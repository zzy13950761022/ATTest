=== Run Tests ===
...FF.....                                                               [100%]
================================== FAILURES ===================================
_____________________ test_tensor_property_access_methods _____________________

    def test_tensor_property_access_methods():
        """TC-04: Tensor属性访问方法
    
        Test plan: TC-04
        Priority: High
        Assertion level: weak
        """
        # Create a graph for testing
        graph = ops.Graph()
    
        with graph.as_default():
            # Create a tensor with specific properties
            # Parameters from test plan: dtype=int32, shape=[4, 4], device=cpu
            tensor = tf.constant(
                np.ones((4, 4), dtype=np.int32),
                dtype=tf.int32,
                name="property_test_tensor"
            )
    
        # Weak assertions from test plan
        # 1. dtype_accessible
        dtype = tensor.dtype
        assert dtype is not None
        assert dtype == tf.int32
        assert isinstance(dtype, tf.DType)
    
        # 2. shape_accessible
        shape = tensor.shape
        assert shape is not None
        assert shape.as_list() == [4, 4]
        assert shape.rank == 2
        assert shape.dims is not None
        assert len(shape.dims) == 2
        assert shape.dims[0].value == 4
        assert shape.dims[1].value == 4
    
        # 3. device_accessible
        device = tensor.device
        assert device is not None
        # Device could be empty string or specific device string
        assert isinstance(device, str)
    
        # 4. name_accessible
        name = tensor.name
        assert name is not None
        assert isinstance(name, str)
        assert name == "property_test_tensor:0"
    
        # Additional property access tests
        # Test op property
        op = tensor.op
        assert op is not None
        assert op.name == "property_test_tensor"
        assert op.type == "Const"
        assert op.graph is graph
    
        # Test value_index property
        value_index = tensor.value_index
        assert value_index == 0
    
        # Test graph property
        tensor_graph = tensor.graph
        assert tensor_graph is graph
    
        # Test consumers property
        consumers = tensor.consumers()
        assert consumers is not None
        # Initially no consumers
        assert len(consumers) == 0
    
        # Add a consumer and test again
        with graph.as_default():
            add_op = tf.add(tensor, 1, name="add_consumer")
            consumers_after = tensor.consumers()
            assert len(consumers_after) > 0
            assert add_op.op in consumers_after
    
        # Test tensor ID (unique identifier)
        tensor_id = tensor._id
        assert tensor_id is not None
    
        # Test tensor string conversion methods
        # __str__ method
        str_repr = str(tensor)
        assert "Tensor" in str_repr
        assert "property_test_tensor:0" in str_repr
        assert "shape=(4, 4)" in str_repr or "shape=[4, 4]" in str_repr
        assert "dtype=int32" in str_repr
    
        # __repr__ method
        repr_str = repr(tensor)
        assert "Tensor" in repr_str
    
        # Test tensor equality and hash
        # Tensors should be comparable by identity
        with graph.as_default():
            same_tensor = graph.get_tensor_by_name("property_test_tensor:0")
            assert same_tensor is tensor
            assert hash(same_tensor) == hash(tensor)
    
            # Different tensor should not be equal
            other_tensor = tf.constant(1, dtype=tf.int32, name="other")
            assert other_tensor is not tensor
            assert hash(other_tensor) != hash(tensor)
    
        # Test tensor property immutability
        # These properties should be read-only
        # We can't directly test immutability by assignment since they're properties
        # But we can verify they return consistent values
    
        original_properties = {
            'dtype': tensor.dtype,
            'shape': tensor.shape.as_list(),
            'name': tensor.name,
            'device': tensor.device
        }
    
        # Access multiple times to ensure consistency
        for _ in range(3):
            assert tensor.dtype == original_properties['dtype']
            assert tensor.shape.as_list() == original_properties['shape']
            assert tensor.name == original_properties['name']
            assert tensor.device == original_properties['device']
    
        # Test tensor in different contexts
        # Tensor should maintain properties across contexts
        # In TensorFlow 2.x, we use Eager Execution instead of tf.Session
        # Create a function to evaluate the tensor
        @tf.function
        def evaluate_tensor(t):
            return t
    
        # Evaluate tensor using tf.function
>       result = evaluate_tensor(tensor)

tests\test_tensorflow_python_framework_ops.py:450: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\util\traceback_utils.py:153: in error_handler
    raise e.with_traceback(filtered_tb) from None
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

op_name = '__inference_evaluate_tensor_25', num_outputs = 1
inputs = [<tf.Tensor 'property_test_tensor:0' shape=(4, 4) dtype=int32>]
attrs = ('executor_type', '', 'config_proto', b'\n\x07\n\x03CPU\x10\x01\n\x07\n\x03GPU\x10\x002\x02J\x008\x01\x82\x01\x00')
ctx = <tensorflow.python.eager.context.Context object at 0x00000264BC461B20>
name = None

    def quick_execute(op_name, num_outputs, inputs, attrs, ctx, name=None):
      """Execute a TensorFlow operation.
    
      Args:
        op_name: Name of the TensorFlow operation (see REGISTER_OP in C++ code) to
          execute.
        num_outputs: The number of outputs of the operation to fetch. (Explicitly
          provided instead of being inferred for performance reasons).
        inputs: A list of inputs to the operation. Each entry should be a Tensor, or
          a value which can be passed to the Tensor constructor to create one.
        attrs: A tuple with alternating string attr names and attr values for this
          operation.
        ctx: The value of context.context().
        name: Customized name for the operation.
    
      Returns:
        List of output Tensor objects. The list is empty if there are no outputs
    
      Raises:
        An exception on error.
      """
      device_name = ctx.device_name
      # pylint: disable=protected-access
      try:
        ctx.ensure_initialized()
>       tensors = pywrap_tfe.TFE_Py_Execute(ctx._handle, device_name, op_name,
                                            inputs, attrs, num_outputs)
E                                           TypeError: <tf.Tensor 'property_test_tensor:0' shape=(4, 4) dtype=int32> is out of scope and cannot be used here. Use return values, explicit Python locals or TensorFlow collections to access it.
E                                           Please see https://www.tensorflow.org/guide/function#all_outputs_of_a_tffunction_must_be_return_values for more information.
E                                           
E                                           <tf.Tensor 'property_test_tensor:0' shape=(4, 4) dtype=int32> was defined here:
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\runpy.py", line 197, in _run_module_as_main
E                                                 return _run_code(code, main_globals, None,
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\runpy.py", line 87, in _run_code
E                                                 exec(code, run_globals)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pytest\__main__.py", line 9, in <module>
E                                                 raise SystemExit(pytest.console_main())
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\config\__init__.py", line 201, in console_main
E                                                 code = main()
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\config\__init__.py", line 175, in main
E                                                 ret: ExitCode | int = config.hook.pytest_cmdline_main(config=config)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_hooks.py", line 512, in __call__
E                                                 return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
E                                                 return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_callers.py", line 121, in _multicall
E                                                 res = hook_impl.function(*args)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\main.py", line 330, in pytest_cmdline_main
E                                                 return wrap_session(config, _main)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\main.py", line 283, in wrap_session
E                                                 session.exitstatus = doit(config, session) or 0
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\main.py", line 337, in _main
E                                                 config.hook.pytest_runtestloop(session=session)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_hooks.py", line 512, in __call__
E                                                 return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
E                                                 return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_callers.py", line 121, in _multicall
E                                                 res = hook_impl.function(*args)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\main.py", line 362, in pytest_runtestloop
E                                                 item.config.hook.pytest_runtest_protocol(item=item, nextitem=nextitem)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_hooks.py", line 512, in __call__
E                                                 return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
E                                                 return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_callers.py", line 121, in _multicall
E                                                 res = hook_impl.function(*args)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\runner.py", line 113, in pytest_runtest_protocol
E                                                 runtestprotocol(item, nextitem=nextitem)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\runner.py", line 132, in runtestprotocol
E                                                 reports.append(call_and_report(item, "call", log))
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\runner.py", line 241, in call_and_report
E                                                 call = CallInfo.from_call(
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\runner.py", line 341, in from_call
E                                                 result: TResult | None = func()
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\runner.py", line 242, in <lambda>
E                                                 lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_hooks.py", line 512, in __call__
E                                                 return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
E                                                 return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_callers.py", line 121, in _multicall
E                                                 res = hook_impl.function(*args)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\runner.py", line 174, in pytest_runtest_call
E                                                 item.runtest()
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\python.py", line 1627, in runtest
E                                                 self.ihook.pytest_pyfunc_call(pyfuncitem=self)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_hooks.py", line 512, in __call__
E                                                 return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
E                                                 return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\pluggy\_callers.py", line 121, in _multicall
E                                                 res = hook_impl.function(*args)
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\_pytest\python.py", line 159, in pytest_pyfunc_call
E                                                 result = testfunction(**testargs)
E                                               File "D:\Project\TestAgent-CLI-main\exam\tensorflow\python.framework.ops\tests\test_tensorflow_python_framework_ops.py", line 330, in test_tensor_property_access_methods
E                                                 tensor = tf.constant(
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\constant_op.py", line 267, in constant
E                                                 return _constant_impl(value, dtype, shape, name, verify_shape=False,
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\constant_op.py", line 289, in _constant_impl
E                                                 const_tensor = g._create_op_internal(  # pylint: disable=protected-access
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\ops.py", line 3776, in _create_op_internal
E                                                 ret = Operation(
E                                               File "D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\ops.py", line 2175, in __init__
E                                                 self._traceback = tf_stack.extract_stack_for_node(self._c_op)
E                                           
E                                           The tensor <tf.Tensor 'property_test_tensor:0' shape=(4, 4) dtype=int32> cannot be accessed from here, because it was defined in <tensorflow.python.framework.ops.Graph object at 0x00000264C37C29A0>, which is out of scope.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\execute.py:54: TypeError
---------------------------- Captured stderr call -----------------------------
2026-01-20 15:02:03.745909: I tensorflow/core/platform/cpu_feature_guard.cc:151] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX AVX2
To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.
___________________ test_convert_to_tensor_basic_conversion ___________________

    def test_convert_to_tensor_basic_conversion():
        """TC-08: convert_to_tensor基本转换
    
        Test plan: TC-08
        Priority: High
        Assertion level: weak
        """
        # Parameters from test plan: input_type=numpy_array, dtype=float32, shape=[3, 3], data=random
    
        # Create test data
        np.random.seed(42)
        numpy_array = np.random.randn(3, 3).astype(np.float32)
    
        # Test conversion using TensorFlow's convert_to_tensor
        # Note: tf.convert_to_tensor is the public API
        tensor = tf.convert_to_tensor(numpy_array, dtype=tf.float32)
    
        # Weak assertions from test plan
        # 1. conversion_success
        assert tensor is not None
        assert isinstance(tensor, tf.Tensor)
    
        # 2. dtype_matches
        assert tensor.dtype == tf.float32
    
        # 3. shape_matches
        assert tensor.shape.as_list() == [3, 3]
    
        # 4. value_preserved
        # In TensorFlow 2.x, we can directly convert tensor to numpy for value checking
        tensor_value = tensor.numpy()
        # Check shape and dtype match
        assert tensor_value.shape == (3, 3)
        assert tensor_value.dtype == np.float32
        # Check values are close (allow for floating point differences)
        np.testing.assert_array_almost_equal(tensor_value, numpy_array, decimal=5)
    
        # Additional conversion tests
    
        # Test without explicit dtype (should infer from numpy array)
        tensor_inferred = tf.convert_to_tensor(numpy_array)
        assert tensor_inferred.dtype == tf.float32
        assert tensor_inferred.shape.as_list() == [3, 3]
    
        # Test with name parameter
        tensor_named = tf.convert_to_tensor(numpy_array, dtype=tf.float32, name="named_tensor")
>       assert tensor_named.name == "named_tensor:0"

tests\test_tensorflow_python_framework_ops.py:527: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\ops.py:513: in __getattr__
    self.__getattribute__(name)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <tf.Tensor: shape=(3, 3), dtype=float32, numpy=
array([[ 0.49671414, -0.1382643 ,  0.64768857],
       [ 1.5230298 , -0.23415338, -0.23413695],
       [ 1.5792128 ,  0.7674347 , -0.46947438]], dtype=float32)>

    @property
    def name(self):
>     raise AttributeError(
          "Tensor.name is meaningless when eager execution is enabled.")
E     AttributeError: Tensor.name is meaningless when eager execution is enabled.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\ops.py:1384: AttributeError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                            Stmts   Miss Branch BrPart  Cover   Missing
-------------------------------------------------------------------------------------------
tests\test_tensorflow_python_framework_ops.py     327     71     20      1    77%   30, 35, 39-42, 46-54, 58-61, 447, 454-465, 530-600, 707-708
-------------------------------------------------------------------------------------------
TOTAL                                             327     71     20      1    77%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_framework_ops.py::test_tensor_property_access_methods
FAILED tests\test_tensorflow_python_framework_ops.py::test_convert_to_tensor_basic_conversion
2 failed, 8 passed in 1.74s

Error: exit 1