"""
Test cases for tensorflow.python.ops.signal.fft_ops module.
Generated by ATTest for target: tensorflow.python.ops.signal.fft_ops
"""

import numpy as np
import tensorflow as tf
import pytest
from tensorflow.python.ops.signal import fft_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# ==== BLOCK:HEADER START ====
# Test class and helper functions
class TestFFTOps:
    """Test class for tensorflow.python.ops.signal.fft_ops module."""
    
    @staticmethod
    def create_test_tensor(shape, dtype):
        """Create test tensor with given shape and dtype."""
        # Handle scalar case (empty shape)
        if shape == ():
            if dtype in [tf.float32, tf.float64]:
                return tf.constant(np.random.randn(), dtype=dtype)
            elif dtype in [tf.complex64, tf.complex128]:
                real = np.random.randn()
                imag = np.random.randn()
                return tf.constant(real + 1j * imag, dtype=dtype)
            else:
                raise ValueError(f"Unsupported dtype: {dtype}")
        
        # Normal case (non-empty shape)
        if dtype in [tf.float32, tf.float64]:
            return tf.constant(np.random.randn(*shape).astype(dtype.as_numpy_dtype))
        elif dtype in [tf.complex64, tf.complex128]:
            real = np.random.randn(*shape).astype(dtype.real_dtype.as_numpy_dtype)
            imag = np.random.randn(*shape).astype(dtype.real_dtype.as_numpy_dtype)
            return tf.constant(real + 1j * imag)
        else:
            raise ValueError(f"Unsupported dtype: {dtype}")
    
    @staticmethod
    def assert_tensor_properties(tensor, expected_shape, expected_dtype):
        """Assert basic tensor properties."""
        assert tensor.shape == expected_shape, f"Expected shape {expected_shape}, got {tensor.shape}"
        assert tensor.dtype == expected_dtype, f"Expected dtype {expected_dtype}, got {tensor.dtype}"
        
        # Check finite values - handle complex types differently
        if tensor.dtype in [tf.float32, tf.float64]:
            # Real types: use tf.math.is_finite
            assert tf.reduce_all(tf.math.is_finite(tensor)), "Tensor contains non-finite values"
        elif tensor.dtype in [tf.complex64, tf.complex128]:
            # Complex types: check real and imaginary parts separately
            real_part = tf.math.real(tensor)
            imag_part = tf.math.imag(tensor)
            assert tf.reduce_all(tf.math.is_finite(real_part)), "Tensor real part contains non-finite values"
            assert tf.reduce_all(tf.math.is_finite(imag_part)), "Tensor imaginary part contains non-finite values"
        else:
            raise ValueError(f"Unsupported dtype for finite check: {tensor.dtype}")
    
    @staticmethod
    def assert_allclose(actual, expected, rtol=1e-6, atol=1e-6):
        """Assert that two tensors are close within tolerance."""
        np.testing.assert_allclose(
            actual.numpy() if hasattr(actual, 'numpy') else actual,
            expected.numpy() if hasattr(expected, 'numpy') else expected,
            rtol=rtol,
            atol=atol
        )
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
@pytest.mark.parametrize("dtype,shape,axes", [
    (tf.float32, (10,), None),  # Base case from test plan
    (tf.float64, (12,), None),  # Parameter extension: different dtype
    (tf.float32, (6, 6), [0, 1]),  # Parameter extension: 2D tensor with multiple axes
])
def test_fftshift_basic(dtype, shape, axes):
    """Test basic functionality of fftshift."""
    # Create test instance
    test_instance = TestFFTOps()
    
    # Create test tensor
    x = test_instance.create_test_tensor(shape, dtype)
    
    # Compute TensorFlow fftshift
    tf_result = fft_ops.fftshift(x, axes=axes)
    
    # Compute NumPy reference
    np_x = x.numpy()
    np_result = np.fft.fftshift(np_x, axes=axes)
    
    # Weak assertions
    test_instance.assert_tensor_properties(tf_result, shape, dtype)
    
    # Basic property check: fftshift should preserve shape and dtype
    assert tf_result.shape == x.shape, "fftshift should preserve shape"
    assert tf_result.dtype == x.dtype, "fftshift should preserve dtype"
    
    # Check that result contains finite values
    assert tf.reduce_all(tf.math.is_finite(tf_result)), "Result contains non-finite values"
    
    # Compare with NumPy (weak assertion with tolerance)
    test_instance.assert_allclose(tf_result, np_result, rtol=1e-6, atol=1e-6)
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
@pytest.mark.parametrize("dtype,shape,axes", [
    (tf.complex64, (8,), None),  # Base case from test plan
    (tf.complex128, (16,), None),  # Parameter extension: different complex precision
    (tf.complex64, (4, 4), None),  # Parameter extension: 2D complex FFT
])
def test_fft_ifft_inverse(dtype, shape, axes):
    """Test that fft and ifft are inverse operations."""
    # Create test instance
    test_instance = TestFFTOps()
    
    # Create complex test tensor
    x = test_instance.create_test_tensor(shape, dtype)
    
    # Compute forward FFT
    x_fft = fft_ops.fft(x)
    
    # Compute inverse FFT
    x_reconstructed = fft_ops.ifft(x_fft)
    
    # Weak assertions
    test_instance.assert_tensor_properties(x_fft, shape, dtype)
    test_instance.assert_tensor_properties(x_reconstructed, shape, dtype)
    
    # Basic property: FFT should preserve shape
    assert x_fft.shape == x.shape, "FFT should preserve shape"
    assert x_reconstructed.shape == x.shape, "IFFT should preserve shape"
    
    # Basic property: FFT should preserve dtype
    assert x_fft.dtype == x.dtype, "FFT should preserve dtype"
    assert x_reconstructed.dtype == x.dtype, "IFFT should preserve dtype"
    
    # Basic inverse property: ifft(fft(x)) should be close to x
    # Using weak assertion with tolerance
    test_instance.assert_allclose(x_reconstructed, x, rtol=1e-6, atol=1e-6)
    
    # Compare with NumPy FFT (weak assertion)
    np_x = x.numpy()
    np_fft = np.fft.fft(np_x, axis=-1)
    test_instance.assert_allclose(x_fft, np_fft, rtol=1e-6, atol=1e-6)
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_03 START ====
@pytest.mark.parametrize("dtype,shape,fft_length", [
    (tf.float32, (8,), 8),  # Base case from test plan
    (tf.float64, (16,), 16),  # Parameter extension: different real precision
])
def test_rfft_irfft_real_transform(dtype, shape, fft_length):
    """Test real-valued FFT and inverse real FFT."""
    # Create test instance
    test_instance = TestFFTOps()
    
    # Create real test tensor
    x = test_instance.create_test_tensor(shape, dtype)
    
    # Convert fft_length to TensorFlow tensor with shape [1]
    fft_length_tensor = tf.constant([fft_length], dtype=tf.int32)
    
    # Compute RFFT
    x_rfft = fft_ops.rfft(x, fft_length=fft_length_tensor)
    
    # Compute IRFFT
    x_reconstructed = fft_ops.irfft(x_rfft, fft_length=fft_length_tensor)
    
    # Expected shape for RFFT output
    # For 1D RFFT with length N, output shape is (N//2 + 1,)
    expected_rfft_shape = (fft_length // 2 + 1,)
    
    # Weak assertions
    # Check RFFT output properties
    assert x_rfft.shape == expected_rfft_shape, f"RFFT shape mismatch: expected {expected_rfft_shape}, got {x_rfft.shape}"
    
    # Check dtype: RFFT of real input should produce complex output
    if dtype == tf.float32:
        expected_complex_dtype = tf.complex64
    else:  # tf.float64
        expected_complex_dtype = tf.complex128
    assert x_rfft.dtype == expected_complex_dtype, f"RFFT dtype mismatch: expected {expected_complex_dtype}, got {x_rfft.dtype}"
    
    # Check IRFFT output properties
    assert x_reconstructed.shape == shape, f"IRFFT shape mismatch: expected {shape}, got {x_reconstructed.shape}"
    assert x_reconstructed.dtype == dtype, f"IRFFT dtype mismatch: expected {dtype}, got {x_reconstructed.dtype}"
    
    # Check that results contain finite values
    test_instance.assert_tensor_properties(x_rfft, expected_rfft_shape, expected_complex_dtype)
    test_instance.assert_tensor_properties(x_reconstructed, shape, dtype)
    
    # Basic property: irfft(rfft(x)) should be close to original x
    # Note: For real FFT, we need to handle potential padding/truncation
    # Compare only the valid part (up to min(shape[0], fft_length))
    valid_length = min(shape[0], fft_length)
    x_valid = x[:valid_length]
    x_reconstructed_valid = x_reconstructed[:valid_length]
    
    test_instance.assert_allclose(x_reconstructed_valid, x_valid, rtol=1e-6, atol=1e-6)
    
    # Compare with NumPy RFFT (weak assertion)
    np_x = x.numpy()
    np_rfft = np.fft.rfft(np_x, n=fft_length)
    test_instance.assert_allclose(x_rfft, np_rfft, rtol=1e-6, atol=1e-6)
# ==== BLOCK:CASE_03 END ====

# ==== BLOCK:CASE_04 START ====
@pytest.mark.parametrize("dtype,shape,axes", [
    (tf.float32, (4, 4), 0),  # Base case from test plan: 2D tensor, axis 0
    (tf.float32, (3, 3, 3), -1),  # Parameter extension: 3D tensor, negative axis index
])
def test_axis_parameter_handling(dtype, shape, axes):
    """Test handling of different axis parameters."""
    # Create test instance
    test_instance = TestFFTOps()
    
    # Create test tensor
    x = test_instance.create_test_tensor(shape, dtype)
    
    # Compute TensorFlow fftshift
    tf_result = fft_ops.fftshift(x, axes=axes)
    
    # Compute NumPy reference
    np_x = x.numpy()
    np_result = np.fft.fftshift(np_x, axes=axes)
    
    # Weak assertions
    test_instance.assert_tensor_properties(tf_result, shape, dtype)
    
    # Basic property check: fftshift should preserve shape and dtype
    assert tf_result.shape == x.shape, "fftshift should preserve shape"
    assert tf_result.dtype == x.dtype, "fftshift should preserve dtype"
    
    # Compare with NumPy (weak assertion with tolerance)
    test_instance.assert_allclose(tf_result, np_result, rtol=1e-6, atol=1e-6)
    
    # Test ifftshift as inverse operation
    tf_inverse = fft_ops.ifftshift(tf_result, axes=axes)
    test_instance.assert_allclose(tf_inverse, x, rtol=1e-6, atol=1e-6)
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
@pytest.mark.parametrize("dtype,shape,axes", [
    (tf.float32, (1,), None),  # Base case from test plan: single element tensor
    (tf.float32, (), None),  # Parameter extension: empty tensor (scalar)
])
def test_edge_case_handling(dtype, shape, axes):
    """Test edge case handling for fftshift."""
    # Create test instance
    test_instance = TestFFTOps()
    
    # Create test tensor - handle scalar case specially
    if shape == ():  # Scalar case
        if dtype in [tf.float32, tf.float64]:
            x = tf.constant(np.random.randn(), dtype=dtype)
        elif dtype in [tf.complex64, tf.complex128]:
            real = np.random.randn()
            imag = np.random.randn()
            x = tf.constant(real + 1j * imag, dtype=dtype)
        else:
            raise ValueError(f"Unsupported dtype: {dtype}")
    else:
        x = test_instance.create_test_tensor(shape, dtype)
    
    # Compute TensorFlow fftshift
    tf_result = fft_ops.fftshift(x, axes=axes)
    
    # Compute NumPy reference
    np_x = x.numpy()
    np_result = np.fft.fftshift(np_x, axes=axes)
    
    # Weak assertions
    test_instance.assert_tensor_properties(tf_result, shape, dtype)
    
    # Basic property check: fftshift should preserve shape and dtype
    assert tf_result.shape == x.shape, "fftshift should preserve shape"
    assert tf_result.dtype == x.dtype, "fftshift should preserve dtype"
    
    # Check that result contains finite values
    if tf_result.shape.num_elements() > 0:  # Skip check for empty tensors
        assert tf.reduce_all(tf.math.is_finite(tf_result)), "Result contains non-finite values"
    
    # Compare with NumPy (weak assertion with tolerance)
    test_instance.assert_allclose(tf_result, np_result, rtol=1e-6, atol=1e-6)
    
    # Test ifftshift as inverse operation
    tf_inverse = fft_ops.ifftshift(tf_result, axes=axes)
    test_instance.assert_allclose(tf_inverse, x, rtol=1e-6, atol=1e-6)
    
    # Additional edge case tests
    
    # Test with explicit axes parameter for 1D tensor
    if len(shape) == 1:
        # Test with axes=0 explicitly
        tf_result_axis0 = fft_ops.fftshift(x, axes=0)
        np_result_axis0 = np.fft.fftshift(np_x, axes=0)
        test_instance.assert_allclose(tf_result_axis0, np_result_axis0, rtol=1e-6, atol=1e-6)
        
        # Test inverse with explicit axis
        tf_inverse_axis0 = fft_ops.ifftshift(tf_result_axis0, axes=0)
        test_instance.assert_allclose(tf_inverse_axis0, x, rtol=1e-6, atol=1e-6)
    
    # Test that fftshift of a single element tensor returns the same tensor
    if shape == (1,):
        test_instance.assert_allclose(tf_result, x, rtol=1e-6, atol=1e-6)
    
    # Test that fftshift of an empty tensor returns an empty tensor
    if shape == ():
        # Empty tensor (scalar) should return the same
        test_instance.assert_allclose(tf_result, x, rtol=1e-6, atol=1e-6)
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:FOOTER START ====
# Footer block for cleanup and additional assertions
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
# ==== BLOCK:FOOTER END ====