=== Run Tests ===
FFF..FFFF.                                                               [100%]
================================== FAILURES ===================================
_ test_assert_equal_eager_mode[assert_equal-x_shape0-y_shape0-float32-eager] __

func_name = 'assert_equal', x_shape = [2, 2], y_shape = [2, 2]
dtype = 'float32', mode = 'eager'
mock_executing_eagerly = <MagicMock name='executing_eagerly' id='2673836083328'>
mock_constant_value = <MagicMock name='constant_value' id='2673836173344'>
mock_equal = <MagicMock name='equal' id='2673836189632'>
mock_greater = <MagicMock name='greater' id='2673836210016'>

    @pytest.mark.parametrize(
        "func_name,x_shape,y_shape,dtype,mode",
        [
            ("assert_equal", [2, 2], [2, 2], "float32", "eager"),
            # Parameter extensions from test_plan.json
            ("assert_equal", [4, 4], [4, 4], "float64", "eager"),
            ("assert_greater", [2, 2], [2, 2], "float32", "eager"),
        ]
    )
    def test_assert_equal_eager_mode(
        func_name, x_shape, y_shape, dtype, mode,
        mock_executing_eagerly, mock_constant_value, mock_equal, mock_greater
    ):
        """
        Test assert_equal and similar functions in eager mode.
    
        Weak assertions:
        - returns_none: Function should return None in eager mode
        - no_exception: No exception should be raised
    
        Parameters from test_plan.json:
        - func: assert_equal (and extensions)
        - x_shape: [2, 2], [4, 4], [2, 2]
        - y_shape: [2, 2], [4, 4], [2, 2]
        - dtype: float32, float64, float32
        - mode: eager
        """
        # Setup mocks
        mock_executing_eagerly.return_value = True  # Eager mode
        mock_constant_value.return_value = None  # Dynamic check required
    
        # Create tensors
        x = create_tensor(x_shape, dtype)
        y = create_tensor(y_shape, dtype)
    
        # Mock tensor properties for graph mode
        # In graph mode, tensors should have a name attribute
        # Use property mock to avoid AttributeError
        with patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name, \
             patch.object(type(y), 'name', create=True, new_callable=PropertyMock) as mock_y_name:
            mock_x_name.return_value = "x_tensor"
            mock_y_name.return_value = "y_tensor"
    
        # Mock the comparison operation
        comparison_result = tf.constant(True)
        if func_name == "assert_equal":
            mock_equal.return_value = comparison_result
        elif func_name == "assert_greater":
            mock_greater.return_value = comparison_result
    
        # Get the function to test
        func = getattr(check_ops, func_name)
    
        # Execute the function
        result = func(x, y)
    
        # Weak assertion: returns_none
        assert result is None, f"{func_name} should return None in eager mode, got {result}"
    
        # Weak assertion: no_exception (implicitly passed if we reach here)
    
        # Verify mocks were called as expected
>       mock_executing_eagerly.assert_called_once()

tests\test_tensorflow_python_ops_check_ops.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='executing_eagerly' id='2673836083328'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'executing_eagerly' to have been called once. Called 5 times.
E           Calls: [call(), call(), call(), call(), call()].

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:886: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 15:53:56.008138: I tensorflow/core/platform/cpu_feature_guard.cc:151] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX AVX2
To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.
_ test_assert_equal_eager_mode[assert_equal-x_shape1-y_shape1-float64-eager] __

func_name = 'assert_equal', x_shape = [4, 4], y_shape = [4, 4]
dtype = 'float64', mode = 'eager'
mock_executing_eagerly = <MagicMock name='executing_eagerly' id='2673836226640'>
mock_constant_value = <MagicMock name='constant_value' id='2673856147952'>
mock_equal = <MagicMock name='equal' id='2673855873472'>
mock_greater = <MagicMock name='greater' id='2673855877472'>

    @pytest.mark.parametrize(
        "func_name,x_shape,y_shape,dtype,mode",
        [
            ("assert_equal", [2, 2], [2, 2], "float32", "eager"),
            # Parameter extensions from test_plan.json
            ("assert_equal", [4, 4], [4, 4], "float64", "eager"),
            ("assert_greater", [2, 2], [2, 2], "float32", "eager"),
        ]
    )
    def test_assert_equal_eager_mode(
        func_name, x_shape, y_shape, dtype, mode,
        mock_executing_eagerly, mock_constant_value, mock_equal, mock_greater
    ):
        """
        Test assert_equal and similar functions in eager mode.
    
        Weak assertions:
        - returns_none: Function should return None in eager mode
        - no_exception: No exception should be raised
    
        Parameters from test_plan.json:
        - func: assert_equal (and extensions)
        - x_shape: [2, 2], [4, 4], [2, 2]
        - y_shape: [2, 2], [4, 4], [2, 2]
        - dtype: float32, float64, float32
        - mode: eager
        """
        # Setup mocks
        mock_executing_eagerly.return_value = True  # Eager mode
        mock_constant_value.return_value = None  # Dynamic check required
    
        # Create tensors
        x = create_tensor(x_shape, dtype)
        y = create_tensor(y_shape, dtype)
    
        # Mock tensor properties for graph mode
        # In graph mode, tensors should have a name attribute
        # Use property mock to avoid AttributeError
        with patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name, \
             patch.object(type(y), 'name', create=True, new_callable=PropertyMock) as mock_y_name:
            mock_x_name.return_value = "x_tensor"
            mock_y_name.return_value = "y_tensor"
    
        # Mock the comparison operation
        comparison_result = tf.constant(True)
        if func_name == "assert_equal":
            mock_equal.return_value = comparison_result
        elif func_name == "assert_greater":
            mock_greater.return_value = comparison_result
    
        # Get the function to test
        func = getattr(check_ops, func_name)
    
        # Execute the function
        result = func(x, y)
    
        # Weak assertion: returns_none
        assert result is None, f"{func_name} should return None in eager mode, got {result}"
    
        # Weak assertion: no_exception (implicitly passed if we reach here)
    
        # Verify mocks were called as expected
>       mock_executing_eagerly.assert_called_once()

tests\test_tensorflow_python_ops_check_ops.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='executing_eagerly' id='2673836226640'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'executing_eagerly' to have been called once. Called 5 times.
E           Calls: [call(), call(), call(), call(), call()].

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:886: AssertionError
_ test_assert_equal_eager_mode[assert_greater-x_shape2-y_shape2-float32-eager] _

func_name = 'assert_greater', x_shape = [2, 2], y_shape = [2, 2]
dtype = 'float32', mode = 'eager'
mock_executing_eagerly = <MagicMock name='executing_eagerly' id='2673855411872'>
mock_constant_value = <MagicMock name='constant_value' id='2673855343536'>
mock_equal = <MagicMock name='equal' id='2673855302480'>
mock_greater = <MagicMock name='greater' id='2673855601392'>

    @pytest.mark.parametrize(
        "func_name,x_shape,y_shape,dtype,mode",
        [
            ("assert_equal", [2, 2], [2, 2], "float32", "eager"),
            # Parameter extensions from test_plan.json
            ("assert_equal", [4, 4], [4, 4], "float64", "eager"),
            ("assert_greater", [2, 2], [2, 2], "float32", "eager"),
        ]
    )
    def test_assert_equal_eager_mode(
        func_name, x_shape, y_shape, dtype, mode,
        mock_executing_eagerly, mock_constant_value, mock_equal, mock_greater
    ):
        """
        Test assert_equal and similar functions in eager mode.
    
        Weak assertions:
        - returns_none: Function should return None in eager mode
        - no_exception: No exception should be raised
    
        Parameters from test_plan.json:
        - func: assert_equal (and extensions)
        - x_shape: [2, 2], [4, 4], [2, 2]
        - y_shape: [2, 2], [4, 4], [2, 2]
        - dtype: float32, float64, float32
        - mode: eager
        """
        # Setup mocks
        mock_executing_eagerly.return_value = True  # Eager mode
        mock_constant_value.return_value = None  # Dynamic check required
    
        # Create tensors
        x = create_tensor(x_shape, dtype)
        y = create_tensor(y_shape, dtype)
    
        # Mock tensor properties for graph mode
        # In graph mode, tensors should have a name attribute
        # Use property mock to avoid AttributeError
        with patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name, \
             patch.object(type(y), 'name', create=True, new_callable=PropertyMock) as mock_y_name:
            mock_x_name.return_value = "x_tensor"
            mock_y_name.return_value = "y_tensor"
    
        # Mock the comparison operation
        comparison_result = tf.constant(True)
        if func_name == "assert_equal":
            mock_equal.return_value = comparison_result
        elif func_name == "assert_greater":
            mock_greater.return_value = comparison_result
    
        # Get the function to test
        func = getattr(check_ops, func_name)
    
        # Execute the function
        result = func(x, y)
    
        # Weak assertion: returns_none
        assert result is None, f"{func_name} should return None in eager mode, got {result}"
    
        # Weak assertion: no_exception (implicitly passed if we reach here)
    
        # Verify mocks were called as expected
>       mock_executing_eagerly.assert_called_once()

tests\test_tensorflow_python_ops_check_ops.py:158: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='executing_eagerly' id='2673855411872'>

    def assert_called_once(self):
        """assert that the mock was called only once.
        """
        if not self.call_count == 1:
            msg = ("Expected '%s' to have been called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'executing_eagerly' to have been called once. Called 4 times.
E           Calls: [call(), call(), call(), call()].

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:886: AssertionError
_ test_assert_less_static_failure[assert_less-x_shape0-y_shape0-float64-static_fail] _

func_name = 'assert_less', x_shape = [2], y_shape = [2], dtype = 'float64'
mode = 'static_fail'
mock_constant_value = <MagicMock name='constant_value' id='2673855571136'>
mock_less = <MagicMock name='less' id='2673855391008'>

    @pytest.mark.parametrize(
        "func_name,x_shape,y_shape,dtype,mode",
        [
            ("assert_less", [2], [2], "float64", "static_fail"),
            # Parameter extensions from test_plan.json
            ("assert_less", [3], [3], "float32", "static_fail"),
        ]
    )
    def test_assert_less_static_failure(
        func_name, x_shape, y_shape, dtype, mode,
        mock_constant_value, mock_less
    ):
        """
        Test assert_less with static failure (immediate exception).
    
        Weak assertions:
        - raises_invalid_argument_error: Should raise InvalidArgumentError
        - error_type_correct: Error type should be correct
    
        Parameters from test_plan.json:
        - func: assert_less
        - x_shape: [2], [3]
        - y_shape: [2], [3]
        - dtype: float64, float32
        - mode: static_fail
        """
        # Setup mocks for static failure
        # For static failure, constant_value returns False (condition fails)
        mock_constant_value.return_value = False
    
        # Create tensors where x > y to trigger failure
        x = create_tensor(x_shape, dtype, value=10.0)  # x = 10
        y = create_tensor(y_shape, dtype, value=5.0)   # y = 5
    
        # Mock the comparison operation (won't be called in static failure)
        comparison_result = tf.constant(False)
        mock_less.return_value = comparison_result
    
        # Get the function to test
        func = getattr(check_ops, func_name)
    
        # Weak assertion: raises_invalid_argument_error
        with pytest.raises(tf.errors.InvalidArgumentError) as exc_info:
            func(x, y)
    
        # Weak assertion: error_type_correct
        # The actual error message may vary, but it should be an InvalidArgumentError
        error_msg = str(exc_info.value).lower()
        # Accept various error message formats that indicate assertion failure
        assert any(keyword in error_msg for keyword in
                   ["assertion", "condition", "failed", "invalid", "where"]), \
               f"Error message should indicate assertion failure, got: {error_msg}"
    
        # Verify mocks were called as expected
>       mock_constant_value.assert_called()

tests\test_tensorflow_python_ops_check_ops.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='constant_value' id='2673855571136'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'constant_value' to have been called.

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:876: AssertionError
_ test_assert_less_static_failure[assert_less-x_shape1-y_shape1-float32-static_fail] _

func_name = 'assert_less', x_shape = [3], y_shape = [3], dtype = 'float32'
mode = 'static_fail'
mock_constant_value = <MagicMock name='constant_value' id='2673855565632'>
mock_less = <MagicMock name='less' id='2673855462656'>

    @pytest.mark.parametrize(
        "func_name,x_shape,y_shape,dtype,mode",
        [
            ("assert_less", [2], [2], "float64", "static_fail"),
            # Parameter extensions from test_plan.json
            ("assert_less", [3], [3], "float32", "static_fail"),
        ]
    )
    def test_assert_less_static_failure(
        func_name, x_shape, y_shape, dtype, mode,
        mock_constant_value, mock_less
    ):
        """
        Test assert_less with static failure (immediate exception).
    
        Weak assertions:
        - raises_invalid_argument_error: Should raise InvalidArgumentError
        - error_type_correct: Error type should be correct
    
        Parameters from test_plan.json:
        - func: assert_less
        - x_shape: [2], [3]
        - y_shape: [2], [3]
        - dtype: float64, float32
        - mode: static_fail
        """
        # Setup mocks for static failure
        # For static failure, constant_value returns False (condition fails)
        mock_constant_value.return_value = False
    
        # Create tensors where x > y to trigger failure
        x = create_tensor(x_shape, dtype, value=10.0)  # x = 10
        y = create_tensor(y_shape, dtype, value=5.0)   # y = 5
    
        # Mock the comparison operation (won't be called in static failure)
        comparison_result = tf.constant(False)
        mock_less.return_value = comparison_result
    
        # Get the function to test
        func = getattr(check_ops, func_name)
    
        # Weak assertion: raises_invalid_argument_error
        with pytest.raises(tf.errors.InvalidArgumentError) as exc_info:
            func(x, y)
    
        # Weak assertion: error_type_correct
        # The actual error message may vary, but it should be an InvalidArgumentError
        error_msg = str(exc_info.value).lower()
        # Accept various error message formats that indicate assertion failure
        assert any(keyword in error_msg for keyword in
                   ["assertion", "condition", "failed", "invalid", "where"]), \
               f"Error message should indicate assertion failure, got: {error_msg}"
    
        # Verify mocks were called as expected
>       mock_constant_value.assert_called()

tests\test_tensorflow_python_ops_check_ops.py:295: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='constant_value' id='2673855565632'>

    def assert_called(self):
        """assert that the mock was called at least once
        """
        if self.call_count == 0:
            msg = ("Expected '%s' to have been called." %
                   (self._mock_name or 'mock'))
>           raise AssertionError(msg)
E           AssertionError: Expected 'constant_value' to have been called.

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:876: AssertionError
__ test_assert_positive_empty_tensor[assert_positive-x_shape0-float32-eager] __

func_name = 'assert_positive', x_shape = [0, 0], dtype = 'float32'
mode = 'eager'
mock_executing_eagerly = <MagicMock name='executing_eagerly' id='2673836172048'>
mock_constant_value = <MagicMock name='constant_value' id='2673855497264'>
mock_greater = <MagicMock name='greater' id='2673855874720'>

    @pytest.mark.parametrize(
        "func_name,x_shape,dtype,mode",
        [
            ("assert_positive", [0, 0], "float32", "eager"),
            # Parameter extensions from test_plan.json
            ("assert_positive", [0], "int32", "graph"),
        ]
    )
    def test_assert_positive_empty_tensor(
        func_name, x_shape, dtype, mode,
        mock_executing_eagerly, mock_constant_value, mock_greater
    ):
        """
        Test assert_positive with empty tensors.
    
        Weak assertions:
        - returns_none: Function should return None in eager mode
        - no_exception: No exception should be raised
    
        Parameters from test_plan.json:
        - func: assert_positive
        - x_shape: [0, 0], [0]
        - dtype: float32, int32
        - mode: eager, graph
        """
        # Setup mocks based on mode
        if mode == "eager":
            mock_executing_eagerly.return_value = True  # Eager mode
        else:  # graph mode
            mock_executing_eagerly.return_value = False  # Graph mode
    
        # For empty tensors, constant_value returns empty array
        mock_constant_value.return_value = np.array([], dtype=np.float32 if dtype == 'float32' else np.int32)
    
        # Create empty tensor
        x = create_tensor(x_shape, dtype, value=1.0)  # Value doesn't matter for empty tensor
    
        # Mock the comparison operation
        # For empty tensor, comparison returns empty tensor
        empty_comparison = tf.constant([], dtype=tf.bool)
        mock_greater.return_value = empty_comparison
    
        # Get the function to test
        func = getattr(check_ops, func_name)
    
        # Execute the function
        if mode == "eager":
            result = func(x)
            # Weak assertion: returns_none (for eager mode)
            assert result is None, f"{func_name} should return None in eager mode for empty tensor"
        else:  # graph mode
            # In graph mode, we need to mock Assert operation and tensor name
            with patch.object(control_flow_ops, 'Assert') as mock_assert, \
                 patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name:
                mock_x_name.return_value = "x_tensor"
                mock_assert_op = Mock()
                mock_assert.return_value = mock_assert_op
                result = func(x)
                # Weak assertion: returns_assert_op (for graph mode)
                assert result == mock_assert_op, f"{func_name} should return Assert operation in graph mode"
                assert mock_assert.call_count >= 1, \
                    f"Assert should be called at least once, was called {mock_assert.call_count} times"
    
        # Weak assertion: no_exception (implicitly passed if we reach here)
    
        # Verify mocks were called as expected
        # Note: executing_eagerly may be called multiple times internally
        assert mock_executing_eagerly.call_count >= 1, \
            f"executing_eagerly should be called at least once, was called {mock_executing_eagerly.call_count} times"
    
>       assert mock_constant_value.call_count >= 1, \
            f"constant_value should be called at least once, was called {mock_constant_value.call_count} times"
E       AssertionError: constant_value should be called at least once, was called 0 times
E       assert 0 >= 1
E        +  where 0 = <MagicMock name='constant_value' id='2673855497264'>.call_count

tests\test_tensorflow_python_ops_check_ops.py:371: AssertionError
___ test_assert_positive_empty_tensor[assert_positive-x_shape1-int32-graph] ___

func_name = 'assert_positive', x_shape = [0], dtype = 'int32', mode = 'graph'
mock_executing_eagerly = <MagicMock name='executing_eagerly' id='2673855335056'>
mock_constant_value = <MagicMock name='constant_value' id='2673855887200'>
mock_greater = <MagicMock name='greater' id='2673836210736'>

    @pytest.mark.parametrize(
        "func_name,x_shape,dtype,mode",
        [
            ("assert_positive", [0, 0], "float32", "eager"),
            # Parameter extensions from test_plan.json
            ("assert_positive", [0], "int32", "graph"),
        ]
    )
    def test_assert_positive_empty_tensor(
        func_name, x_shape, dtype, mode,
        mock_executing_eagerly, mock_constant_value, mock_greater
    ):
        """
        Test assert_positive with empty tensors.
    
        Weak assertions:
        - returns_none: Function should return None in eager mode
        - no_exception: No exception should be raised
    
        Parameters from test_plan.json:
        - func: assert_positive
        - x_shape: [0, 0], [0]
        - dtype: float32, int32
        - mode: eager, graph
        """
        # Setup mocks based on mode
        if mode == "eager":
            mock_executing_eagerly.return_value = True  # Eager mode
        else:  # graph mode
            mock_executing_eagerly.return_value = False  # Graph mode
    
        # For empty tensors, constant_value returns empty array
        mock_constant_value.return_value = np.array([], dtype=np.float32 if dtype == 'float32' else np.int32)
    
        # Create empty tensor
        x = create_tensor(x_shape, dtype, value=1.0)  # Value doesn't matter for empty tensor
    
        # Mock the comparison operation
        # For empty tensor, comparison returns empty tensor
        empty_comparison = tf.constant([], dtype=tf.bool)
        mock_greater.return_value = empty_comparison
    
        # Get the function to test
        func = getattr(check_ops, func_name)
    
        # Execute the function
        if mode == "eager":
            result = func(x)
            # Weak assertion: returns_none (for eager mode)
            assert result is None, f"{func_name} should return None in eager mode for empty tensor"
        else:  # graph mode
            # In graph mode, we need to mock Assert operation and tensor name
            with patch.object(control_flow_ops, 'Assert') as mock_assert, \
                 patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name:
                mock_x_name.return_value = "x_tensor"
                mock_assert_op = Mock()
                mock_assert.return_value = mock_assert_op
                result = func(x)
                # Weak assertion: returns_assert_op (for graph mode)
                assert result == mock_assert_op, f"{func_name} should return Assert operation in graph mode"
                assert mock_assert.call_count >= 1, \
                    f"Assert should be called at least once, was called {mock_assert.call_count} times"
    
        # Weak assertion: no_exception (implicitly passed if we reach here)
    
        # Verify mocks were called as expected
        # Note: executing_eagerly may be called multiple times internally
        assert mock_executing_eagerly.call_count >= 1, \
            f"executing_eagerly should be called at least once, was called {mock_executing_eagerly.call_count} times"
    
        assert mock_constant_value.call_count >= 1, \
            f"constant_value should be called at least once, was called {mock_constant_value.call_count} times"
    
>       assert mock_greater.call_count >= 1, \
            f"greater should be called at least once, was called {mock_greater.call_count} times"
E       AssertionError: greater should be called at least once, was called 0 times
E       assert 0 >= 1
E        +  where 0 = <MagicMock name='greater' id='2673836210736'>.call_count

tests\test_tensorflow_python_ops_check_ops.py:374: AssertionError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                            Stmts   Miss Branch BrPart  Cover   Missing
-------------------------------------------------------------------------------------------
tests\test_tensorflow_python_ops_check_ops.py     152      8     24      3    91%   65-66, 83, 143->147, 160-163, 438
-------------------------------------------------------------------------------------------
TOTAL                                             152      8     24      3    91%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_ops_check_ops.py::test_assert_equal_eager_mode[assert_equal-x_shape0-y_shape0-float32-eager]
FAILED tests\test_tensorflow_python_ops_check_ops.py::test_assert_equal_eager_mode[assert_equal-x_shape1-y_shape1-float64-eager]
FAILED tests\test_tensorflow_python_ops_check_ops.py::test_assert_equal_eager_mode[assert_greater-x_shape2-y_shape2-float32-eager]
FAILED tests\test_tensorflow_python_ops_check_ops.py::test_assert_less_static_failure[assert_less-x_shape0-y_shape0-float64-static_fail]
FAILED tests\test_tensorflow_python_ops_check_ops.py::test_assert_less_static_failure[assert_less-x_shape1-y_shape1-float32-static_fail]
FAILED tests\test_tensorflow_python_ops_check_ops.py::test_assert_positive_empty_tensor[assert_positive-x_shape0-float32-eager]
FAILED tests\test_tensorflow_python_ops_check_ops.py::test_assert_positive_empty_tensor[assert_positive-x_shape1-int32-graph]
7 failed, 3 passed in 2.19s

Error: exit 1