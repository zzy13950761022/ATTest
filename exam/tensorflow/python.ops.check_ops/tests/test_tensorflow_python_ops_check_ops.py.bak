# START:HEADER
"""
Test cases for tensorflow.python.ops.check_ops module.
Generated by ATTest.
"""
import math
import pytest
import numpy as np
from unittest.mock import Mock, patch, MagicMock, PropertyMock
import tensorflow as tf
from tensorflow.python.ops import check_ops

# Import modules for mocking
# Import modules for mocking - use the same imports as in check_ops module
from tensorflow.python.eager import context
from tensorflow.python.framework import tensor_util
from tensorflow.python.ops import math_ops
from tensorflow.python.ops import control_flow_ops
from tensorflow.python.ops import array_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# Common fixtures and utilities
@pytest.fixture
def mock_executing_eagerly():
    """Mock for tensorflow.python.eager.context.executing_eagerly."""
    with patch.object(context, 'executing_eagerly') as mock:
        yield mock

@pytest.fixture
def mock_constant_value():
    """Mock for tensorflow.python.framework.tensor_util.constant_value."""
    with patch.object(tensor_util, 'constant_value') as mock:
        yield mock

@pytest.fixture
def mock_equal():
    """Mock for tensorflow.python.ops.math_ops.equal."""
    with patch.object(math_ops, 'equal') as mock:
        yield mock

@pytest.fixture
def mock_less():
    """Mock for tensorflow.python.ops.math_ops.less."""
    with patch.object(math_ops, 'less') as mock:
        yield mock

@pytest.fixture
def mock_greater():
    """Mock for tensorflow.python.ops.math_ops.greater."""
    with patch.object(math_ops, 'greater') as mock:
        yield mock

@pytest.fixture
def mock_assert():
    """Mock for tensorflow.python.ops.control_flow_ops.Assert."""
    with patch.object(control_flow_ops, 'Assert') as mock:
        yield mock

@pytest.fixture
def mock_shape():
    """Mock for tensorflow.python.ops.array_ops.shape."""
    with patch.object(array_ops, 'shape') as mock:
        yield mock

def create_tensor(shape, dtype, value=None):
    """Create a tensor with given shape and dtype."""
    if dtype == 'float32':
        tf_dtype = tf.float32
        np_dtype = np.float32
    elif dtype == 'float64':
        tf_dtype = tf.float64
        np_dtype = np.float64
    elif dtype == 'int32':
        tf_dtype = tf.int32
        np_dtype = np.int32
    elif dtype == 'int64':
        tf_dtype = tf.int64
        np_dtype = np.int64
    else:
        raise ValueError(f"Unsupported dtype: {dtype}")
    
    if value is None:
        # Generate deterministic values
        size = np.prod(shape)
        values = np.arange(1, size + 1, dtype=np_dtype).reshape(shape)
    else:
        values = np.full(shape, value, dtype=np_dtype)
    
    return tf.constant(values, dtype=tf_dtype)
# END:HEADER

# START:CASE_01
@pytest.mark.parametrize(
    "func_name,x_shape,y_shape,dtype,mode",
    [
        ("assert_equal", [2, 2], [2, 2], "float32", "eager"),
        # Parameter extensions from test_plan.json
        ("assert_equal", [4, 4], [4, 4], "float64", "eager"),
        ("assert_greater", [2, 2], [2, 2], "float32", "eager"),
    ]
)
def test_assert_equal_eager_mode(
    func_name, x_shape, y_shape, dtype, mode,
    mock_executing_eagerly, mock_constant_value, mock_equal, mock_greater
):
    """
    Test assert_equal and similar functions in eager mode.
    
    Weak assertions:
    - returns_none: Function should return None in eager mode
    - no_exception: No exception should be raised
    
    Parameters from test_plan.json:
    - func: assert_equal (and extensions)
    - x_shape: [2, 2], [4, 4], [2, 2]
    - y_shape: [2, 2], [4, 4], [2, 2]
    - dtype: float32, float64, float32
    - mode: eager
    """
    # Setup mocks
    mock_executing_eagerly.return_value = True  # Eager mode
    mock_constant_value.return_value = None  # Dynamic check required
    
    # Create tensors
    x = create_tensor(x_shape, dtype)
    y = create_tensor(y_shape, dtype)
    
    # Mock tensor properties for graph mode
    # In graph mode, tensors should have a name attribute
    # Use property mock to avoid AttributeError
    with patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name, \
         patch.object(type(y), 'name', create=True, new_callable=PropertyMock) as mock_y_name:
        mock_x_name.return_value = "x_tensor"
        mock_y_name.return_value = "y_tensor"
    
    # Mock the comparison operation
    comparison_result = tf.constant(True)
    if func_name == "assert_equal":
        mock_equal.return_value = comparison_result
    elif func_name == "assert_greater":
        mock_greater.return_value = comparison_result
    
    # Get the function to test
    func = getattr(check_ops, func_name)
    
    # Execute the function
    result = func(x, y)
    
    # Weak assertion: returns_none
    assert result is None, f"{func_name} should return None in eager mode, got {result}"
    
    # Weak assertion: no_exception (implicitly passed if we reach here)
    
    # Verify mocks were called as expected
    mock_executing_eagerly.assert_called_once()
    
    if func_name == "assert_equal":
        mock_equal.assert_called_once()
    elif func_name == "assert_greater":
        mock_greater.assert_called_once()
# END:CASE_01

# START:CASE_02
@pytest.mark.parametrize(
    "func_name,x_shape,y_shape,dtype,mode",
    [
        ("assert_equal", [3, 3], [3, 3], "int32", "graph"),
        # Parameter extensions from test_plan.json
        ("assert_equal", [1, 5], [5, 1], "int32", "graph"),
    ]
)
def test_assert_equal_graph_mode(
    func_name, x_shape, y_shape, dtype, mode,
    mock_executing_eagerly, mock_constant_value, mock_equal, mock_assert
):
    """
    Test assert_equal in graph mode.
    
    Weak assertions:
    - returns_assert_op: Function should return Assert operation in graph mode
    - no_exception: No exception should be raised
    
    Parameters from test_plan.json:
    - func: assert_equal
    - x_shape: [3, 3], [1, 5]
    - y_shape: [3, 3], [5, 1]
    - dtype: int32, int32
    - mode: graph
    """
    # Setup mocks
    mock_executing_eagerly.return_value = False  # Graph mode
    mock_constant_value.return_value = None  # Dynamic check required
    
    # Create tensors
    x = create_tensor(x_shape, dtype)
    y = create_tensor(y_shape, dtype)
    
    # Mock tensor properties for graph mode
    # In graph mode, tensors should have a name attribute
    # Use property mock to avoid AttributeError
    with patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name, \
         patch.object(type(y), 'name', create=True, new_callable=PropertyMock) as mock_y_name:
        mock_x_name.return_value = "x_tensor"
        mock_y_name.return_value = "y_tensor"
        
        # Mock the comparison operation
        comparison_result = tf.constant(True)
        mock_equal.return_value = comparison_result
        
        # Mock the Assert operation
        mock_assert_op = Mock()
        mock_assert.return_value = mock_assert_op
        
        # Get the function to test
        func = getattr(check_ops, func_name)
        
        # Execute the function
        result = func(x, y)
    
    # Weak assertion: returns_assert_op
    assert result == mock_assert_op, f"{func_name} should return Assert operation in graph mode"
    
    # Weak assertion: no_exception (implicitly passed if we reach here)
    
    # Verify mocks were called as expected
    # Note: executing_eagerly may be called multiple times internally
    assert mock_executing_eagerly.call_count >= 1, \
        f"executing_eagerly should be called at least once, was called {mock_executing_eagerly.call_count} times"
    
    assert mock_equal.call_count >= 1, \
        f"equal should be called at least once, was called {mock_equal.call_count} times"
    
    assert mock_assert.call_count >= 1, \
        f"Assert should be called at least once, was called {mock_assert.call_count} times"
# END:CASE_02

# START:CASE_03
@pytest.mark.parametrize(
    "func_name,x_shape,y_shape,dtype,mode",
    [
        ("assert_less", [2], [2], "float64", "static_fail"),
        # Parameter extensions from test_plan.json
        ("assert_less", [3], [3], "float32", "static_fail"),
    ]
)
def test_assert_less_static_failure(
    func_name, x_shape, y_shape, dtype, mode,
    mock_constant_value, mock_less
):
    """
    Test assert_less with static failure (immediate exception).
    
    Weak assertions:
    - raises_invalid_argument_error: Should raise InvalidArgumentError
    - error_type_correct: Error type should be correct
    
    Parameters from test_plan.json:
    - func: assert_less
    - x_shape: [2], [3]
    - y_shape: [2], [3]
    - dtype: float64, float32
    - mode: static_fail
    """
    # Setup mocks for static failure
    # For static failure, constant_value returns False (condition fails)
    mock_constant_value.return_value = False
    
    # Create tensors where x > y to trigger failure
    x = create_tensor(x_shape, dtype, value=10.0)  # x = 10
    y = create_tensor(y_shape, dtype, value=5.0)   # y = 5
    
    # Mock the comparison operation (won't be called in static failure)
    comparison_result = tf.constant(False)
    mock_less.return_value = comparison_result
    
    # Get the function to test
    func = getattr(check_ops, func_name)
    
    # Weak assertion: raises_invalid_argument_error
    with pytest.raises(tf.errors.InvalidArgumentError) as exc_info:
        func(x, y)
    
    # Weak assertion: error_type_correct
    # The actual error message may vary, but it should be an InvalidArgumentError
    error_msg = str(exc_info.value).lower()
    # Accept various error message formats that indicate assertion failure
    assert any(keyword in error_msg for keyword in 
               ["assertion", "condition", "failed", "invalid", "where"]), \
           f"Error message should indicate assertion failure, got: {error_msg}"
    
    # Verify mocks were called as expected
    mock_constant_value.assert_called()
    # In static failure mode, less() might not be called
    # because the condition is evaluated statically
# END:CASE_03

# START:CASE_04
@pytest.mark.parametrize(
    "func_name,x_shape,dtype,mode",
    [
        ("assert_positive", [0, 0], "float32", "eager"),
        # Parameter extensions from test_plan.json
        ("assert_positive", [0], "int32", "graph"),
    ]
)
def test_assert_positive_empty_tensor(
    func_name, x_shape, dtype, mode,
    mock_executing_eagerly, mock_constant_value, mock_greater
):
    """
    Test assert_positive with empty tensors.
    
    Weak assertions:
    - returns_none: Function should return None in eager mode
    - no_exception: No exception should be raised
    
    Parameters from test_plan.json:
    - func: assert_positive
    - x_shape: [0, 0], [0]
    - dtype: float32, int32
    - mode: eager, graph
    """
    # Setup mocks based on mode
    if mode == "eager":
        mock_executing_eagerly.return_value = True  # Eager mode
    else:  # graph mode
        mock_executing_eagerly.return_value = False  # Graph mode
    
    # For empty tensors, constant_value returns empty array
    mock_constant_value.return_value = np.array([], dtype=np.float32 if dtype == 'float32' else np.int32)
    
    # Create empty tensor
    x = create_tensor(x_shape, dtype, value=1.0)  # Value doesn't matter for empty tensor
    
    # Mock the comparison operation
    # For empty tensor, comparison returns empty tensor
    empty_comparison = tf.constant([], dtype=tf.bool)
    mock_greater.return_value = empty_comparison
    
    # Get the function to test
    func = getattr(check_ops, func_name)
    
    # Execute the function
    if mode == "eager":
        result = func(x)
        # Weak assertion: returns_none (for eager mode)
        assert result is None, f"{func_name} should return None in eager mode for empty tensor"
    else:  # graph mode
        # In graph mode, we need to mock Assert operation and tensor name
        with patch.object(control_flow_ops, 'Assert') as mock_assert, \
             patch.object(type(x), 'name', create=True, new_callable=PropertyMock) as mock_x_name:
            mock_x_name.return_value = "x_tensor"
            mock_assert_op = Mock()
            mock_assert.return_value = mock_assert_op
            result = func(x)
            # Weak assertion: returns_assert_op (for graph mode)
            assert result == mock_assert_op, f"{func_name} should return Assert operation in graph mode"
            assert mock_assert.call_count >= 1, \
                f"Assert should be called at least once, was called {mock_assert.call_count} times"
    
    # Weak assertion: no_exception (implicitly passed if we reach here)
    
    # Verify mocks were called as expected
    # Note: executing_eagerly may be called multiple times internally
    assert mock_executing_eagerly.call_count >= 1, \
        f"executing_eagerly should be called at least once, was called {mock_executing_eagerly.call_count} times"
    
    assert mock_constant_value.call_count >= 1, \
        f"constant_value should be called at least once, was called {mock_constant_value.call_count} times"
    
    assert mock_greater.call_count >= 1, \
        f"greater should be called at least once, was called {mock_greater.call_count} times"
# END:CASE_04

# START:CASE_05
# DEFERRED: assert_rank_broadcast_shapes
# Will be implemented in later iterations
# Parameters from test_plan.json:
# - func: assert_rank
# - x_shape: [1, 3, 1]
# - y_shape: [3, 1, 5]
# - dtype: int64
# - mode: eager
# END:CASE_05

# START:FOOTER
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
# END:FOOTER