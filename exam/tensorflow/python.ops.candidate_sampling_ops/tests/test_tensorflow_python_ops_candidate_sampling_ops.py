# START: HEADER
"""
Test cases for tensorflow.python.ops.candidate_sampling_ops
Generated by ATTest
"""

import math
import pytest
import numpy as np
import tensorflow as tf
from unittest.mock import patch, MagicMock

# Import target functions
from tensorflow.python.ops import candidate_sampling_ops

# Import modules for mocking
import tensorflow.python.ops.gen_candidate_sampling_ops as gen_candidate_sampling_ops
import tensorflow.python.framework.random_seed as random_seed

# Fixtures and helper functions
@pytest.fixture
def tf_compat_mode():
    """TensorFlow compatibility mode for testing."""
    # TensorFlow 2.x uses eager execution by default
    # We'll use tf.compat.v1 for backward compatibility
    tf.compat.v1.disable_eager_execution()
    yield
    # Clear default graph after each test
    tf.compat.v1.reset_default_graph()

def assert_tensor_shape(tensor, expected_shape, name=""):
    """Assert tensor shape matches expected."""
    # For TensorFlow 2.x compatibility
    if hasattr(tensor, 'shape'):
        actual_shape = tensor.shape.as_list() if hasattr(tensor.shape, 'as_list') else list(tensor.shape)
    else:
        actual_shape = list(tensor.shape)
    
    assert actual_shape == expected_shape, \
        f"{name}: Expected shape {expected_shape}, got {actual_shape}"

def assert_tensor_dtype(tensor, expected_dtype, name=""):
    """Assert tensor dtype matches expected."""
    # Handle both TensorFlow tensors and numpy arrays
    if hasattr(tensor, 'dtype'):
        actual_dtype = tensor.dtype
    else:
        actual_dtype = tensor.dtype
    
    assert actual_dtype == expected_dtype, \
        f"{name}: Expected dtype {expected_dtype}, got {actual_dtype}"

def assert_tensor_values_in_range(tensor, min_val, max_val, name=""):
    """Assert tensor values are within range [min_val, max_val)."""
    # Convert tensor to numpy for value checking
    if hasattr(tensor, 'numpy'):
        values = tensor.numpy()
    elif hasattr(tensor, 'eval'):
        with tf.compat.v1.Session() as sess:
            values = sess.run(tensor)
    else:
        values = tensor
    
    assert np.all(values >= min_val) and np.all(values < max_val), \
        f"{name}: Values not in range [{min_val}, {max_val})"

def run_tensor(tensor):
    """Run tensor computation in TensorFlow 2.x compatible way."""
    if hasattr(tensor, 'numpy'):
        return tensor.numpy()
    elif hasattr(tensor, 'eval'):
        with tf.compat.v1.Session() as sess:
            return sess.run(tensor)
    else:
        return tensor
# END: HEADER

# START: CASE_01
class TestUniformCandidateSampler:
    """Test uniform_candidate_sampler basic functionality."""
    
    @pytest.mark.parametrize("true_classes_shape,num_true,num_sampled,range_max,unique,seed", [
        ([2, 3], 3, 5, 10, False, 42),  # Base case from test plan
        ([4, 2], 2, 8, 20, False, 999),  # Extension case
    ])
    def test_uniform_candidate_sampler_basic(
        self, true_classes_shape, num_true, num_sampled, range_max, unique, seed
    ):
        """Test uniform_candidate_sampler with basic parameters."""
        batch_size, _ = true_classes_shape
        
        # Create true_classes tensor
        true_classes = tf.constant(
            np.random.randint(0, range_max, size=true_classes_shape),
            dtype=tf.int64
        )
        
        # Mock the underlying C++ operation
        with patch.object(gen_candidate_sampling_ops, 'uniform_candidate_sampler') as mock_op, \
             patch.object(random_seed, 'get_seed') as mock_get_seed:
            
            # Setup mock to return correct seed values based on TensorFlow's get_seed logic
            # When no global seed is set, get_seed returns (DEFAULT_GRAPH_SEED, _truncate_seed(seed))
            DEFAULT_GRAPH_SEED = 87654321
            _MAXINT32 = 2**31 - 1
            expected_seed2 = seed % _MAXINT32
            mock_get_seed.return_value = (DEFAULT_GRAPH_SEED, expected_seed2)
            
            # Setup mock return values
            mock_sampled_candidates = tf.constant(
                np.random.randint(0, range_max, size=[num_sampled]),
                dtype=tf.int64
            )
            mock_true_expected_count = tf.constant(
                np.random.uniform(0.1, 0.5, size=true_classes_shape),
                dtype=tf.float32
            )
            mock_sampled_expected_count = tf.constant(
                np.random.uniform(0.1, 0.5, size=[num_sampled]),
                dtype=tf.float32
            )
            
            mock_op.return_value = (
                mock_sampled_candidates,
                mock_true_expected_count,
                mock_sampled_expected_count
            )
            
            # Call the function under test
            result = candidate_sampling_ops.uniform_candidate_sampler(
                true_classes=true_classes,
                num_true=num_true,
                num_sampled=num_sampled,
                unique=unique,
                range_max=range_max,
                seed=seed
            )
            
            sampled_candidates, true_expected_count, sampled_expected_count = result
            
            # Verify mock was called with correct arguments
            mock_op.assert_called_once()
            
            # The underlying C++ op is called with positional arguments
            # Check the call arguments - first 5 are positional, last 3 are keyword
            call_args = mock_op.call_args
            
            # Check positional arguments (first 5)
            assert call_args[0][0] is true_classes, "First positional arg should be true_classes"
            assert call_args[0][1] == num_true, f"Second positional arg should be num_true={num_true}"
            assert call_args[0][2] == num_sampled, f"Third positional arg should be num_sampled={num_sampled}"
            assert call_args[0][3] == unique, f"Fourth positional arg should be unique={unique}"
            assert call_args[0][4] == range_max, f"Fifth positional arg should be range_max={range_max}"
            
            # Check keyword arguments (seed, seed2, name)
            # With our mock, get_seed returns (DEFAULT_GRAPH_SEED, seed % _MAXINT32)
            DEFAULT_GRAPH_SEED = 87654321
            _MAXINT32 = 2**31 - 1
            expected_seed2 = seed % _MAXINT32
            
            assert call_args[1]['seed'] == DEFAULT_GRAPH_SEED, \
                f"Expected seed={DEFAULT_GRAPH_SEED} (DEFAULT_GRAPH_SEED), got {call_args[1]['seed']}"
            assert call_args[1]['seed2'] == expected_seed2, \
                f"Expected seed2={expected_seed2} (seed % _MAXINT32), got {call_args[1]['seed2']}"
            assert call_args[1]['name'] is None, "Expected name=None"
            
            # Weak assertions: output shape
            assert_tensor_shape(sampled_candidates, [num_sampled], "sampled_candidates")
            assert_tensor_shape(true_expected_count, true_classes_shape, "true_expected_count")
            assert_tensor_shape(sampled_expected_count, [num_sampled], "sampled_expected_count")
            
            # Weak assertions: dtype check
            assert_tensor_dtype(sampled_candidates, tf.int64, "sampled_candidates")
            assert_tensor_dtype(true_expected_count, tf.float32, "true_expected_count")
            assert_tensor_dtype(sampled_expected_count, tf.float32, "sampled_expected_count")
            
            # Weak assertions: value range
            sampled_values = run_tensor(sampled_candidates)
            assert np.all(sampled_values >= 0) and np.all(sampled_values < range_max), \
                f"sampled_candidates values not in range [0, {range_max})"
            
            true_expected_values = run_tensor(true_expected_count)
            assert np.all(true_expected_values >= 0), \
                "true_expected_count should be non-negative"
            
            sampled_expected_values = run_tensor(sampled_expected_count)
            assert np.all(sampled_expected_values >= 0), \
                "sampled_expected_count should be non-negative"
# END: CASE_01

# START: CASE_02
class TestUniqueConstraint:
    """Test unique=True constraint validation."""
    
    @pytest.mark.parametrize("true_classes_shape,num_true,num_sampled,range_max,unique,seed", [
        ([1, 2], 2, 3, 5, True, 123),  # Base case from test plan
        ([2, 1], 1, 4, 4, True, 777),  # Extension case: num_sampled equals range_max
    ])
    def test_unique_constraint_validation(
        self, true_classes_shape, num_true, num_sampled, range_max, unique, seed
    ):
        """Test uniform_candidate_sampler with unique=True constraint."""
        batch_size, _ = true_classes_shape
        
        # Create true_classes tensor
        true_classes = tf.constant(
            np.random.randint(0, range_max, size=true_classes_shape),
            dtype=tf.int64
        )
        
        # Mock the underlying C++ operation
        with patch.object(gen_candidate_sampling_ops, 'uniform_candidate_sampler') as mock_op, \
             patch.object(random_seed, 'get_seed') as mock_get_seed:
            
            # Setup mock to return correct seed values based on TensorFlow's get_seed logic
            # When no global seed is set, get_seed returns (DEFAULT_GRAPH_SEED, _truncate_seed(seed))
            DEFAULT_GRAPH_SEED = 87654321
            _MAXINT32 = 2**31 - 1
            expected_seed2 = seed % _MAXINT32
            mock_get_seed.return_value = (DEFAULT_GRAPH_SEED, expected_seed2)
            
            # For unique=True, create unique sampled candidates
            unique_candidates = np.arange(range_max)
            np.random.shuffle(unique_candidates)
            mock_sampled_candidates = tf.constant(
                unique_candidates[:num_sampled],
                dtype=tf.int64
            )
            
            mock_true_expected_count = tf.constant(
                np.random.uniform(0.1, 0.5, size=true_classes_shape),
                dtype=tf.float32
            )
            mock_sampled_expected_count = tf.constant(
                np.random.uniform(0.1, 0.5, size=[num_sampled]),
                dtype=tf.float32
            )
            
            mock_op.return_value = (
                mock_sampled_candidates,
                mock_true_expected_count,
                mock_sampled_expected_count
            )
            
            # Call the function under test
            result = candidate_sampling_ops.uniform_candidate_sampler(
                true_classes=true_classes,
                num_true=num_true,
                num_sampled=num_sampled,
                unique=unique,
                range_max=range_max,
                seed=seed
            )
            
            sampled_candidates, true_expected_count, sampled_expected_count = result
            
            # Verify mock was called with correct arguments
            mock_op.assert_called_once()
            
            # The underlying C++ op is called with positional arguments
            # Check the call arguments - first 5 are positional, last 3 are keyword
            call_args = mock_op.call_args
            
            # Check positional arguments (first 5)
            assert call_args[0][0] is true_classes, "First positional arg should be true_classes"
            assert call_args[0][1] == num_true, f"Second positional arg should be num_true={num_true}"
            assert call_args[0][2] == num_sampled, f"Third positional arg should be num_sampled={num_sampled}"
            assert call_args[0][3] == unique, f"Fourth positional arg should be unique={unique}"
            assert call_args[0][4] == range_max, f"Fifth positional arg should be range_max={range_max}"
            
            # Check keyword arguments (seed, seed2, name)
            # With our mock, get_seed returns (DEFAULT_GRAPH_SEED, seed % _MAXINT32)
            DEFAULT_GRAPH_SEED = 87654321
            _MAXINT32 = 2**31 - 1
            expected_seed2 = seed % _MAXINT32
            
            assert call_args[1]['seed'] == DEFAULT_GRAPH_SEED, \
                f"Expected seed={DEFAULT_GRAPH_SEED} (DEFAULT_GRAPH_SEED), got {call_args[1]['seed']}"
            assert call_args[1]['seed2'] == expected_seed2, \
                f"Expected seed2={expected_seed2} (seed % _MAXINT32), got {call_args[1]['seed2']}"
            assert call_args[1]['name'] is None, "Expected name=None"
            
            # Weak assertions: output shape
            assert_tensor_shape(sampled_candidates, [num_sampled], "sampled_candidates")
            assert_tensor_shape(true_expected_count, true_classes_shape, "true_expected_count")
            assert_tensor_shape(sampled_expected_count, [num_sampled], "sampled_expected_count")
            
            # Weak assertions: dtype check
            assert_tensor_dtype(sampled_candidates, tf.int64, "sampled_candidates")
            assert_tensor_dtype(true_expected_count, tf.float32, "true_expected_count")
            assert_tensor_dtype(sampled_expected_count, tf.float32, "sampled_expected_count")
            
            # Weak assertions: unique constraint verification
            sampled_values = run_tensor(sampled_candidates)
            
            # Check that all sampled values are unique
            unique_values = np.unique(sampled_values)
            assert len(unique_values) == len(sampled_values), \
                f"Expected {len(sampled_values)} unique values, got {len(unique_values)}"
            
            # Check values are in valid range
            assert np.all(sampled_values >= 0) and np.all(sampled_values < range_max), \
                f"sampled_candidates values not in range [0, {range_max})"
            
            # Check that when num_sampled == range_max, all values 0..range_max-1 are present
            if num_sampled == range_max:
                sorted_values = np.sort(sampled_values)
                expected_values = np.arange(range_max)
                assert np.array_equal(sorted_values, expected_values), \
                    f"When num_sampled == range_max, expected all values 0..{range_max-1}"
# END: CASE_02

# START: CASE_03
class TestComputeAccidentalHits:
    """Test compute_accidental_hits basic functionality."""
    
    @pytest.mark.parametrize("true_classes_shape,sampled_candidates_shape,num_true,seed", [
        ([3, 2], [4], 2, 456),  # Base case from test plan
        ([1, 5], [10], 5, 555),  # Extension case
    ])
    def test_compute_accidental_hits_basic(
        self, true_classes_shape, sampled_candidates_shape, num_true, seed
    ):
        """Test compute_accidental_hits with basic parameters."""
        batch_size, _ = true_classes_shape
        num_sampled = sampled_candidates_shape[0]
        
        # Create true_classes tensor
        true_classes = tf.constant(
            np.random.randint(0, 10, size=true_classes_shape),
            dtype=tf.int64
        )
        
        # Create sampled_candidates tensor
        sampled_candidates = tf.constant(
            np.random.randint(0, 10, size=sampled_candidates_shape),
            dtype=tf.int64
        )
        
        # Mock the underlying C++ operation
        with patch.object(gen_candidate_sampling_ops, 'compute_accidental_hits') as mock_op:
            
            # Setup mock return values
            # For accidental hits, we need indices where true_classes match sampled_candidates
            mock_indices = tf.constant(
                np.random.randint(0, batch_size * num_true, size=[min(batch_size * num_true, num_sampled)]),
                dtype=tf.int32
            )
            mock_ids = tf.constant(
                np.random.randint(0, num_sampled, size=[min(batch_size * num_true, num_sampled)]),
                dtype=tf.int64
            )
            mock_weights = tf.constant(
                np.random.uniform(-1.0, 1.0, size=[min(batch_size * num_true, num_sampled)]),
                dtype=tf.float32
            )
            
            mock_op.return_value = (mock_indices, mock_ids, mock_weights)
            
            # Call the function under test
            result = candidate_sampling_ops.compute_accidental_hits(
                true_classes=true_classes,
                sampled_candidates=sampled_candidates,
                num_true=num_true,
                seed=seed
            )
            
            indices, ids, weights = result
            
            # Verify mock was called with correct arguments
            mock_op.assert_called_once()
            
            # The underlying C++ op is called with positional arguments
            # Check the call arguments - first 3 are positional, last 3 are keyword
            call_args = mock_op.call_args
            
            # Check positional arguments (first 3)
            assert call_args[0][0] is true_classes, "First positional arg should be true_classes"
            assert call_args[0][1] is sampled_candidates, "Second positional arg should be sampled_candidates"
            assert call_args[0][2] == num_true, f"Third positional arg should be num_true={num_true}"
            
            # Check keyword arguments (seed, seed2, name)
            # Note: When no global seed is set, TensorFlow uses DEFAULT_GRAPH_SEED = 87654321
            # as the first seed, and _truncate_seed(op_seed) as the second seed
            DEFAULT_GRAPH_SEED = 87654321
            assert call_args[1]['seed'] == DEFAULT_GRAPH_SEED, \
                f"Expected seed={DEFAULT_GRAPH_SEED} (DEFAULT_GRAPH_SEED), got {call_args[1]['seed']}"
            
            # The second seed should be the truncated op_seed
            _MAXINT32 = 2**31 - 1
            expected_seed2 = seed % _MAXINT32
            assert call_args[1]['seed2'] == expected_seed2, \
                f"Expected seed2={expected_seed2} (seed % _MAXINT32), got {call_args[1]['seed2']}"
            
            assert call_args[1]['name'] is None, "Expected name=None"
            
            # Weak assertions: output shape consistency
            # All three outputs should have the same first dimension
            indices_shape = indices.shape.as_list()
            ids_shape = ids.shape.as_list()
            weights_shape = weights.shape.as_list()
            
            assert indices_shape[0] == ids_shape[0], \
                f"indices and ids should have same first dimension: {indices_shape[0]} != {ids_shape[0]}"
            assert indices_shape[0] == weights_shape[0], \
                f"indices and weights should have same first dimension: {indices_shape[0]} != {weights_shape[0]}"
            
            # Weak assertions: dtype check
            assert_tensor_dtype(indices, tf.int32, "indices")
            assert_tensor_dtype(ids, tf.int64, "ids")
            assert_tensor_dtype(weights, tf.float32, "weights")
            
            # Weak assertions: indices range
            indices_values = run_tensor(indices)
            ids_values = run_tensor(ids)
            
            # Check indices are within valid range
            max_index = batch_size * num_true
            if len(indices_values) > 0:
                assert np.all(indices_values >= 0) and np.all(indices_values < max_index), \
                    f"indices should be in range [0, {max_index})"
            
            # Check ids are within valid range
            if len(ids_values) > 0:
                assert np.all(ids_values >= 0) and np.all(ids_values < num_sampled), \
                    f"ids should be in range [0, {num_sampled})"
# END: CASE_03

# START: CASE_04
# DEFERRED: log_uniform_candidate_sampler分布验证
# Will be implemented in later iteration
# END: CASE_04

# START: CASE_05
# DEFERRED: all_candidate_sampler全类别采样
# Will be implemented in later iteration
# END: CASE_05

# START: FOOTER
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
# END: FOOTER