=== Run Tests ===
FFFFFFF..FFF....                                                         [100%]
=================================== FAILURES ===================================
_ test_basic_scalar_gradient_verification[scalar_square-input_shape0-float32-None-eager] _

func_type = 'scalar_square', input_shape = [1], dtype = 'float32', delta = None
execution_mode = 'eager'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("scalar_square", [1], "float32", None, "eager"),
            # Parameter extensions
            ("scalar_square", [1], "float64", None, "graph"),
            ("scalar_square", [3], "float32", 0.0001, "eager"),
        ]
    )
    def test_basic_scalar_gradient_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-01: 基本标量函数梯度验证"""
    
        # Select function based on type
        if func_type == "scalar_square":
            test_func = scalar_square
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
        elif dtype == "float64":
            tf_dtype = tf.float64
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random input
        np_input = np.random.randn(*input_shape).astype(np.float32 if dtype == "float32" else np.float64)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients
        if delta is None:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x)
        else:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. basic_gradient_property: Check gradient has expected structure
            # For scalar square function f(x) = x^2, gradient should be 2x
            if func_type == "scalar_square" and input_shape == [1]:
                expected_grad = 2 * np_input
                # Check shape matches expected
                assert theo_grad.shape == (1, 1), f"Expected gradient shape (1,1), got {theo_grad.shape}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Error thresholds based on dtype precision
            if dtype == "float32":
                abs_threshold = 1e-4
                rel_threshold = 1e-3
            else:  # float64
                abs_threshold = 1e-8
                rel_threshold = 1e-6
    
            # Adjust thresholds for delta if specified
            if delta is not None:
                # Larger delta may cause larger errors
                delta_factor = min(10.0, max(1.0, delta * 100))
                abs_threshold *= delta_factor
                rel_threshold *= delta_factor
    
            assert max_abs_error < abs_threshold, \
                f"Max absolute error {max_abs_error} exceeds threshold {abs_threshold}"
    
            # Only check relative error if theoretical gradient is not too small
            if np.max(np.abs(theo_grad)) > 1e-6:
                assert max_rel_error < rel_threshold, \
                    f"Max relative error {max_rel_error} exceeds threshold {rel_threshold}"
    
        # 2. jacobian_structure: Check specific structure of Jacobian matrix
        for i in range(len(x)):
            theo_grad = theoretical[i]
    
            # For scalar square function f(x) = x^2
            if func_type == "scalar_square":
                n = input_shape[0]
    
                # Expected Jacobian shape: (n, n) for vector input
                expected_shape = (n, n)
                assert theo_grad.shape == expected_shape, \
                    f"Expected Jacobian shape {expected_shape}, got {theo_grad.shape}"
    
                # For f(x) = sum(x_i^2), the Jacobian should be diagonal with 2x_i on diagonal
                # But compute_gradient returns full Jacobian
>               J = theo_grad.numpy()
E               AttributeError: 'numpy.ndarray' object has no attribute 'numpy'. Did you mean: 'dump'?

tests/test_tensorflow_python_ops_gradient_checker_v2.py:164: AttributeError
_ test_basic_scalar_gradient_verification[scalar_square-input_shape1-float64-None-graph] _

func_type = 'scalar_square', input_shape = [1], dtype = 'float64', delta = None
execution_mode = 'graph'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("scalar_square", [1], "float32", None, "eager"),
            # Parameter extensions
            ("scalar_square", [1], "float64", None, "graph"),
            ("scalar_square", [3], "float32", 0.0001, "eager"),
        ]
    )
    def test_basic_scalar_gradient_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-01: 基本标量函数梯度验证"""
    
        # Select function based on type
        if func_type == "scalar_square":
            test_func = scalar_square
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
        elif dtype == "float64":
            tf_dtype = tf.float64
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random input
        np_input = np.random.randn(*input_shape).astype(np.float32 if dtype == "float32" else np.float64)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients
        if delta is None:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x)
        else:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. basic_gradient_property: Check gradient has expected structure
            # For scalar square function f(x) = x^2, gradient should be 2x
            if func_type == "scalar_square" and input_shape == [1]:
                expected_grad = 2 * np_input
                # Check shape matches expected
                assert theo_grad.shape == (1, 1), f"Expected gradient shape (1,1), got {theo_grad.shape}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Error thresholds based on dtype precision
            if dtype == "float32":
                abs_threshold = 1e-4
                rel_threshold = 1e-3
            else:  # float64
                abs_threshold = 1e-8
                rel_threshold = 1e-6
    
            # Adjust thresholds for delta if specified
            if delta is not None:
                # Larger delta may cause larger errors
                delta_factor = min(10.0, max(1.0, delta * 100))
                abs_threshold *= delta_factor
                rel_threshold *= delta_factor
    
            assert max_abs_error < abs_threshold, \
                f"Max absolute error {max_abs_error} exceeds threshold {abs_threshold}"
    
            # Only check relative error if theoretical gradient is not too small
            if np.max(np.abs(theo_grad)) > 1e-6:
                assert max_rel_error < rel_threshold, \
                    f"Max relative error {max_rel_error} exceeds threshold {rel_threshold}"
    
        # 2. jacobian_structure: Check specific structure of Jacobian matrix
        for i in range(len(x)):
            theo_grad = theoretical[i]
    
            # For scalar square function f(x) = x^2
            if func_type == "scalar_square":
                n = input_shape[0]
    
                # Expected Jacobian shape: (n, n) for vector input
                expected_shape = (n, n)
                assert theo_grad.shape == expected_shape, \
                    f"Expected Jacobian shape {expected_shape}, got {theo_grad.shape}"
    
                # For f(x) = sum(x_i^2), the Jacobian should be diagonal with 2x_i on diagonal
                # But compute_gradient returns full Jacobian
>               J = theo_grad.numpy()
E               AttributeError: 'numpy.ndarray' object has no attribute 'numpy'. Did you mean: 'dump'?

tests/test_tensorflow_python_ops_gradient_checker_v2.py:164: AttributeError
----------------------------- Captured stderr call -----------------------------
2026-01-24 18:49:41.035646: W tensorflow/core/platform/profile_utils/cpu_utils.cc:128] Failed to get CPU frequency: 0 Hz
_ test_basic_scalar_gradient_verification[scalar_square-input_shape2-float32-0.0001-eager] _

func_type = 'scalar_square', input_shape = [3], dtype = 'float32'
delta = 0.0001, execution_mode = 'eager'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("scalar_square", [1], "float32", None, "eager"),
            # Parameter extensions
            ("scalar_square", [1], "float64", None, "graph"),
            ("scalar_square", [3], "float32", 0.0001, "eager"),
        ]
    )
    def test_basic_scalar_gradient_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-01: 基本标量函数梯度验证"""
    
        # Select function based on type
        if func_type == "scalar_square":
            test_func = scalar_square
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
        elif dtype == "float64":
            tf_dtype = tf.float64
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random input
        np_input = np.random.randn(*input_shape).astype(np.float32 if dtype == "float32" else np.float64)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients
        if delta is None:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x)
        else:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. basic_gradient_property: Check gradient has expected structure
            # For scalar square function f(x) = x^2, gradient should be 2x
            if func_type == "scalar_square" and input_shape == [1]:
                expected_grad = 2 * np_input
                # Check shape matches expected
                assert theo_grad.shape == (1, 1), f"Expected gradient shape (1,1), got {theo_grad.shape}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Error thresholds based on dtype precision
            if dtype == "float32":
                abs_threshold = 1e-4
                rel_threshold = 1e-3
            else:  # float64
                abs_threshold = 1e-8
                rel_threshold = 1e-6
    
            # Adjust thresholds for delta if specified
            if delta is not None:
                # Larger delta may cause larger errors
                delta_factor = min(10.0, max(1.0, delta * 100))
                abs_threshold *= delta_factor
                rel_threshold *= delta_factor
    
>           assert max_abs_error < abs_threshold, \
                f"Max absolute error {max_abs_error} exceeds threshold {abs_threshold}"
E           AssertionError: Max absolute error 0.00027883052825927734 exceeds threshold 0.0001
E           assert 0.00027883053 < 0.0001

tests/test_tensorflow_python_ops_gradient_checker_v2.py:141: AssertionError
_ test_vector_matrix_gradient_verification[matrix_multiply-input_shape0-float64-0.001-graph] _

func_type = 'matrix_multiply', input_shape = [2, 3], dtype = 'float64'
delta = 0.001, execution_mode = 'graph'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("matrix_multiply", [2, 3], "float64", 0.001, "graph"),
            # Parameter extension
            ("matrix_multiply", [4, 4], "float32", None, "eager"),
        ]
    )
    def test_vector_matrix_gradient_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-02: 向量矩阵函数梯度验证"""
    
        # Select function based on type
        if func_type == "matrix_multiply":
            test_func = matrix_multiply
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
            np_dtype = np.float32
        elif dtype == "float64":
            tf_dtype = tf.float64
            np_dtype = np.float64
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random matrix input
        np_input = np.random.randn(*input_shape).astype(np_dtype)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients
        if delta is None:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x)
        else:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
            # Convert numpy dtype string to compare
            expected_dtype = np_dtype
            assert theo_grad.dtype == expected_dtype, f"Expected dtype {expected_dtype}, got {theo_grad.dtype}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. jacobian_dimensions: Check Jacobian has correct dimensions
            # For matrix input of shape (m, n), Jacobian should have shape (m*m, m*n)
            # because output is (m, m) and input is (m, n)
            m, n = input_shape
            expected_jacobian_shape = (m * m, m * n)
            assert theo_grad.shape == expected_jacobian_shape, \
                f"Expected Jacobian shape {expected_jacobian_shape}, got {theo_grad.shape}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Error thresholds based on dtype precision
            if dtype == "float32":
                abs_threshold = 1e-4
                rel_threshold = 1e-3
            else:  # float64
                abs_threshold = 1e-8
                rel_threshold = 1e-6
    
            # Adjust thresholds for delta if specified
            if delta is not None:
                # Larger delta may cause larger errors
                delta_factor = min(10.0, max(1.0, delta * 100))
                abs_threshold *= delta_factor
                rel_threshold *= delta_factor
    
            assert max_abs_error < abs_threshold, \
                f"Max absolute error {max_abs_error} exceeds threshold {abs_threshold}"
    
            # Only check relative error if theoretical gradient is not too small
            if np.max(np.abs(theo_grad)) > 1e-6:
                assert max_rel_error < rel_threshold, \
                    f"Max relative error {max_rel_error} exceeds threshold {rel_threshold}"
    
        # 2. matrix_structure: Check specific structure of matrix gradient
        for i in range(len(x)):
            theo_grad = theoretical[i]
    
            # For matrix multiplication function f(X) = X @ X^T
            if func_type == "matrix_multiply":
                m, n = input_shape
    
                # Expected Jacobian shape: (m*m, m*n)
                expected_shape = (m * m, m * n)
                assert theo_grad.shape == expected_shape, \
                    f"Expected Jacobian shape {expected_shape}, got {theo_grad.shape}"
    
                # The Jacobian has specific structure for this function
                # f(X) = X @ X^T, so ∂f_ij/∂X_kl = δ_ik X_jl + δ_jk X_il
                # This creates a specific pattern in the Jacobian
    
>               J = theo_grad.numpy()
E               AttributeError: 'numpy.ndarray' object has no attribute 'numpy'. Did you mean: 'dump'?

tests/test_tensorflow_python_ops_gradient_checker_v2.py:390: AttributeError
_ test_vector_matrix_gradient_verification[matrix_multiply-input_shape1-float32-None-eager] _

func_type = 'matrix_multiply', input_shape = [4, 4], dtype = 'float32'
delta = None, execution_mode = 'eager'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("matrix_multiply", [2, 3], "float64", 0.001, "graph"),
            # Parameter extension
            ("matrix_multiply", [4, 4], "float32", None, "eager"),
        ]
    )
    def test_vector_matrix_gradient_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-02: 向量矩阵函数梯度验证"""
    
        # Select function based on type
        if func_type == "matrix_multiply":
            test_func = matrix_multiply
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
            np_dtype = np.float32
        elif dtype == "float64":
            tf_dtype = tf.float64
            np_dtype = np.float64
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random matrix input
        np_input = np.random.randn(*input_shape).astype(np_dtype)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients
        if delta is None:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x)
        else:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
            # Convert numpy dtype string to compare
            expected_dtype = np_dtype
            assert theo_grad.dtype == expected_dtype, f"Expected dtype {expected_dtype}, got {theo_grad.dtype}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. jacobian_dimensions: Check Jacobian has correct dimensions
            # For matrix input of shape (m, n), Jacobian should have shape (m*m, m*n)
            # because output is (m, m) and input is (m, n)
            m, n = input_shape
            expected_jacobian_shape = (m * m, m * n)
            assert theo_grad.shape == expected_jacobian_shape, \
                f"Expected Jacobian shape {expected_jacobian_shape}, got {theo_grad.shape}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Error thresholds based on dtype precision
            if dtype == "float32":
                abs_threshold = 1e-4
                rel_threshold = 1e-3
            else:  # float64
                abs_threshold = 1e-8
                rel_threshold = 1e-6
    
            # Adjust thresholds for delta if specified
            if delta is not None:
                # Larger delta may cause larger errors
                delta_factor = min(10.0, max(1.0, delta * 100))
                abs_threshold *= delta_factor
                rel_threshold *= delta_factor
    
>           assert max_abs_error < abs_threshold, \
                f"Max absolute error {max_abs_error} exceeds threshold {abs_threshold}"
E           AssertionError: Max absolute error 0.00014448165893554688 exceeds threshold 0.0001
E           assert 0.00014448166 < 0.0001

tests/test_tensorflow_python_ops_gradient_checker_v2.py:365: AssertionError
_ test_complex_type_gradient_computation[complex_function-input_shape0-complex64-None-eager] _

func_type = 'complex_function', input_shape = [2], dtype = 'complex64'
delta = None, execution_mode = 'eager'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("complex_function", [2], "complex64", None, "eager"),
            # Parameter extension
            ("complex_function", [3], "complex128", 0.001, "graph"),
        ]
    )
    def test_complex_type_gradient_computation(func_type, input_shape, dtype, delta, execution_mode):
        """TC-03: 复数类型梯度计算"""
    
        # Select function based on type
        if func_type == "complex_function":
            test_func = complex_function
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "complex64":
            tf_dtype = tf.complex64
            np_dtype = np.complex64
        elif dtype == "complex128":
            tf_dtype = tf.complex128
            np_dtype = np.complex128
        else:
            pytest.fail(f"Unsupported dtype for complex test: {dtype}")
    
        # Generate random complex input
        real_part = np.random.randn(*input_shape).astype(np.float32 if dtype == "complex64" else np.float64)
        imag_part = np.random.randn(*input_shape).astype(np.float32 if dtype == "complex64" else np.float64)
        np_input = real_part + 1j * imag_part
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients
        if delta is None:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x)
        else:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            # For complex functions, gradients are real-valued
            # The shape should be doubled for complex inputs
            expected_dtype = np.float32 if dtype == "complex64" else np.float64
            assert theo_grad.dtype == expected_dtype, \
                f"Expected dtype {expected_dtype}, got {theo_grad.dtype}"
            assert num_grad.dtype == expected_dtype, \
                f"Expected dtype {expected_dtype}, got {num_grad.dtype}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. complex_handling: Check gradient shape for complex inputs
            # For complex input of shape (n,), TensorFlow treats complex numbers as pairs of real numbers
            # So input dimension = 2 * n (real and imaginary parts)
            # For f(z) = z * conj(z) = |z|^2, the output is real-valued
            # However, TensorFlow's gradient checker may treat the output as complex (2 * n real dimensions)
            # Let's check the actual shape and adjust expectations
    
            n = input_shape[0]
            # Input has n complex numbers = 2n real dimensions
            input_real_dim = 2 * n
    
            # For complex function f(z) = z * conj(z), the output is real-valued
            # But TensorFlow may treat it as complex output (2n real dimensions)
            # Let's check what we actually get
            actual_shape = theo_grad.shape
    
            # The Jacobian should have dimensions: (output_dim, input_dim)
            # We need to determine output_dim based on actual shape
            if actual_shape[0] == actual_shape[1]:
                # Square matrix: output_dim = input_dim = 2n
                # This means TensorFlow treats the output as complex (2n real dimensions)
                expected_jacobian_shape = (2 * n, 2 * n)
                assert theo_grad.shape == expected_jacobian_shape, \
                    f"Expected square Jacobian shape {expected_jacobian_shape} for complex input, got {theo_grad.shape}"
            elif actual_shape[0] == n and actual_shape[1] == 2 * n:
                # Rectangular matrix: output_dim = n (real), input_dim = 2n
                expected_jacobian_shape = (n, 2 * n)
                assert theo_grad.shape == expected_jacobian_shape, \
                    f"Expected rectangular Jacobian shape {expected_jacobian_shape} for complex input, got {theo_grad.shape}"
            else:
                # Unexpected shape, but we'll accept it for now
                # Just log the shape for debugging
                print(f"Complex gradient shape: {theo_grad.shape} for input shape {input_shape}")
    
            # Additional check: For f(z) = z * conj(z) = |z|^2
            # The gradient should be 2 * real(z) for real part and 2 * imag(z) for imag part
            if func_type == "complex_function":
                # Reshape gradient to see real and imaginary parts
                # The gradient matrix should have structure related to the complex function
                pass  # Detailed structure checks deferred to strong assertions
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute relative error
            abs_diff = np.abs(theo_grad - num_grad)
            abs_theo = np.abs(theo_grad)
    
            # Avoid division by zero
            mask = abs_theo > 1e-10
            if np.any(mask):
                rel_error = np.mean(abs_diff[mask] / abs_theo[mask])
            else:
                rel_error = np.mean(abs_diff)
    
            # For complex gradients, we expect reasonable accuracy
            # The tolerance depends on delta and dtype precision
            if delta is None:
                # Default delta
                max_rel_error = 1e-3 if dtype == "complex64" else 1e-5
            else:
                # User-specified delta
                max_rel_error = min(0.1, delta * 10)  # Scale with delta
    
            assert rel_error < max_rel_error, \
                f"Relative error {rel_error} exceeds threshold {max_rel_error} for dtype {dtype}"
    
            # Also check absolute error
            max_abs_error = np.max(abs_diff)
            max_abs_threshold = 1e-2 if dtype == "complex64" else 1e-4
            assert max_abs_error < max_abs_threshold, \
                f"Maximum absolute error {max_abs_error} exceeds threshold {max_abs_threshold}"
    
        # 2. complex_conjugate_relation: Check specific properties of complex gradient
        if func_type == "complex_function":
            for i in range(len(x)):
                theo_grad = theoretical[i]
                num_grad = numerical[i]
    
                # For f(z) = z * conj(z) = |z|^2
                # The gradient with respect to z is conj(z)
                # The gradient with respect to conj(z) is z
    
                # In TensorFlow's representation, complex numbers are split into real and imaginary parts
                # The Jacobian should have specific structure
    
                n = input_shape[0]
                if theo_grad.shape == (2 * n, 2 * n):
                    # Square Jacobian: output is treated as complex (2n real dimensions)
                    # Check symmetry properties
    
                    # The Jacobian should be block-diagonal for this function
                    # Real part depends only on real input, imaginary part depends only on imaginary input
>                   J = theo_grad.numpy()
E                   AttributeError: 'numpy.ndarray' object has no attribute 'numpy'. Did you mean: 'dump'?

tests/test_tensorflow_python_ops_gradient_checker_v2.py:690: AttributeError
_ test_complex_type_gradient_computation[complex_function-input_shape1-complex128-0.001-graph] _

func_type = 'complex_function', input_shape = [3], dtype = 'complex128'
delta = 0.001, execution_mode = 'graph'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("complex_function", [2], "complex64", None, "eager"),
            # Parameter extension
            ("complex_function", [3], "complex128", 0.001, "graph"),
        ]
    )
    def test_complex_type_gradient_computation(func_type, input_shape, dtype, delta, execution_mode):
        """TC-03: 复数类型梯度计算"""
    
        # Select function based on type
        if func_type == "complex_function":
            test_func = complex_function
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "complex64":
            tf_dtype = tf.complex64
            np_dtype = np.complex64
        elif dtype == "complex128":
            tf_dtype = tf.complex128
            np_dtype = np.complex128
        else:
            pytest.fail(f"Unsupported dtype for complex test: {dtype}")
    
        # Generate random complex input
        real_part = np.random.randn(*input_shape).astype(np.float32 if dtype == "complex64" else np.float64)
        imag_part = np.random.randn(*input_shape).astype(np.float32 if dtype == "complex64" else np.float64)
        np_input = real_part + 1j * imag_part
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients
        if delta is None:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x)
        else:
            theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            # For complex functions, gradients are real-valued
            # The shape should be doubled for complex inputs
            expected_dtype = np.float32 if dtype == "complex64" else np.float64
            assert theo_grad.dtype == expected_dtype, \
                f"Expected dtype {expected_dtype}, got {theo_grad.dtype}"
            assert num_grad.dtype == expected_dtype, \
                f"Expected dtype {expected_dtype}, got {num_grad.dtype}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. complex_handling: Check gradient shape for complex inputs
            # For complex input of shape (n,), TensorFlow treats complex numbers as pairs of real numbers
            # So input dimension = 2 * n (real and imaginary parts)
            # For f(z) = z * conj(z) = |z|^2, the output is real-valued
            # However, TensorFlow's gradient checker may treat the output as complex (2 * n real dimensions)
            # Let's check the actual shape and adjust expectations
    
            n = input_shape[0]
            # Input has n complex numbers = 2n real dimensions
            input_real_dim = 2 * n
    
            # For complex function f(z) = z * conj(z), the output is real-valued
            # But TensorFlow may treat it as complex output (2n real dimensions)
            # Let's check what we actually get
            actual_shape = theo_grad.shape
    
            # The Jacobian should have dimensions: (output_dim, input_dim)
            # We need to determine output_dim based on actual shape
            if actual_shape[0] == actual_shape[1]:
                # Square matrix: output_dim = input_dim = 2n
                # This means TensorFlow treats the output as complex (2n real dimensions)
                expected_jacobian_shape = (2 * n, 2 * n)
                assert theo_grad.shape == expected_jacobian_shape, \
                    f"Expected square Jacobian shape {expected_jacobian_shape} for complex input, got {theo_grad.shape}"
            elif actual_shape[0] == n and actual_shape[1] == 2 * n:
                # Rectangular matrix: output_dim = n (real), input_dim = 2n
                expected_jacobian_shape = (n, 2 * n)
                assert theo_grad.shape == expected_jacobian_shape, \
                    f"Expected rectangular Jacobian shape {expected_jacobian_shape} for complex input, got {theo_grad.shape}"
            else:
                # Unexpected shape, but we'll accept it for now
                # Just log the shape for debugging
                print(f"Complex gradient shape: {theo_grad.shape} for input shape {input_shape}")
    
            # Additional check: For f(z) = z * conj(z) = |z|^2
            # The gradient should be 2 * real(z) for real part and 2 * imag(z) for imag part
            if func_type == "complex_function":
                # Reshape gradient to see real and imaginary parts
                # The gradient matrix should have structure related to the complex function
                pass  # Detailed structure checks deferred to strong assertions
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute relative error
            abs_diff = np.abs(theo_grad - num_grad)
            abs_theo = np.abs(theo_grad)
    
            # Avoid division by zero
            mask = abs_theo > 1e-10
            if np.any(mask):
                rel_error = np.mean(abs_diff[mask] / abs_theo[mask])
            else:
                rel_error = np.mean(abs_diff)
    
            # For complex gradients, we expect reasonable accuracy
            # The tolerance depends on delta and dtype precision
            if delta is None:
                # Default delta
                max_rel_error = 1e-3 if dtype == "complex64" else 1e-5
            else:
                # User-specified delta
                max_rel_error = min(0.1, delta * 10)  # Scale with delta
    
            assert rel_error < max_rel_error, \
                f"Relative error {rel_error} exceeds threshold {max_rel_error} for dtype {dtype}"
    
            # Also check absolute error
            max_abs_error = np.max(abs_diff)
            max_abs_threshold = 1e-2 if dtype == "complex64" else 1e-4
            assert max_abs_error < max_abs_threshold, \
                f"Maximum absolute error {max_abs_error} exceeds threshold {max_abs_threshold}"
    
        # 2. complex_conjugate_relation: Check specific properties of complex gradient
        if func_type == "complex_function":
            for i in range(len(x)):
                theo_grad = theoretical[i]
                num_grad = numerical[i]
    
                # For f(z) = z * conj(z) = |z|^2
                # The gradient with respect to z is conj(z)
                # The gradient with respect to conj(z) is z
    
                # In TensorFlow's representation, complex numbers are split into real and imaginary parts
                # The Jacobian should have specific structure
    
                n = input_shape[0]
                if theo_grad.shape == (2 * n, 2 * n):
                    # Square Jacobian: output is treated as complex (2n real dimensions)
                    # Check symmetry properties
    
                    # The Jacobian should be block-diagonal for this function
                    # Real part depends only on real input, imaginary part depends only on imaginary input
>                   J = theo_grad.numpy()
E                   AttributeError: 'numpy.ndarray' object has no attribute 'numpy'. Did you mean: 'dump'?

tests/test_tensorflow_python_ops_gradient_checker_v2.py:690: AttributeError
_ test_delta_parameter_impact_verification[scalar_square-input_shape0-float32-0.01-eager] _

func_type = 'scalar_square', input_shape = [1], dtype = 'float32', delta = 0.01
execution_mode = 'eager'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("scalar_square", [1], "float32", 0.01, "eager"),
            # Additional test cases for delta parameter
            ("scalar_square", [1], "float32", 0.001, "eager"),
            ("scalar_square", [1], "float32", 0.1, "eager"),
        ]
    )
    def test_delta_parameter_impact_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-05: delta参数影响验证"""
    
        # Select function based on type
        if func_type == "scalar_square":
            test_func = scalar_square
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
            np_dtype = np.float32
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random input
        np_input = np.random.randn(*input_shape).astype(np_dtype)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients with specified delta
        theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. delta_effect: Check that delta parameter affects numerical gradient
            # For scalar square function f(x) = x^2, gradient should be approximately 2x
            # The numerical gradient accuracy depends on delta
            if func_type == "scalar_square" and input_shape == [1]:
                expected_grad = 2 * np_input
                theo_value = theo_grad[0, 0]
                num_value = num_grad[0, 0]
    
                # Theoretical gradient should be exact
                assert abs(theo_value - expected_grad) < 1e-10, \
                    f"Theoretical gradient should be {expected_grad}, got {theo_value}"
    
                # Numerical gradient should be close to theoretical
                # Larger delta may cause larger errors
                error = abs(num_value - theo_value)
                # For reasonable delta values (0.001-0.1), error should be small
                if 0.001 <= delta <= 0.1:
                    assert error < 0.01, \
                        f"Numerical gradient error too large: {error} with delta={delta}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Expected error bounds based on delta
            # For finite difference with step size delta, error is O(delta^2) for central difference
            # But TensorFlow's gradient_checker_v2 might use forward/backward difference
            expected_abs_error_bound = delta * 0.1  # Conservative bound
            expected_rel_error_bound = 0.1  # 10% relative error
    
            assert max_abs_error < expected_abs_error_bound, \
                f"Max absolute error {max_abs_error} exceeds bound {expected_abs_error_bound} for delta={delta}"
    
            # Only check relative error if theoretical gradient is not too small
            if np.max(np.abs(theo_grad)) > 1e-6:
                assert max_rel_error < expected_rel_error_bound, \
                    f"Max relative error {max_rel_error} exceeds bound {expected_rel_error_bound} for delta={delta}"
    
        # 2. delta_sensitivity: Check that error scales appropriately with delta
        # This test requires multiple delta values to check scaling
        # We'll check within the parameterized test by comparing error magnitudes
    
        if func_type == "scalar_square" and input_shape == [1]:
            # For scalar square function, we can analyze error scaling
            theo_value = theoretical[0][0, 0]
            num_value = numerical[0][0, 0]
            error = abs(num_value - theo_value)
    
            # Expected error scaling: for finite difference, error ~ O(delta^2) for central difference
            # But we need to be conservative since we don't know the exact method used
    
            # Record error for different delta values (this is for manual inspection)
            # In a real test suite, we might run multiple tests with different deltas
            # and check that error decreases with smaller delta
    
            # For now, we just verify that error is reasonable for the given delta
            if delta <= 0.001:
                assert error < 1e-6, f"Error {error} too large for small delta={delta}"
            elif delta <= 0.01:
                assert error < 1e-4, f"Error {error} too large for delta={delta}"
            elif delta <= 0.1:
                assert error < 1e-2, f"Error {error} too large for large delta={delta}"
    
            # Check that error is not suspiciously small (indicating potential issues)
            if delta > 1e-10:  # Non-zero delta
                # Error should be non-zero for non-zero input
                if abs(np_input[0]) > 1e-6:
                    assert error > 1e-12, f"Error {error} suspiciously small for delta={delta} and non-zero input"
    
        # 3. error_below_threshold: Comprehensive error analysis
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute comprehensive error metrics
            mse = np.mean((theo_grad - num_grad) ** 2)
            rmse = np.sqrt(mse)
            mae = np.mean(np.abs(theo_grad - num_grad))
            max_abs_error = np.max(np.abs(theo_grad - num_grad))
    
            # Compute relative errors
            theo_abs = np.abs(theo_grad)
            mask = theo_abs > 1e-10  # Avoid division by zero
            if np.any(mask):
                rel_errors = np.abs(theo_grad[mask] - num_grad[mask]) / theo_abs[mask]
                max_rel_error = np.max(rel_errors)
                mean_rel_error = np.mean(rel_errors)
            else:
                max_rel_error = 0.0
                mean_rel_error = 0.0
    
            # Error thresholds based on delta and dtype
            if dtype == "float32":
                # float32 has about 7 decimal digits of precision
                base_precision = 1e-7
            else:  # float64
                base_precision = 1e-15
    
            # Scale thresholds with delta
            # For finite difference, error scales with delta^2 for central difference
            # But we'll be conservative and use linear scaling
            delta_factor = min(100.0, max(1.0, delta * 1000))  # Scale from 1 to 100
    
            mse_threshold = base_precision * delta_factor
            rmse_threshold = np.sqrt(mse_threshold)
            mae_threshold = base_precision * delta_factor
            max_abs_threshold = base_precision * delta_factor * 10  # Allow larger max error
    
            # For relative errors
            max_rel_threshold = 0.1 * delta_factor  # 10% scaled by delta
            mean_rel_threshold = 0.05 * delta_factor  # 5% scaled by delta
    
            # Apply thresholds
            assert mse < mse_threshold, f"MSE {mse} exceeds threshold {mse_threshold} for delta={delta}"
            assert rmse < rmse_threshold, f"RMSE {rmse} exceeds threshold {rmse_threshold} for delta={delta}"
>           assert mae < mae_threshold, f"MAE {mae} exceeds threshold {mae_threshold} for delta={delta}"
E           AssertionError: MAE 1.2874603271484375e-05 exceeds threshold 1e-06 for delta=0.01
E           assert 1.2874603e-05 < 1e-06

tests/test_tensorflow_python_ops_gradient_checker_v2.py:1141: AssertionError
_ test_delta_parameter_impact_verification[scalar_square-input_shape1-float32-0.001-eager] _

func_type = 'scalar_square', input_shape = [1], dtype = 'float32', delta = 0.001
execution_mode = 'eager'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("scalar_square", [1], "float32", 0.01, "eager"),
            # Additional test cases for delta parameter
            ("scalar_square", [1], "float32", 0.001, "eager"),
            ("scalar_square", [1], "float32", 0.1, "eager"),
        ]
    )
    def test_delta_parameter_impact_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-05: delta参数影响验证"""
    
        # Select function based on type
        if func_type == "scalar_square":
            test_func = scalar_square
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
            np_dtype = np.float32
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random input
        np_input = np.random.randn(*input_shape).astype(np_dtype)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients with specified delta
        theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. delta_effect: Check that delta parameter affects numerical gradient
            # For scalar square function f(x) = x^2, gradient should be approximately 2x
            # The numerical gradient accuracy depends on delta
            if func_type == "scalar_square" and input_shape == [1]:
                expected_grad = 2 * np_input
                theo_value = theo_grad[0, 0]
                num_value = num_grad[0, 0]
    
                # Theoretical gradient should be exact
                assert abs(theo_value - expected_grad) < 1e-10, \
                    f"Theoretical gradient should be {expected_grad}, got {theo_value}"
    
                # Numerical gradient should be close to theoretical
                # Larger delta may cause larger errors
                error = abs(num_value - theo_value)
                # For reasonable delta values (0.001-0.1), error should be small
                if 0.001 <= delta <= 0.1:
                    assert error < 0.01, \
                        f"Numerical gradient error too large: {error} with delta={delta}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Expected error bounds based on delta
            # For finite difference with step size delta, error is O(delta^2) for central difference
            # But TensorFlow's gradient_checker_v2 might use forward/backward difference
            expected_abs_error_bound = delta * 0.1  # Conservative bound
            expected_rel_error_bound = 0.1  # 10% relative error
    
>           assert max_abs_error < expected_abs_error_bound, \
                f"Max absolute error {max_abs_error} exceeds bound {expected_abs_error_bound} for delta={delta}"
E           AssertionError: Max absolute error 0.00014710426330566406 exceeds bound 0.0001 for delta=0.001
E           assert 0.00014710426 < 0.0001

tests/test_tensorflow_python_ops_gradient_checker_v2.py:1056: AssertionError
_ test_delta_parameter_impact_verification[scalar_square-input_shape2-float32-0.1-eager] _

func_type = 'scalar_square', input_shape = [1], dtype = 'float32', delta = 0.1
execution_mode = 'eager'

    @pytest.mark.parametrize(
        "func_type,input_shape,dtype,delta,execution_mode",
        [
            # Base case from test plan
            ("scalar_square", [1], "float32", 0.01, "eager"),
            # Additional test cases for delta parameter
            ("scalar_square", [1], "float32", 0.001, "eager"),
            ("scalar_square", [1], "float32", 0.1, "eager"),
        ]
    )
    def test_delta_parameter_impact_verification(func_type, input_shape, dtype, delta, execution_mode):
        """TC-05: delta参数影响验证"""
    
        # Select function based on type
        if func_type == "scalar_square":
            test_func = scalar_square
        else:
            pytest.fail(f"Unknown function type: {func_type}")
    
        # Create test input
        if dtype == "float32":
            tf_dtype = tf.float32
            np_dtype = np.float32
        else:
            pytest.fail(f"Unsupported dtype: {dtype}")
    
        # Generate random input
        np_input = np.random.randn(*input_shape).astype(np_dtype)
        x = [tf.constant(np_input, dtype=tf_dtype)]
    
        # Set execution mode
        if execution_mode == "graph":
            @tf.function
            def graph_func(x):
                return test_func(x)
            func_to_test = graph_func
        else:  # eager
            func_to_test = test_func
    
        # Compute gradients with specified delta
        theoretical, numerical = gradient_checker_v2.compute_gradient(func_to_test, x, delta=delta)
    
        # Weak assertions (round 1)
        # 1. shape_match: Check shapes match
        assert len(theoretical) == len(numerical) == len(x), "Number of gradients should match number of inputs"
    
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # 2. shape_match: Individual gradient shapes
            assert theo_grad.shape == num_grad.shape, f"Gradient shapes mismatch at index {i}"
    
            # 3. dtype_match: Check dtypes
            assert theo_grad.dtype == num_grad.dtype, f"Gradient dtypes mismatch at index {i}"
    
            # 4. finite_values: Check for finite values
            assert np.all(np.isfinite(theo_grad)), f"Theoretical gradient contains non-finite values at index {i}"
            assert np.all(np.isfinite(num_grad)), f"Numerical gradient contains non-finite values at index {i}"
    
            # 5. delta_effect: Check that delta parameter affects numerical gradient
            # For scalar square function f(x) = x^2, gradient should be approximately 2x
            # The numerical gradient accuracy depends on delta
            if func_type == "scalar_square" and input_shape == [1]:
                expected_grad = 2 * np_input
                theo_value = theo_grad[0, 0]
                num_value = num_grad[0, 0]
    
                # Theoretical gradient should be exact
                assert abs(theo_value - expected_grad) < 1e-10, \
                    f"Theoretical gradient should be {expected_grad}, got {theo_value}"
    
                # Numerical gradient should be close to theoretical
                # Larger delta may cause larger errors
                error = abs(num_value - theo_value)
                # For reasonable delta values (0.001-0.1), error should be small
                if 0.001 <= delta <= 0.1:
                    assert error < 0.01, \
                        f"Numerical gradient error too large: {error} with delta={delta}"
    
        # STRONG ASSERTIONS (Final round)
        # 1. gradient_approx_equal: Check that theoretical and numerical gradients are approximately equal
        for i in range(len(x)):
            theo_grad = theoretical[i]
            num_grad = numerical[i]
    
            # Compute error metrics
            abs_error = np.abs(theo_grad - num_grad)
            rel_error = np.abs(theo_grad - num_grad) / (np.abs(theo_grad) + 1e-10)  # Avoid division by zero
    
            max_abs_error = np.max(abs_error)
            max_rel_error = np.max(rel_error)
            mean_abs_error = np.mean(abs_error)
            mean_rel_error = np.mean(rel_error)
    
            # Expected error bounds based on delta
            # For finite difference with step size delta, error is O(delta^2) for central difference
            # But TensorFlow's gradient_checker_v2 might use forward/backward difference
            expected_abs_error_bound = delta * 0.1  # Conservative bound
            expected_rel_error_bound = 0.1  # 10% relative error
    
            assert max_abs_error < expected_abs_error_bound, \
                f"Max absolute error {max_abs_error} exceeds bound {expected_abs_error_bound} for delta={delta}"
    
            # Only check relative error if theoretical gradient is not too small
            if np.max(np.abs(theo_grad)) > 1e-6:
                assert max_rel_error < expected_rel_error_bound, \
                    f"Max relative error {max_rel_error} exceeds bound {expected_rel_error_bound} for delta={delta}"
    
        # 2. delta_sensitivity: Check that error scales appropriately with delta
        # This test requires multiple delta values to check scaling
        # We'll check within the parameterized test by comparing error magnitudes
    
        if func_type == "scalar_square" and input_shape == [1]:
            # For scalar square function, we can analyze error scaling
            theo_value = theoretical[0][0, 0]
            num_value = numerical[0][0, 0]
            error = abs(num_value - theo_value)
    
            # Expected error scaling: for finite difference, error ~ O(delta^2) for central difference
            # But we need to be conservative since we don't know the exact method used
    
            # Record error for different delta values (this is for manual inspection)
            # In a real test suite, we might run multiple tests with different deltas
            # and check that error decreases with smaller delta
    
            # For now, we just verify that error is reasonable for the given delta
            if delta <= 0.001:
                assert error < 1e-6, f"Error {error} too large for small delta={delta}"
            elif delta <= 0.01:
                assert error < 1e-4, f"Error {error} too large for delta={delta}"
            elif delta <= 0.1:
                assert error < 1e-2, f"Error {error} too large for large delta={delta}"
    
            # Check that error is not suspiciously small (indicating potential issues)
            if delta > 1e-10:  # Non-zero delta
                # Error should be non-zero for non-zero input
                if abs(np_input[0]) > 1e-6:
>                   assert error > 1e-12, f"Error {error} suspiciously small for delta={delta} and non-zero input"
E                   AssertionError: Error 0.0 suspiciously small for delta=0.1 and non-zero input
E                   assert 0.0 > 1e-12

tests/test_tensorflow_python_ops_gradient_checker_v2.py:1093: AssertionError
=============================== warnings summary ===============================
../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:18
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:18: DeprecationWarning: Call to deprecated create function FileDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    DESCRIPTOR = _descriptor.FileDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:36
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:36: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:43
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:43: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:29
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:29: DeprecationWarning: Call to deprecated create function Descriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _TENSORSHAPEPROTO_DIM = _descriptor.Descriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:73
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:73: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:80
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:80: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:66
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_shape_pb2.py:66: DeprecationWarning: Call to deprecated create function Descriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _TENSORSHAPEPROTO = _descriptor.Descriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:19
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:19: DeprecationWarning: Call to deprecated create function FileDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    DESCRIPTOR = _descriptor.FileDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:33
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:33: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:37
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:37: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:41
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:41: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:45
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:45: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:49
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:49: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:53
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:53: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:57
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:57: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:61
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:61: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:65
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:65: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:69
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:69: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:73
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:73: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:77
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:77: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:81
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:81: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:85
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:85: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:89
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:89: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:93
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:93: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:97
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:97: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:101
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:101: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:105
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:105: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:109
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:109: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:113
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:113: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:117
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:117: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:121
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:121: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:125
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:125: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:129
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:129: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:133
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:133: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:137
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:137: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:141
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:141: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:145
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:145: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:149
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:149: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:153
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:153: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:157
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:157: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:161
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:161: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:165
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:165: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:169
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:169: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:173
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:173: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:177
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:177: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:181
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:181: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:185
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:185: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:189
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:189: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:193
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:193: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:197
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:197: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:201
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:201: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:205
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:205: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:209
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:209: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:213
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:213: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:217
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:217: DeprecationWarning: Call to deprecated create function EnumValueDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.EnumValueDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:27
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/types_pb2.py:27: DeprecationWarning: Call to deprecated create function EnumDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _DATATYPE = _descriptor.EnumDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:20
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:20: DeprecationWarning: Call to deprecated create function FileDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    DESCRIPTOR = _descriptor.FileDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:39
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:39: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:46
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:46: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:32
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:32: DeprecationWarning: Call to deprecated create function Descriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _RESOURCEHANDLEPROTO_DTYPEANDSHAPE = _descriptor.Descriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:76
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:76: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:83
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:83: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:90
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:90: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:97
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:97: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:104
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:104: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:111
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:111: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:69
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/resource_handle_pb2.py:69: DeprecationWarning: Call to deprecated create function Descriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _RESOURCEHANDLEPROTO = _descriptor.Descriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:21
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:21: DeprecationWarning: Call to deprecated create function FileDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    DESCRIPTOR = _descriptor.FileDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:40
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:40: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:47
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:47: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:54
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:54: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:61
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:61: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:68
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:68: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:75
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:75: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:82
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:82: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:89
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:89: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:96
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:96: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:103
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:103: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:110
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:110: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:117
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:117: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:124
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:124: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:131
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:131: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:138
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:138: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:145
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:145: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:152
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:152: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:33
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:33: DeprecationWarning: Call to deprecated create function Descriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _TENSORPROTO = _descriptor.Descriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:183
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:183: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:190
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:190: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:197
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:197: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:176
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/tensor_pb2.py:176: DeprecationWarning: Call to deprecated create function Descriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _VARIANTTENSORDATAPROTO = _descriptor.Descriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:21
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:21: DeprecationWarning: Call to deprecated create function FileDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    DESCRIPTOR = _descriptor.FileDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:40
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:40: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:47
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:47: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:54
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:54: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:61
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:61: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:68
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:68: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:75
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:75: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:82
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:82: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:89
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:89: DeprecationWarning: Call to deprecated create function FieldDescriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _descriptor.FieldDescriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:33
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/core/framework/attr_value_pb2.py:33: DeprecationWarning: Call to deprecated create function Descriptor(). Note: Create unlinked descriptors is going to go away. Please use get/find descriptors from generated code or query the descriptor_pool.
    _ATTRVALUE_LISTVALUE = _descriptor.Descriptor(

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/python/framework/dtypes.py:205
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/python/framework/dtypes.py:205: DeprecationWarning: `np.bool8` is a deprecated alias for `np.bool_`.  (Deprecated NumPy 1.24)
    np.bool8: (False, True),

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/flatbuffers/compat.py:19
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/flatbuffers/compat.py:19: DeprecationWarning: the imp module is deprecated in favour of importlib and slated for removal in Python 3.12; see the module's documentation for alternative uses
    import imp

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:326
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorboard/compat/tensorflow_stub/dtypes.py:326: DeprecationWarning: `np.bool8` is a deprecated alias for `np.bool_`.  (Deprecated NumPy 1.24)
    np.bool8: (False, True),

exam/tensorflow/python.ops.gradient_checker_v2/tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_compute_gradient_with_zero_delta
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/tensorflow/python/ops/gradient_checker_v2.py:250: RuntimeWarning: invalid value encountered in divide
    diff = (y_pos - y_neg) / scale

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                                      Stmts   Miss Branch BrPart  Cover   Missing
-----------------------------------------------------------------------------------------------------
tests/test_tensorflow_python_ops_gradient_checker_v2.py     578    202    184     37    63%   57, 65, 75, 145->113, 154->150, 167-254, 275, 285, 295, 369->337, 378->374, 397-516, 537, 547, 559, 618-626, 630->574, 650, 693-767, 793, 819->829, 858, 948->exit, 972, 979, 987-990, 1018->1001, 1031->1001, 1060->1037, 1068->1096, 1083, 1086->1090, 1090->1096, 1092->1096, 1096->exit, 1114-1115, 1122, 1142-1166, 1221
-----------------------------------------------------------------------------------------------------
TOTAL                                                       578    202    184     37    63%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_basic_scalar_gradient_verification[scalar_square-input_shape0-float32-None-eager]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_basic_scalar_gradient_verification[scalar_square-input_shape1-float64-None-graph]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_basic_scalar_gradient_verification[scalar_square-input_shape2-float32-0.0001-eager]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_vector_matrix_gradient_verification[matrix_multiply-input_shape0-float64-0.001-graph]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_vector_matrix_gradient_verification[matrix_multiply-input_shape1-float32-None-eager]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_complex_type_gradient_computation[complex_function-input_shape0-complex64-None-eager]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_complex_type_gradient_computation[complex_function-input_shape1-complex128-0.001-graph]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_delta_parameter_impact_verification[scalar_square-input_shape0-float32-0.01-eager]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_delta_parameter_impact_verification[scalar_square-input_shape1-float32-0.001-eager]
FAILED tests/test_tensorflow_python_ops_gradient_checker_v2.py::test_delta_parameter_impact_verification[scalar_square-input_shape2-float32-0.1-eager]
10 failed, 6 passed, 104 warnings in 2.23s

Error: exit 1