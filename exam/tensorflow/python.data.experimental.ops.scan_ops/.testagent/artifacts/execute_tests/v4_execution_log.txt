=== Run Tests ===
.FFFFF                                                                   [100%]
================================== FAILURES ===================================
_ test_scan_invalid_parameters[initial_state1-invalid_args_scan_func-expected_error1] _

initial_state = <tf.Tensor: shape=(), dtype=float32, numpy=0.0>
scan_func = <function invalid_args_scan_func at 0x000001E6B86D9F70>
expected_error = (<class 'TypeError'>, <class 'ValueError'>)

    @pytest.mark.parametrize("initial_state,scan_func,expected_error", [
        # Test case 1: initial_state is None (invalid)
        (
            None,  # invalid initial_state
            valid_scan_func,
            (TypeError, ValueError)  # TensorFlow may raise either
        ),
        # Test case 2: scan_func has wrong number of arguments
        (
            tf.constant(0.0, dtype=tf.float32),  # valid initial_state
            invalid_args_scan_func,  # function with 3 args instead of 2
            (TypeError, ValueError)
        ),
    ])
    def test_scan_invalid_parameters(initial_state, scan_func, expected_error):
        """Test scan function with invalid parameters raises appropriate exceptions.
    
        This test verifies:
        1. Invalid initial_state raises exception
        2. Scan function with wrong argument count raises exception
        3. Exception type is correct (TypeError or ValueError)
        4. No side effects from failed scan call
    
        Note: The scan() function itself doesn't validate parameters immediately.
        Validation happens when the returned transformation function is applied
        to a dataset (in dataset.scan()).
        """
        # Capture deprecation warnings from TensorFlow logging
        import logging
        warning_messages = []
    
        # Custom handler to capture warnings
        class WarningCaptureHandler(logging.Handler):
            def emit(self, record):
                warning_messages.append(record.getMessage())
    
        # Set up logging capture
        tf_logger = logging.getLogger('tensorflow')
        original_level = tf_logger.level
        original_handlers = tf_logger.handlers.copy()
    
        # Add our custom handler
        capture_handler = WarningCaptureHandler()
        capture_handler.setLevel(logging.WARNING)
        tf_logger.addHandler(capture_handler)
        tf_logger.setLevel(logging.WARNING)
    
        try:
            # The scan() function should return a transformation function
            # even with invalid parameters (validation is deferred)
            transform_fn = scan(initial_state, scan_func)
    
            # Check for deprecation warning
>           assert len(warning_messages) > 0, "Expected deprecation warning"
E           AssertionError: Expected deprecation warning
E           assert 0 > 0
E            +  where 0 = len([])

tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py:133: AssertionError
_ test_scan_edge_cases[initial_state0-identity_scan_func-empty_dataset-handles_empty] _

initial_state = <tf.Tensor: shape=(0,), dtype=float32, numpy=array([], dtype=float32)>
scan_func = <function identity_scan_func at 0x000001E6B86E4D30>
dataset_fixture = 'empty_dataset', expected_behavior = 'handles_empty'
request = <FixtureRequest for <Function test_scan_edge_cases[initial_state0-identity_scan_func-empty_dataset-handles_empty]>>

    @pytest.mark.parametrize("initial_state,scan_func,dataset_fixture,expected_behavior", [
        # Test case 1: Empty tensor state with empty dataset
        (
            tf.constant([], dtype=tf.float32),  # empty tensor
            identity_scan_func,
            'empty_dataset',
            'handles_empty'  # Should handle without crashing
        ),
        # Test case 2: Zero scalar state with single element
        (
            tf.constant(0.0, dtype=tf.float32),  # zero scalar
            valid_scan_func,
            'single_element_dataset',
            'single_pass_works'  # Should process single element correctly
        ),
    ])
    def test_scan_edge_cases(initial_state, scan_func, dataset_fixture, expected_behavior, request):
        """Test scan function with edge cases and boundary conditions.
    
        This test verifies:
        1. Empty states and datasets are handled without crashing
        2. Single element datasets work correctly
        3. Basic sanity checks pass for edge cases
        4. The function returns a callable transformation
        """
        # Get the dataset fixture
        dataset = request.getfixturevalue(dataset_fixture)
    
        # Capture deprecation warnings from TensorFlow logging
        import logging
        warning_messages = []
    
        # Custom handler to capture warnings
        class WarningCaptureHandler(logging.Handler):
            def emit(self, record):
                warning_messages.append(record.getMessage())
    
        # Set up logging capture
        tf_logger = logging.getLogger('tensorflow')
        original_level = tf_logger.level
        original_handlers = tf_logger.handlers.copy()
    
        # Add our custom handler
        capture_handler = WarningCaptureHandler()
        capture_handler.setLevel(logging.WARNING)
        tf_logger.addHandler(capture_handler)
        tf_logger.setLevel(logging.WARNING)
    
        try:
            # Call scan function - should not crash
            transform_fn = scan(initial_state, scan_func)
    
            # Check if deprecation warning was captured
>           assert len(warning_messages) > 0, "Expected at least one warning"
E           AssertionError: Expected at least one warning
E           assert 0 > 0
E            +  where 0 = len([])

tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py:248: AssertionError
_ test_scan_edge_cases[initial_state1-valid_scan_func-single_element_dataset-single_pass_works] _

initial_state = <tf.Tensor: shape=(), dtype=float32, numpy=0.0>
scan_func = <function valid_scan_func at 0x000001E692C24280>
dataset_fixture = 'single_element_dataset'
expected_behavior = 'single_pass_works'
request = <FixtureRequest for <Function test_scan_edge_cases[initial_state1-valid_scan_func-single_element_dataset-single_pass_works]>>

    @pytest.mark.parametrize("initial_state,scan_func,dataset_fixture,expected_behavior", [
        # Test case 1: Empty tensor state with empty dataset
        (
            tf.constant([], dtype=tf.float32),  # empty tensor
            identity_scan_func,
            'empty_dataset',
            'handles_empty'  # Should handle without crashing
        ),
        # Test case 2: Zero scalar state with single element
        (
            tf.constant(0.0, dtype=tf.float32),  # zero scalar
            valid_scan_func,
            'single_element_dataset',
            'single_pass_works'  # Should process single element correctly
        ),
    ])
    def test_scan_edge_cases(initial_state, scan_func, dataset_fixture, expected_behavior, request):
        """Test scan function with edge cases and boundary conditions.
    
        This test verifies:
        1. Empty states and datasets are handled without crashing
        2. Single element datasets work correctly
        3. Basic sanity checks pass for edge cases
        4. The function returns a callable transformation
        """
        # Get the dataset fixture
        dataset = request.getfixturevalue(dataset_fixture)
    
        # Capture deprecation warnings from TensorFlow logging
        import logging
        warning_messages = []
    
        # Custom handler to capture warnings
        class WarningCaptureHandler(logging.Handler):
            def emit(self, record):
                warning_messages.append(record.getMessage())
    
        # Set up logging capture
        tf_logger = logging.getLogger('tensorflow')
        original_level = tf_logger.level
        original_handlers = tf_logger.handlers.copy()
    
        # Add our custom handler
        capture_handler = WarningCaptureHandler()
        capture_handler.setLevel(logging.WARNING)
        tf_logger.addHandler(capture_handler)
        tf_logger.setLevel(logging.WARNING)
    
        try:
            # Call scan function - should not crash
            transform_fn = scan(initial_state, scan_func)
    
            # Check if deprecation warning was captured
>           assert len(warning_messages) > 0, "Expected at least one warning"
E           AssertionError: Expected at least one warning
E           assert 0 > 0
E            +  where 0 = len([])

tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py:248: AssertionError
_ test_scan_extreme_numeric_handling[initial_state0-numeric_safe_scan_func-extreme_values_dataset-handles_extreme_numeric] _

initial_state = <tf.Tensor: shape=(), dtype=float32, numpy=nan>
scan_func = <function numeric_safe_scan_func at 0x000001E6B8DE5F70>
dataset_fixture = 'extreme_values_dataset'
expected_behavior = 'handles_extreme_numeric'
request = <FixtureRequest for <Function test_scan_extreme_numeric_handling[initial_state0-numeric_safe_scan_func-extreme_values_dataset-handles_extreme_numeric]>>

    @pytest.mark.parametrize("initial_state,scan_func,dataset_fixture,expected_behavior", [
        # Test case 1: NaN/Inf state with extreme values dataset
        (
            tf.constant(np.nan, dtype=tf.float32),  # NaN state
            numeric_safe_scan_func,
            'extreme_values_dataset',
            'handles_extreme_numeric'  # Should handle extreme values without crashing
        ),
        # Test case 2: Large numeric state with extreme values
        (
            tf.constant(1e10, dtype=tf.float32),  # Large state
            numeric_safe_scan_func,
            'extreme_values_dataset',
            'handles_large_numeric'  # Should handle large values
        ),
    ])
    def test_scan_extreme_numeric_handling(initial_state, scan_func, dataset_fixture, expected_behavior, request):
        """Test scan function with extreme numeric values and edge cases.
    
        This test verifies:
        1. NaN and Inf values are handled without crashing
        2. Large numeric values don't cause overflow or underflow
        3. The scan function can process extreme values safely
        4. Basic sanity checks pass for numeric edge cases
    
        This corresponds to param_extensions for CASE_04 in test_plan.json.
        """
        # Get the dataset fixture
        dataset = request.getfixturevalue(dataset_fixture)
    
        # Capture deprecation warnings from TensorFlow logging
        import logging
        warning_messages = []
    
        # Custom handler to capture warnings
        class WarningCaptureHandler(logging.Handler):
            def emit(self, record):
                warning_messages.append(record.getMessage())
    
        # Set up logging capture
        tf_logger = logging.getLogger('tensorflow')
        original_level = tf_logger.level
        original_handlers = tf_logger.handlers.copy()
    
        # Add our custom handler
        capture_handler = WarningCaptureHandler()
        capture_handler.setLevel(logging.WARNING)
        tf_logger.addHandler(capture_handler)
        tf_logger.setLevel(logging.WARNING)
    
        try:
            # Call scan function - should not crash
            transform_fn = scan(initial_state, scan_func)
    
            # Check if deprecation warning was captured
>           assert len(warning_messages) > 0, "Expected at least one warning"
E           AssertionError: Expected at least one warning
E           assert 0 > 0
E            +  where 0 = len([])

tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py:367: AssertionError
_ test_scan_extreme_numeric_handling[initial_state1-numeric_safe_scan_func-extreme_values_dataset-handles_large_numeric] _

initial_state = <tf.Tensor: shape=(), dtype=float32, numpy=10000000000.0>
scan_func = <function numeric_safe_scan_func at 0x000001E6B8DE5F70>
dataset_fixture = 'extreme_values_dataset'
expected_behavior = 'handles_large_numeric'
request = <FixtureRequest for <Function test_scan_extreme_numeric_handling[initial_state1-numeric_safe_scan_func-extreme_values_dataset-handles_large_numeric]>>

    @pytest.mark.parametrize("initial_state,scan_func,dataset_fixture,expected_behavior", [
        # Test case 1: NaN/Inf state with extreme values dataset
        (
            tf.constant(np.nan, dtype=tf.float32),  # NaN state
            numeric_safe_scan_func,
            'extreme_values_dataset',
            'handles_extreme_numeric'  # Should handle extreme values without crashing
        ),
        # Test case 2: Large numeric state with extreme values
        (
            tf.constant(1e10, dtype=tf.float32),  # Large state
            numeric_safe_scan_func,
            'extreme_values_dataset',
            'handles_large_numeric'  # Should handle large values
        ),
    ])
    def test_scan_extreme_numeric_handling(initial_state, scan_func, dataset_fixture, expected_behavior, request):
        """Test scan function with extreme numeric values and edge cases.
    
        This test verifies:
        1. NaN and Inf values are handled without crashing
        2. Large numeric values don't cause overflow or underflow
        3. The scan function can process extreme values safely
        4. Basic sanity checks pass for numeric edge cases
    
        This corresponds to param_extensions for CASE_04 in test_plan.json.
        """
        # Get the dataset fixture
        dataset = request.getfixturevalue(dataset_fixture)
    
        # Capture deprecation warnings from TensorFlow logging
        import logging
        warning_messages = []
    
        # Custom handler to capture warnings
        class WarningCaptureHandler(logging.Handler):
            def emit(self, record):
                warning_messages.append(record.getMessage())
    
        # Set up logging capture
        tf_logger = logging.getLogger('tensorflow')
        original_level = tf_logger.level
        original_handlers = tf_logger.handlers.copy()
    
        # Add our custom handler
        capture_handler = WarningCaptureHandler()
        capture_handler.setLevel(logging.WARNING)
        tf_logger.addHandler(capture_handler)
        tf_logger.setLevel(logging.WARNING)
    
        try:
            # Call scan function - should not crash
            transform_fn = scan(initial_state, scan_func)
    
            # Check if deprecation warning was captured
>           assert len(warning_messages) > 0, "Expected at least one warning"
E           AssertionError: Expected at least one warning
E           assert 0 > 0
E            +  where 0 = len([])

tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py:367: AssertionError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                                                Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------------------------------------------
tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py     237    134     64      3    35%   35-37, 42, 47, 51, 56-59, 163-165, 173-190, 230, 249-251, 259-308, 349, 368-370, 378-437, 453-457, 468-483, 495-512, 525-531, 536, 541-542
---------------------------------------------------------------------------------------------------------------
TOTAL                                                                 237    134     64      3    35%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py::test_scan_invalid_parameters[initial_state1-invalid_args_scan_func-expected_error1]
FAILED tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py::test_scan_edge_cases[initial_state0-identity_scan_func-empty_dataset-handles_empty]
FAILED tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py::test_scan_edge_cases[initial_state1-valid_scan_func-single_element_dataset-single_pass_works]
FAILED tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py::test_scan_extreme_numeric_handling[initial_state0-numeric_safe_scan_func-extreme_values_dataset-handles_extreme_numeric]
FAILED tests\test_tensorflow_python_data_experimental_ops_scan_ops_g2.py::test_scan_extreme_numeric_handling[initial_state1-numeric_safe_scan_func-extreme_values_dataset-handles_large_numeric]
5 failed, 1 passed in 1.62s

Error: exit 1