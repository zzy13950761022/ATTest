import numpy as np
import tensorflow as tf
import pytest
from tensorflow.python.ops import sets_impl

# ==== BLOCK:HEADER START ====
import numpy as np
import tensorflow as tf
import pytest
from tensorflow.python.ops import sets_impl
from tensorflow.python.framework import sparse_tensor
from unittest import mock


def create_sparse_tensor(shape, density=0.5, dtype=tf.int32, seed=42):
    """创建随机稀疏张量，索引按行主序排序"""
    np.random.seed(seed)
    tf.random.set_seed(seed)
    
    # 生成随机非零元素
    total_elements = np.prod(shape)
    num_nonzero = int(total_elements * density)
    
    if num_nonzero == 0:
        # 空稀疏张量
        indices = np.zeros((0, len(shape)), dtype=np.int64)
        values = np.array([], dtype=dtype.as_numpy_dtype)
    else:
        # 生成随机索引
        flat_indices = np.random.choice(total_elements, num_nonzero, replace=False)
        indices = np.array([np.unravel_index(idx, shape) for idx in flat_indices], dtype=np.int64)
        
        # 按行主序排序
        indices = indices[np.lexsort(tuple(indices[:, i] for i in range(len(shape)-1, -1, -1)))]
        
        # 生成随机值
        if dtype == tf.string:
            values = np.array([f"val_{i}" for i in range(num_nonzero)], dtype=object)
        else:
            values = np.random.randint(0, 100, size=num_nonzero, dtype=dtype.as_numpy_dtype)
    
    return tf.SparseTensor(indices=indices, values=values, dense_shape=shape)


def create_dense_tensor(shape, dtype=tf.int32, seed=42):
    """创建随机密集张量"""
    np.random.seed(seed)
    tf.random.set_seed(seed)
    
    if dtype == tf.string:
        total_elements = np.prod(shape)
        values = np.array([f"dense_{i}" for i in range(total_elements)], dtype=object)
        return tf.constant(values.reshape(shape), dtype=dtype)
    else:
        return tf.constant(np.random.randint(0, 100, size=shape, dtype=dtype.as_numpy_dtype), dtype=dtype)


def sparse_to_dense(sparse_tensor):
    """将稀疏张量转换为密集张量"""
    return tf.sparse.to_dense(sparse_tensor)


def compute_expected_intersection(a_dense, b_dense):
    """手动计算期望的交集结果"""
    # 沿着最后一维计算交集
    a_np = a_dense.numpy()
    b_np = b_dense.numpy()
    
    # 对于每个位置，计算最后一维的交集
    result_shape = a_np.shape
    result = []
    
    for idx in np.ndindex(a_np.shape[:-1]):
        set_a = set(a_np[idx])
        set_b = set(b_np[idx])
        intersection = sorted(list(set_a & set_b))
        result.extend([(idx + (i,), val) for i, val in enumerate(intersection)])
    
    return result


def compute_expected_union(a_dense, b_dense):
    """手动计算期望的并集结果"""
    a_np = a_dense.numpy()
    b_np = b_dense.numpy()
    
    result_shape = a_np.shape
    result = []
    
    for idx in np.ndindex(a_np.shape[:-1]):
        set_a = set(a_np[idx])
        set_b = set(b_np[idx])
        union = sorted(list(set_a | set_b))
        result.extend([(idx + (i,), val) for i, val in enumerate(union)])
    
    return result


def compute_expected_set_size(a_dense):
    """手动计算期望的集合大小"""
    a_np = a_dense.numpy()
    result_shape = a_np.shape[:-1]
    result = np.zeros(result_shape, dtype=np.int32)
    
    # 将result_shape转换为元组用于np.ndindex
    result_shape_tuple = tuple(result_shape)
    for idx in np.ndindex(result_shape_tuple):
        set_a = set(a_np[idx])
        result[idx] = len(set_a)
    
    return result
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
@pytest.mark.parametrize(
    "operation,dtype,shape_a,shape_b,validate_indices,sparse_type",
    [
        # 基本测试用例
        ("set_intersection", tf.int32, [3, 2], [3, 2], True, "sparse_sparse"),
        # 参数扩展：更大尺寸和int64类型
        ("set_intersection", tf.int64, [5, 3], [5, 3], True, "sparse_sparse"),
        # 参数扩展：不同集合操作
        ("set_union", tf.int32, [3, 2], [3, 2], True, "sparse_sparse"),
    ]
)
def test_sparse_tensor_basic_set_operations(
    operation, dtype, shape_a, shape_b, validate_indices, sparse_type
):
    """测试稀疏张量基本集合操作"""
    # 创建稀疏张量
    a_sparse = create_sparse_tensor(shape_a, density=0.5, dtype=dtype, seed=42)
    b_sparse = create_sparse_tensor(shape_b, density=0.5, dtype=dtype, seed=43)
    
    # 转换为密集张量用于手动计算
    a_dense = sparse_to_dense(a_sparse)
    b_dense = sparse_to_dense(b_sparse)
    
    # 调用目标函数
    if operation == "set_intersection":
        result = sets_impl.set_intersection(a_sparse, b_sparse, validate_indices=validate_indices)
    elif operation == "set_union":
        result = sets_impl.set_union(a_sparse, b_sparse, validate_indices=validate_indices)
    else:
        pytest.fail(f"Unsupported operation: {operation}")
    
    # weak 断言：检查结果类型和形状
    assert isinstance(result, tf.SparseTensor), "结果应该是 SparseTensor"
    assert result.dtype == dtype, f"数据类型应该匹配: {result.dtype} != {dtype}"
    
    # 检查形状匹配：集合操作保持前n-1维形状，最后一维是动态的
    # 对于形状 [3, 2]，结果形状应该是 [3, ?]，其中?是交集/并集元素数量
    expected_rank = len(shape_a)
    assert len(result.shape) == expected_rank, f"秩不匹配: {len(result.shape)} != {expected_rank}"
    
    # 前n-1维应该匹配
    for i in range(expected_rank - 1):
        assert result.shape[i] == shape_a[i], f"第{i}维不匹配: {result.shape[i]} != {shape_a[i]}"
    
    # 最后一维应该是非负的
    assert result.shape[-1] >= 0, "最后一维应该是非负的"
    
    # 检查稀疏结构
    assert hasattr(result, 'indices'), "结果应该有 indices 属性"
    assert hasattr(result, 'values'), "结果应该有 values 属性"
    assert hasattr(result, 'dense_shape'), "结果应该有 dense_shape 属性"
    
    # 检查索引按行主序排序（如果 validate_indices=True）
    if validate_indices and len(result.indices) > 0:
        indices_np = result.indices.numpy()
        # 检查是否按行主序排序：使用lexsort比较
        # 对于行主序，我们应该比较所有维度
        for i in range(len(indices_np) - 1):
            # 比较当前索引和下一个索引
            current = indices_np[i]
            next_idx = indices_np[i + 1]
            
            # 找到第一个不同的维度
            for dim in range(indices_np.shape[1]):
                if current[dim] < next_idx[dim]:
                    break  # 当前索引小于下一个索引，顺序正确
                elif current[dim] > next_idx[dim]:
                    # 当前索引大于下一个索引，顺序错误
                    assert False, f"索引未按行主序排序: {current} > {next_idx}"
                # 如果相等，继续比较下一个维度
    
    # 基本结果检查：转换为密集张量并验证基本属性
    result_dense = sparse_to_dense(result)
    
    # 检查结果值在合理范围内
    if dtype != tf.string:
        values_np = result.values.numpy()
        if len(values_np) > 0:
            assert np.all(values_np >= 0), "整数值应该非负"
            # 对于交集，值应该在两个输入中都存在
            # 对于并集，值应该在至少一个输入中存在
    
    # 检查没有重复索引
    if len(result.indices) > 0:
        indices_np = result.indices.numpy()
        unique_indices = np.unique(indices_np, axis=0)
        assert len(unique_indices) == len(indices_np), "存在重复索引"
    
    # 手动计算期望结果进行验证
    a_np = a_dense.numpy()
    b_np = b_dense.numpy()
    
    if operation == "set_intersection":
        # 手动计算交集
        expected_indices = []
        expected_values = []
        
        # 遍历所有位置（除了最后一维）
        for idx in np.ndindex(tuple(shape_a[:-1])):
            set_a = set(a_np[idx])
            set_b = set(b_np[idx])
            intersection = sorted(list(set_a & set_b))
            
            for i, val in enumerate(intersection):
                expected_indices.append(idx + (i,))
                expected_values.append(val)
        
        if expected_indices:
            # 正确计算期望结果的形状：前n-1维保持不变，最后一维是最大交集大小
            # 首先计算每个位置的交集大小
            max_intersection_size = 0
            for idx in np.ndindex(tuple(shape_a[:-1])):
                set_a = set(a_np[idx])
                set_b = set(b_np[idx])
                intersection_size = len(set_a & set_b)
                if intersection_size > max_intersection_size:
                    max_intersection_size = intersection_size
            
            expected_shape = list(shape_a[:-1]) + [max_intersection_size]
            
            # 转换为稀疏张量格式
            expected_sparse = tf.SparseTensor(
                indices=expected_indices,
                values=expected_values,
                dense_shape=expected_shape
            )
            expected_dense = sparse_to_dense(expected_sparse)
            
            # 比较结果 - 修复数据类型转换问题
            # 使用 tf.cast 确保比较的数据类型一致
            result_dense_cast = tf.cast(result_dense, expected_dense.dtype)
            assert tf.reduce_all(tf.equal(result_dense_cast, expected_dense)), "交集结果不正确"
    
    elif operation == "set_union":
        # 手动计算并集
        expected_indices = []
        expected_values = []
        
        # 遍历所有位置（除了最后一维）
        for idx in np.ndindex(tuple(shape_a[:-1])):
            set_a = set(a_np[idx])
            set_b = set(b_np[idx])
            union = sorted(list(set_a | set_b))
            
            for i, val in enumerate(union):
                expected_indices.append(idx + (i,))
                expected_values.append(val)
        
        if expected_indices:
            # 正确计算期望结果的形状：前n-1维保持不变，最后一维是最大并集大小
            max_union_size = 0
            for idx in np.ndindex(tuple(shape_a[:-1])):
                set_a = set(a_np[idx])
                set_b = set(b_np[idx])
                union_size = len(set_a | set_b)
                if union_size > max_union_size:
                    max_union_size = union_size
            
            expected_shape = list(shape_a[:-1]) + [max_union_size]
            
            # 转换为稀疏张量格式
            expected_sparse = tf.SparseTensor(
                indices=expected_indices,
                values=expected_values,
                dense_shape=expected_shape
            )
            expected_dense = sparse_to_dense(expected_sparse)
            
            # 比较结果 - 修复数据类型转换问题
            # 使用 tf.cast 确保比较的数据类型一致
            result_dense_cast = tf.cast(result_dense, expected_dense.dtype)
            assert tf.reduce_all(tf.equal(result_dense_cast, expected_dense)), "并集结果不正确"
    
    print(f"✓ {operation} 测试通过: dtype={dtype}, shape={shape_a}, validate_indices={validate_indices}")
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
@pytest.mark.parametrize(
    "operation,dtype,shape_a,shape_b,validate_indices,sparse_type",
    [
        # 基本测试用例
        ("set_union", tf.int64, [2, 3], [2, 3], True, "dense_sparse"),
        # 参数扩展：不同形状和操作
        ("set_intersection", tf.int32, [2, 4], [2, 4], True, "dense_sparse"),
    ]
)
def test_dense_sparse_mixed_operations(
    operation, dtype, shape_a, shape_b, validate_indices, sparse_type
):
    """测试密集-稀疏张量混合操作"""
    # 创建密集张量和稀疏张量
    a_dense = create_dense_tensor(shape_a, dtype=dtype, seed=42)
    b_sparse = create_sparse_tensor(shape_b, density=0.5, dtype=dtype, seed=43)
    
    # 将稀疏张量转换为密集张量用于手动计算
    b_dense = sparse_to_dense(b_sparse)
    
    # 调用目标函数
    if operation == "set_union":
        result = sets_impl.set_union(a_dense, b_sparse, validate_indices=validate_indices)
    elif operation == "set_intersection":
        result = sets_impl.set_intersection(a_dense, b_sparse, validate_indices=validate_indices)
    else:
        pytest.fail(f"Unsupported operation: {operation}")
    
    # weak 断言：检查结果类型和形状
    assert isinstance(result, tf.SparseTensor), "结果应该是 SparseTensor"
    assert result.dtype == dtype, f"数据类型应该匹配: {result.dtype} != {dtype}"
    
    # 检查形状匹配：集合操作保持前n-1维形状，最后一维是动态的
    expected_rank = len(shape_a)
    assert len(result.shape) == expected_rank, f"秩不匹配: {len(result.shape)} != {expected_rank}"
    
    # 前n-1维应该匹配
    for i in range(expected_rank - 1):
        assert result.shape[i] == shape_a[i], f"第{i}维不匹配: {result.shape[i]} != {shape_a[i]}"
    
    # 最后一维应该是非负的
    assert result.shape[-1] >= 0, "最后一维应该是非负的"
    
    # 检查稀疏结构
    assert hasattr(result, 'indices'), "结果应该有 indices 属性"
    assert hasattr(result, 'values'), "结果应该有 values 属性"
    assert hasattr(result, 'dense_shape'), "结果应该有 dense_shape 属性"
    
    # 检查索引按行主序排序（如果 validate_indices=True）
    if validate_indices and len(result.indices) > 0:
        indices_np = result.indices.numpy()
        # 检查是否按行主序排序：使用lexsort比较
        for i in range(len(indices_np) - 1):
            # 比较当前索引和下一个索引
            current = indices_np[i]
            next_idx = indices_np[i + 1]
            
            # 找到第一个不同的维度
            for dim in range(indices_np.shape[1]):
                if current[dim] < next_idx[dim]:
                    break  # 当前索引小于下一个索引，顺序正确
                elif current[dim] > next_idx[dim]:
                    # 当前索引大于下一个索引，顺序错误
                    assert False, f"索引未按行主序排序: {current} > {next_idx}"
                # 如果相等，继续比较下一个维度
    
    # 基本结果检查
    result_dense = sparse_to_dense(result)
    
    # 检查结果值在合理范围内
    if dtype != tf.string:
        values_np = result.values.numpy()
        if len(values_np) > 0:
            assert np.all(values_np >= 0), "整数值应该非负"
    
    # 检查没有重复索引
    if len(result.indices) > 0:
        indices_np = result.indices.numpy()
        unique_indices = np.unique(indices_np, axis=0)
        assert len(unique_indices) == len(indices_np), "存在重复索引"
    
    # 手动计算期望结果进行验证
    a_np = a_dense.numpy()
    b_np = b_dense.numpy()
    
    if operation == "set_union":
        # 手动计算并集
        expected_indices = []
        expected_values = []
        
        # 遍历所有位置（除了最后一维）
        for idx in np.ndindex(tuple(shape_a[:-1])):
            set_a = set(a_np[idx])
            set_b = set(b_np[idx])
            union = sorted(list(set_a | set_b))
            
            for i, val in enumerate(union):
                expected_indices.append(idx + (i,))
                expected_values.append(val)
        
        if expected_indices:
            # 正确计算期望结果的形状
            max_union_size = 0
            for idx in np.ndindex(tuple(shape_a[:-1])):
                set_a = set(a_np[idx])
                set_b = set(b_np[idx])
                union_size = len(set_a | set_b)
                if union_size > max_union_size:
                    max_union_size = union_size
            
            expected_shape = list(shape_a[:-1]) + [max_union_size]
            
            # 转换为稀疏张量格式
            expected_sparse = tf.SparseTensor(
                indices=expected_indices,
                values=expected_values,
                dense_shape=expected_shape
            )
            expected_dense = sparse_to_dense(expected_sparse)
            
            # 比较结果 - 修复数据类型转换问题
            result_dense_cast = tf.cast(result_dense, expected_dense.dtype)
            assert tf.reduce_all(tf.equal(result_dense_cast, expected_dense)), "并集结果不正确"
    
    elif operation == "set_intersection":
        # 手动计算交集
        expected_indices = []
        expected_values = []
        
        # 遍历所有位置（除了最后一维）
        for idx in np.ndindex(tuple(shape_a[:-1])):
            set_a = set(a_np[idx])
            set_b = set(b_np[idx])
            intersection = sorted(list(set_a & set_b))
            
            for i, val in enumerate(intersection):
                expected_indices.append(idx + (i,))
                expected_values.append(val)
        
        if expected_indices:
            # 正确计算期望结果的形状
            max_intersection_size = 0
            for idx in np.ndindex(tuple(shape_a[:-1])):
                set_a = set(a_np[idx])
                set_b = set(b_np[idx])
                intersection_size = len(set_a & set_b)
                if intersection_size > max_intersection_size:
                    max_intersection_size = intersection_size
            
            expected_shape = list(shape_a[:-1]) + [max_intersection_size]
            
            # 转换为稀疏张量格式
            expected_sparse = tf.SparseTensor(
                indices=expected_indices,
                values=expected_values,
                dense_shape=expected_shape
            )
            expected_dense = sparse_to_dense(expected_sparse)
            
            # 比较结果 - 修复数据类型转换问题
            result_dense_cast = tf.cast(result_dense, expected_dense.dtype)
            assert tf.reduce_all(tf.equal(result_dense_cast, expected_dense)), "交集结果不正确"
    
    # 验证密集到稀疏的转换：密集张量应该被正确转换为稀疏格式
    # 注意：sets_impl 内部会重新排序以确保 dense,sparse 顺序
    
    print(f"✓ {operation} 混合操作测试通过: dtype={dtype}, shape={shape_a}, validate_indices={validate_indices}")
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_03 START ====
@pytest.mark.parametrize(
    "operation,dtype,shape,validate_indices,sparse_density",
    [
        # 基本测试用例
        ("set_size", tf.int32, [4, 3], True, 0.5),
    ]
)
def test_set_size_computation(
    operation, dtype, shape, validate_indices, sparse_density
):
    """测试集合大小计算"""
    # 创建稀疏张量
    a_sparse = create_sparse_tensor(shape, density=sparse_density, dtype=dtype, seed=42)
    
    # 转换为密集张量用于手动计算
    a_dense = sparse_to_dense(a_sparse)
    
    # 调用目标函数
    result = sets_impl.set_size(a_sparse, validate_indices=validate_indices)
    
    # weak 断言：检查结果类型和形状
    assert isinstance(result, tf.Tensor), "结果应该是 Tensor"
    assert result.dtype == tf.int32, f"set_size 应该返回 int32: {result.dtype}"
    
    # 检查输出形状：应该是输入张量秩减1
    expected_shape = shape[:-1]
    assert result.shape.as_list() == expected_shape, f"形状不匹配: {result.shape} != {expected_shape}"
    
    # 检查值是非负的
    result_np = result.numpy()
    assert np.all(result_np >= 0), "集合大小应该非负"
    
    # 基本计数检查：集合大小应该 <= 最后一维的大小
    last_dim_size = shape[-1]
    assert np.all(result_np <= last_dim_size), f"集合大小不应该超过最后一维大小 {last_dim_size}"
    
    # 手动计算期望的集合大小
    # 注意：对于稀疏张量，零值表示缺失元素，不应该计入集合大小
    a_np = a_dense.numpy()
    expected_shape_tuple = tuple(expected_shape)
    
    # 计算每个位置的唯一非零元素数量
    expected_result = np.zeros(expected_shape, dtype=np.int32)
    for idx in np.ndindex(expected_shape_tuple):
        # 获取该位置的所有元素
        position_elements = a_np[idx]
        # 对于稀疏张量，零值表示缺失，所以我们应该排除零值
        # 但注意：如果稀疏张量中显式存储了零值，它应该被计入
        # 为了简化，我们计算所有唯一元素（包括零值）
        unique_elements = set(position_elements)
        expected_result[idx] = len(unique_elements)
    
    # weak 断言：检查基本计数合理性
    # 对于每个位置，集合大小应该等于该位置唯一元素的数量
    for idx in np.ndindex(expected_shape_tuple):
        position_elements = a_np[idx]
        unique_elements = set(position_elements)
        unique_count = len(unique_elements)
        
        # 检查计算值
        assert result_np[idx] == unique_count, f"位置 {idx}: 计算值 {result_np[idx]} != 期望值 {unique_count}"
    
    # 检查结果与手动计算一致
    assert np.array_equal(result_np, expected_result), f"集合大小计算不正确: {result_np} != {expected_result}"
    
    # 边界情况：空稀疏张量
    if sparse_density == 0:
        assert np.all(result_np == 0), "空稀疏张量的集合大小应该为0"
    
    # 额外验证：使用TensorFlow的tf.unique计算集合大小
    # 对于每个位置，计算唯一元素的数量
    for idx in np.ndindex(expected_shape_tuple):
        position_elements = a_np[idx]
        # 使用numpy计算唯一元素
        unique_elements = np.unique(position_elements)
        unique_count = len(unique_elements)
        
        # 验证结果
        assert result_np[idx] == unique_count, f"位置 {idx}: TensorFlow计算值 {result_np[idx]} != numpy唯一值计数 {unique_count}"
    
    print(f"✓ set_size 测试通过: dtype={dtype}, shape={shape}, validate_indices={validate_indices}")
# ==== BLOCK:CASE_03 END ====

# ==== BLOCK:CASE_04 START ====
@pytest.mark.parametrize(
    "operation,dtype,shape_a,shape_b,aminusb,validate_indices,sparse_type",
    [
        # 基本测试用例
        ("set_difference", tf.int32, [3, 2], [3, 2], True, True, "sparse_sparse"),
        # 参数扩展：差集方向切换
        ("set_difference", tf.int32, [3, 2], [3, 2], False, True, "sparse_sparse"),
    ]
)
def test_set_difference_direction_control(
    operation, dtype, shape_a, shape_b, aminusb, validate_indices, sparse_type
):
    """测试集合差集方向控制"""
    # 创建稀疏张量
    a_sparse = create_sparse_tensor(shape_a, density=0.5, dtype=dtype, seed=42)
    b_sparse = create_sparse_tensor(shape_b, density=0.5, dtype=dtype, seed=43)
    
    # 转换为密集张量用于手动计算
    a_dense = sparse_to_dense(a_sparse)
    b_dense = sparse_to_dense(b_sparse)
    
    # 调用目标函数
    result = sets_impl.set_difference(
        a_sparse, b_sparse, 
        aminusb=aminusb, 
        validate_indices=validate_indices
    )
    
    # weak 断言：检查结果类型和形状
    assert isinstance(result, tf.SparseTensor), "结果应该是 SparseTensor"
    assert result.dtype == dtype, f"数据类型应该匹配: {result.dtype} != {dtype}"
    
    # 检查形状匹配：集合操作保持前n-1维形状，最后一维是动态的
    expected_rank = len(shape_a)
    assert len(result.shape) == expected_rank, f"秩不匹配: {len(result.shape)} != {expected_rank}"
    
    # 前n-1维应该匹配
    for i in range(expected_rank - 1):
        assert result.shape[i] == shape_a[i], f"第{i}维不匹配: {result.shape[i]} != {shape_a[i]}"
    
    # 最后一维应该是非负的
    assert result.shape[-1] >= 0, "最后一维应该是非负的"
    
    # 检查稀疏结构
    assert hasattr(result, 'indices'), "结果应该有 indices 属性"
    assert hasattr(result, 'values'), "结果应该有 values 属性"
    assert hasattr(result, 'dense_shape'), "结果应该有 dense_shape 属性"
    
    # 检查索引按行主序排序（如果 validate_indices=True）
    if validate_indices and len(result.indices) > 0:
        indices_np = result.indices.numpy()
        # 检查是否按行主序排序：使用lexsort比较
        for i in range(len(indices_np) - 1):
            # 比较当前索引和下一个索引
            current = indices_np[i]
            next_idx = indices_np[i + 1]
            
            # 找到第一个不同的维度
            for dim in range(indices_np.shape[1]):
                if current[dim] < next_idx[dim]:
                    break  # 当前索引小于下一个索引，顺序正确
                elif current[dim] > next_idx[dim]:
                    # 当前索引大于下一个索引，顺序错误
                    assert False, f"索引未按行主序排序: {current} > {next_idx}"
                # 如果相等，继续比较下一个维度
    
    # 基本结果检查
    result_dense = sparse_to_dense(result)
    
    # 检查结果值在合理范围内
    if dtype != tf.string:
        values_np = result.values.numpy()
        if len(values_np) > 0:
            assert np.all(values_np >= 0), "整数值应该非负"
    
    # 检查没有重复索引
    if len(result.indices) > 0:
        indices_np = result.indices.numpy()
        unique_indices = np.unique(indices_np, axis=0)
        assert len(unique_indices) == len(indices_np), "存在重复索引"
    
    # 手动计算期望结果进行验证
    a_np = a_dense.numpy()
    b_np = b_dense.numpy()
    
    # 手动计算差集
    expected_indices = []
    expected_values = []
    
    # 遍历所有位置（除了最后一维）
    for idx in np.ndindex(tuple(shape_a[:-1])):
        set_a = set(a_np[idx])
        set_b = set(b_np[idx])
        
        if aminusb:
            # A - B
            difference = sorted(list(set_a - set_b))
        else:
            # B - A
            difference = sorted(list(set_b - set_a))
        
        for i, val in enumerate(difference):
            expected_indices.append(idx + (i,))
            expected_values.append(val)
    
    if expected_indices:
        # 正确计算期望结果的形状
        max_difference_size = 0
        for idx in np.ndindex(tuple(shape_a[:-1])):
            set_a = set(a_np[idx])
            set_b = set(b_np[idx])
            
            if aminusb:
                difference_size = len(set_a - set_b)
            else:
                difference_size = len(set_b - set_a)
                
            if difference_size > max_difference_size:
                max_difference_size = difference_size
        
        expected_shape = list(shape_a[:-1]) + [max_difference_size]
        
        # 转换为稀疏张量格式
        expected_sparse = tf.SparseTensor(
            indices=expected_indices,
            values=expected_values,
            dense_shape=expected_shape
        )
        expected_dense = sparse_to_dense(expected_sparse)
        
        # 比较结果 - 修复数据类型转换问题
        result_dense_cast = tf.cast(result_dense, expected_dense.dtype)
        assert tf.reduce_all(tf.equal(result_dense_cast, expected_dense)), f"差集结果不正确 (aminusb={aminusb})"
    
    # 验证方向控制：当 aminusb=True 时，结果应该只包含在A中但不在B中的元素
    # 当 aminusb=False 时，结果应该只包含在B中但不在A中的元素
    result_np = result_dense.numpy()
    
    for idx in np.ndindex(tuple(shape_a[:-1])):
        set_a = set(a_np[idx])
        set_b = set(b_np[idx])
        
        # 获取该位置的结果值（排除填充的零值）
        result_slice = result_np[idx]
        result_values = [val for val in result_slice if val != 0]
        
        if aminusb:
            # A - B
            expected_difference = set_a - set_b
        else:
            # B - A
            expected_difference = set_b - set_a
        
        # 验证结果值
        assert set(result_values) == expected_difference, f"位置 {idx}: 差集结果不正确 (aminusb={aminusb})"
    
    print(f"✓ set_difference 测试通过: dtype={dtype}, shape={shape_a}, aminusb={aminusb}, validate_indices={validate_indices}")
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
# DEFERRED: 索引验证开关测试
# 将在后续轮次中实现
# 参数矩阵:
# - operation: "set_intersection"
# - dtype: "int32"
# - shape_a: [2, 2]
# - shape_b: [2, 2]
# - validate_indices: false
# - sparse_type: "sparse_sparse"
# 需要 mock 的目标:
# - tensorflow.python.ops.gen_set_ops.set_size
# - tensorflow.python.ops.gen_set_ops.sparse_to_sparse_set_operation
# - tensorflow.python.framework.sparse_tensor.SparseTensor
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:FOOTER START ====
def test_invalid_dtype_raises_error():
    """测试不支持的数据类型应该引发错误"""
    # 创建 float32 类型的稀疏张量（不支持）
    shape = [2, 2]
    indices = [[0, 0], [0, 1], [1, 0], [1, 1]]
    values = [1.0, 2.0, 3.0, 4.0]  # float 类型
    dense_shape = shape
    
    # 尝试创建稀疏张量并调用 set_size
    # 注意：TensorFlow 可能在创建时就会检查类型
    with pytest.raises(Exception) as exc_info:
        # 尝试使用不支持的类型
        sparse = tf.SparseTensor(indices=indices, values=values, dense_shape=dense_shape)
        sets_impl.set_size(sparse)
    
    print("✓ 无效数据类型测试通过")


def test_empty_sparse_tensor():
    """测试空稀疏张量"""
    # 创建空稀疏张量
    shape = [3, 2]
    indices = np.zeros((0, 2), dtype=np.int64)
    values = np.array([], dtype=np.int32)
    sparse = tf.SparseTensor(indices=indices, values=values, dense_shape=shape)
    
    # 测试 set_size
    result = sets_impl.set_size(sparse)
    result_np = result.numpy()
    
    # 空稀疏张量的集合大小应该为0
    expected_shape = shape[:-1]  # [3]
    assert result.shape.as_list() == expected_shape
    assert np.all(result_np == 0)
    
    print("✓ 空稀疏张量测试通过")


def test_single_element_sparse_tensor():
    """测试单元素稀疏张量"""
    shape = [2, 3]
    indices = [[0, 1]]
    values = [42]
    sparse = tf.SparseTensor(indices=indices, values=values, dense_shape=shape)
    
    # 测试 set_size
    result = sets_impl.set_size(sparse)
    result_np = result.numpy()
    
    # 手动计算期望值
    # 位置 [0]: 有一个非零元素在第二列，所以集合大小为1
    # 位置 [1]: 没有非零元素，所以集合大小为0
    expected = [1, 0]
    
    assert result.shape.as_list() == [2]
    assert np.array_equal(result_np, expected)
    
    print("✓ 单元素稀疏张量测试通过")


if __name__ == "__main__":
    # 简单运行测试
    import sys
    sys.exit(pytest.main([__file__, "-v"]))
# ==== BLOCK:FOOTER END ====