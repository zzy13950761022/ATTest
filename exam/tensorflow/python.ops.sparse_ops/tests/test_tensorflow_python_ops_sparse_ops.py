"""
Test cases for tensorflow.python.ops.sparse_ops module.
Generated by ATTest.
"""

import math
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.ops import sparse_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# ==== BLOCK:HEADER START ====
"""
Test cases for tensorflow.python.ops.sparse_ops module.
Generated by ATTest.
"""

import math
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.ops import sparse_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# Tolerance for floating point comparisons
FLOAT_TOLERANCE = 1e-6

# Helper function to compare sparse tensors
def assert_sparse_tensor_equal(actual, expected_indices, expected_values, expected_shape, tolerance=FLOAT_TOLERANCE):
    """Assert that a sparse tensor matches expected values."""
    # Check indices
    actual_indices = actual.indices.numpy()
    np.testing.assert_array_equal(actual_indices, expected_indices)
    
    # Check values
    actual_values = actual.values.numpy()
    if np.issubdtype(actual_values.dtype, np.floating):
        np.testing.assert_allclose(actual_values, expected_values, rtol=tolerance)
    else:
        np.testing.assert_array_equal(actual_values, expected_values)
    
    # Check shape - TensorShape doesn't have numpy() method, use list() instead
    actual_shape = list(actual.shape)
    np.testing.assert_array_equal(actual_shape, expected_shape)

# Helper function to create sparse tensor
def create_sparse_tensor(indices, values, shape, dtype=tf.float32):
    """Create a SparseTensor with given indices, values and shape."""
    return tf.sparse.SparseTensor(
        indices=indices,
        values=values,
        dense_shape=shape
    )

# Helper function to create dense tensor
def create_dense_tensor(values, dtype=tf.float32):
    """Create a dense tensor from numpy array."""
    return tf.constant(values, dtype=dtype)
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
# Test case: from_dense 基本转换
@pytest.mark.parametrize(
    "dtype_str,shape,dense_values,expected_indices,expected_values",
    [
        # Basic 1D case from test plan
        (
            "float32",
            [5],
            [0, 0, 3, 0, 1],
            [[2], [4]],
            [3.0, 1.0]
        ),
        # 2D integer tensor extension
        (
            "int32",
            [3, 3],
            [[0, 5, 0], [0, 0, 0], [2, 0, 8]],
            [[0, 1], [2, 0], [2, 2]],
            [5, 2, 8]
        ),
        # All zeros dense tensor extension
        (
            "float64",
            [10],
            [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
            [],
            []
        ),
    ]
)
def test_from_dense_basic_conversion(dtype_str, shape, dense_values, expected_indices, expected_values):
    """Test basic dense to sparse conversion using from_dense."""
    # Convert dtype string to tf dtype
    dtype_map = {
        "float32": tf.float32,
        "float64": tf.float64,
        "int32": tf.int32,
    }
    dtype = dtype_map[dtype_str]
    
    # Create dense tensor
    dense_tensor = tf.constant(dense_values, dtype=dtype)
    
    # Convert to sparse
    sparse_result = tf.sparse.from_dense(dense_tensor)
    
    # Verify shape - TensorShape doesn't have numpy() method, use as_list() instead
    assert list(sparse_result.shape) == shape
    
    # Verify dtype
    assert sparse_result.values.dtype == dtype
    
    # Verify indices and values
    actual_indices = sparse_result.indices.numpy().tolist()
    actual_values = sparse_result.values.numpy().tolist()
    
    # For empty sparse tensor
    if len(expected_indices) == 0:
        assert len(actual_indices) == 0
        assert len(actual_values) == 0
    else:
        # Check indices match (order is guaranteed by from_dense)
        assert actual_indices == expected_indices
        
        # Check values match with tolerance for floating point
        if dtype in [tf.float32, tf.float64]:
            np.testing.assert_allclose(actual_values, expected_values, rtol=FLOAT_TOLERANCE)
        else:
            assert actual_values == expected_values
    
    # Additional weak assertions from test plan
    # 1. shape_match - already verified
    # 2. dtype_match - already verified
    # 3. indices_correct - already verified
    # 4. values_correct - already verified
    
    # Test roundtrip consistency (weak assertion)
    if len(expected_indices) > 0:  # Skip empty case for roundtrip
        # Convert back to dense
        dense_roundtrip = tf.sparse.to_dense(sparse_result)
        # Compare with original
        if dtype in [tf.float32, tf.float64]:
            np.testing.assert_allclose(
                dense_roundtrip.numpy(),
                dense_tensor.numpy(),
                rtol=FLOAT_TOLERANCE
            )
        else:
            np.testing.assert_array_equal(
                dense_roundtrip.numpy(),
                dense_tensor.numpy()
            )
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
# Test case: sparse_to_dense 基本填充
@pytest.mark.parametrize(
    "indices,values,shape,default_value,dtype_str",
    [
        # Basic 2D case from test plan
        (
            [[0, 0], [1, 2]],
            [1.0, 2.0],
            [3, 4],
            0.0,
            "float32"
        ),
        # 1D tensor with different default value extension
        (
            [[0], [2], [4]],
            [10.0, 20.0, 30.0],
            [5],
            -1.0,
            "float32"
        ),
    ]
)
def test_sparse_to_dense_basic_filling(indices, values, shape, default_value, dtype_str):
    """Test basic sparse to dense conversion using sparse_to_dense."""
    # Convert dtype string to tf dtype
    dtype_map = {
        "float32": tf.float32,
        "float64": tf.float64,
        "int32": tf.int32,
    }
    dtype = dtype_map[dtype_str]
    
    # Create sparse tensor indices and values
    sparse_indices = tf.constant(indices, dtype=tf.int64)
    sparse_values = tf.constant(values, dtype=dtype)
    output_shape = tf.constant(shape, dtype=tf.int64)
    default_val = tf.constant(default_value, dtype=dtype)
    
    # Convert to dense using sparse_ops.sparse_to_dense
    dense_result = sparse_ops.sparse_to_dense(
        sparse_indices=sparse_indices,
        output_shape=output_shape,
        sparse_values=sparse_values,
        default_value=default_val,
        validate_indices=True
    )
    
    # Verify output shape
    assert dense_result.shape.as_list() == shape
    
    # Verify dtype
    assert dense_result.dtype == dtype
    
    # Create expected dense tensor manually
    expected_dense = np.full(shape, default_value, dtype=np.float32 if dtype == tf.float32 else np.float64)
    
    # Fill in the sparse values at specified indices
    for idx, val in zip(indices, values):
        # Handle multi-dimensional indexing
        if len(shape) == 1:
            expected_dense[idx[0]] = val
        elif len(shape) == 2:
            expected_dense[idx[0], idx[1]] = val
    
    # Convert to tensor for comparison
    expected_tensor = tf.constant(expected_dense, dtype=dtype)
    
    # Compare results with tolerance for floating point
    if dtype in [tf.float32, tf.float64]:
        np.testing.assert_allclose(
            dense_result.numpy(),
            expected_tensor.numpy(),
            rtol=FLOAT_TOLERANCE
        )
    else:
        np.testing.assert_array_equal(
            dense_result.numpy(),
            expected_tensor.numpy()
        )
    
    # Additional weak assertions from test plan
    # 1. output_shape - already verified
    # 2. dtype_match - already verified
    # 3. sparse_values_placed - verified by manual filling check
    # 4. default_filled - verified by np.full initialization
    
    # Test with SparseTensor.to_dense() for comparison
    sparse_tensor = tf.sparse.SparseTensor(
        indices=indices,
        values=values,
        dense_shape=shape
    )
    dense_from_sparse = tf.sparse.to_dense(sparse_tensor, default_value=default_value)
    
    # Compare with our result
    if dtype in [tf.float32, tf.float64]:
        np.testing.assert_allclose(
            dense_result.numpy(),
            dense_from_sparse.numpy(),
            rtol=FLOAT_TOLERANCE
        )
    else:
        np.testing.assert_array_equal(
            dense_result.numpy(),
            dense_from_sparse.numpy()
        )
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_03 START ====
# Test case: sparse_tensor_dense_mat_mul 矩阵乘法
@pytest.mark.parametrize(
    "sparse_shape,sparse_indices,sparse_values,dense_shape,dtype_str,adjoint_a",
    [
        # Basic case from test plan
        (
            [2, 3],
            [[0, 1], [1, 2]],
            [2.0, 3.0],
            [3, 2],
            "float32",
            False
        ),
        # Extension with adjoint operation and double precision
        (
            [4, 4],
            [[0, 0], [1, 1], [2, 2], [3, 3]],
            [1.0, 1.0, 1.0, 1.0],
            [4, 4],
            "float64",
            True
        ),
    ]
)
def test_sparse_tensor_dense_mat_mul_basic(
    sparse_shape, sparse_indices, sparse_values, dense_shape, dtype_str, adjoint_a
):
    """Test sparse tensor dense matrix multiplication."""
    # Convert dtype string to tf dtype
    dtype_map = {
        "float32": tf.float32,
        "float64": tf.float64,
    }
    dtype = dtype_map[dtype_str]
    
    # Create sparse tensor components
    a_indices = tf.constant(sparse_indices, dtype=tf.int64)
    a_values = tf.constant(sparse_values, dtype=dtype)
    a_shape = tf.constant(sparse_shape, dtype=tf.int64)
    
    # Create dense matrix B
    # Generate a simple dense matrix for testing
    # For basic case: B is 3x2, for extension: B is 4x4
    b_rows, b_cols = dense_shape
    b_values = np.arange(b_rows * b_cols, dtype=np.float32 if dtype == tf.float32 else np.float64)
    b_values = b_values.reshape(b_rows, b_cols) + 1.0  # Start from 1.0
    b = tf.constant(b_values, dtype=dtype)
    
    # Calculate expected result manually
    # For sparse matrix A (m x n) and dense matrix B (n x p)
    # Result C = A @ B (m x p)
    m, n = sparse_shape
    n_check, p = dense_shape
    
    # Verify dimension compatibility
    assert n == n_check, f"Sparse matrix columns ({n}) must match dense matrix rows ({n_check})"
    
    # Initialize result matrix with zeros
    result_shape = [m, p] if not adjoint_a else [n, p]
    expected_result = np.zeros(result_shape, dtype=np.float32 if dtype == tf.float32 else np.float64)
    
    # Manual sparse-dense multiplication
    if not adjoint_a:
        # C[i, j] = sum_k A[i, k] * B[k, j]
        for (row, col), value in zip(sparse_indices, sparse_values):
            for j in range(p):
                expected_result[row, j] += value * b_values[col, j]
    else:
        # With adjoint_a=True, we use A^T (n x m) @ B (n x p)
        # Actually sparse_tensor_dense_mat_mul with adjoint_a=True computes A^T @ B
        # So result shape is n x p
        for (row, col), value in zip(sparse_indices, sparse_values):
            for j in range(p):
                expected_result[col, j] += value * b_values[col, j]
    
    # Perform the operation
    result = sparse_ops.sparse_tensor_dense_mat_mul(
        a_indices=a_indices,
        a_values=a_values,
        a_shape=a_shape,
        b=b,
        adjoint_a=adjoint_a,
        adjoint_b=False
    )
    
    # Verify result shape
    assert result.shape.as_list() == result_shape
    
    # Verify dtype
    assert result.dtype == dtype
    
    # Compare with expected result
    np.testing.assert_allclose(
        result.numpy(),
        expected_result,
        rtol=FLOAT_TOLERANCE * 10,  # Slightly higher tolerance for matrix multiplication
        atol=FLOAT_TOLERANCE * 10
    )
    
    # Additional weak assertions from test plan
    # 1. result_shape - already verified
    # 2. dtype_match - already verified
    # 3. basic_calculation - verified by manual calculation comparison
    # 4. dimension_compatibility - verified by assert
    
    # Test with dense equivalent for non-adjoint case
    if not adjoint_a and len(sparse_indices) > 0:
        # Create dense version of sparse matrix
        dense_a = np.zeros(sparse_shape, dtype=np.float32 if dtype == tf.float32 else np.float64)
        for (row, col), value in zip(sparse_indices, sparse_values):
            dense_a[row, col] = value
        
        # Compute dense matrix multiplication
        dense_result = np.dot(dense_a, b_values)
        
        # Compare with sparse result
        np.testing.assert_allclose(
            result.numpy(),
            dense_result,
            rtol=FLOAT_TOLERANCE * 10,
            atol=FLOAT_TOLERANCE * 10
        )
# ==== BLOCK:CASE_03 END ====

# ==== BLOCK:CASE_04 START ====
# Test case: 边界条件 - 空稀疏张量
@pytest.mark.parametrize(
    "indices,values,shape,dtype_str,operation",
    [
        # Basic empty sparse tensor case from test plan
        (
            [],
            [],
            [3, 4],
            "float32",
            "to_dense"
        ),
        # Large shape empty tensor extension
        (
            [],
            [],
            [1000, 1000],
            "float32",
            "from_dense"
        ),
    ]
)
def test_empty_sparse_tensor_boundary(indices, values, shape, dtype_str, operation):
    """Test boundary conditions with empty sparse tensors."""
    # Convert dtype string to tf dtype
    dtype_map = {
        "float32": tf.float32,
        "float64": tf.float64,
        "int32": tf.int32,
    }
    dtype = dtype_map[dtype_str]
    
    if operation == "to_dense":
        # Test 1: Empty sparse tensor to dense conversion
        # Create empty sparse tensor with correct shape for indices
        # For empty sparse tensor, indices should have shape (0, rank)
        rank = len(shape)
        if rank == 1:
            # For 1D tensor, indices should be (0, 1)
            indices_shape = (0, 1)
        else:
            # For multi-dimensional tensor, indices should be (0, rank)
            indices_shape = (0, rank)
        
        # Create indices tensor with correct shape
        sparse_indices = tf.constant([], dtype=tf.int64, shape=indices_shape)
        sparse_values = tf.constant([], dtype=dtype)
        
        # Create SparseTensor
        sparse_tensor = tf.sparse.SparseTensor(
            indices=sparse_indices,
            values=sparse_values,
            dense_shape=shape
        )
        
        # Convert to dense with default value 0
        dense_result = tf.sparse.to_dense(sparse_tensor, default_value=0.0)
        
        # Verify output shape
        assert dense_result.shape.as_list() == shape
        
        # Verify dtype
        assert dense_result.dtype == dtype
        
        # Verify all values are default (0.0)
        expected_dense = np.zeros(shape, dtype=np.float32 if dtype == tf.float32 else np.float64)
        if dtype in [tf.float32, tf.float64]:
            np.testing.assert_allclose(
                dense_result.numpy(),
                expected_dense,
                rtol=FLOAT_TOLERANCE
            )
        else:
            np.testing.assert_array_equal(
                dense_result.numpy(),
                expected_dense
            )
        
        # Additional weak assertions from test plan
        # 1. empty_handling - verified by successful conversion
        # 2. shape_preserved - already verified
        # 3. all_default_values - verified by np.zeros comparison
        
        # Test with different default value
        default_val = 5.0
        dense_with_default = tf.sparse.to_dense(sparse_tensor, default_value=default_val)
        expected_with_default = np.full(shape, default_val, dtype=np.float32 if dtype == tf.float32 else np.float64)
        
        if dtype in [tf.float32, tf.float64]:
            np.testing.assert_allclose(
                dense_with_default.numpy(),
                expected_with_default,
                rtol=FLOAT_TOLERANCE
            )
        else:
            np.testing.assert_array_equal(
                dense_with_default.numpy(),
                expected_with_default
            )
    
    elif operation == "from_dense":
        # Test 2: Dense tensor with all zeros to sparse conversion
        # Create dense tensor with all zeros
        dense_values = np.zeros(shape, dtype=np.float32 if dtype == tf.float32 else np.float64)
        dense_tensor = tf.constant(dense_values, dtype=dtype)
        
        # Convert to sparse
        sparse_result = tf.sparse.from_dense(dense_tensor)
        
        # Verify shape
        assert list(sparse_result.shape) == shape
        
        # Verify dtype
        assert sparse_result.values.dtype == dtype
        
        # Verify indices and values are empty
        actual_indices = sparse_result.indices.numpy().tolist()
        actual_values = sparse_result.values.numpy().tolist()
        
        assert len(actual_indices) == 0, f"Expected empty indices, got {actual_indices}"
        assert len(actual_values) == 0, f"Expected empty values, got {actual_values}"
        
        # Verify indices shape is correct (0, rank)
        assert sparse_result.indices.shape.as_list() == [0, len(shape)]
        
        # Verify roundtrip consistency
        dense_roundtrip = tf.sparse.to_dense(sparse_result)
        if dtype in [tf.float32, tf.float64]:
            np.testing.assert_allclose(
                dense_roundtrip.numpy(),
                dense_tensor.numpy(),
                rtol=FLOAT_TOLERANCE
            )
        else:
            np.testing.assert_array_equal(
                dense_roundtrip.numpy(),
                dense_tensor.numpy()
            )
        
        # Additional weak assertions from test plan
        # 1. empty_handling - verified by successful conversion with empty result
        # 2. shape_preserved - already verified
        # 3. all_default_values - verified by all zeros input
        
        # Test memory efficiency by checking tensor sizes
        # For large shapes, sparse representation should be more memory efficient
        if shape == [1000, 1000]:
            # Check that sparse representation has no values
            assert sparse_result.values.shape.as_list() == [0]
            assert sparse_result.indices.shape.as_list() == [0, 2]
    
    # Test that operations don't crash with empty tensors
    # This is implicitly tested by the successful execution above
    
    # Test edge case: shape with zero dimensions
    if operation == "to_dense" and shape == [3, 4]:
        # Test with zero in shape (not allowed in TensorFlow)
        # This is just to document the behavior
        pass
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
# Test case: 异常输入验证
@pytest.mark.parametrize(
    "test_type,indices,values,shape,dtype_str,expected_error_type,expected_error_message",
    [
        # Unsorted indices case from test plan
        (
            "unsorted_indices",
            [[1, 0], [0, 0]],
            [1.0, 2.0],
            [2, 2],
            "float32",
            tf.errors.InvalidArgumentError,
            "indices are not sorted"
        ),
        # Additional test: duplicate indices
        (
            "duplicate_indices",
            [[0, 0], [0, 0]],
            [1.0, 2.0],
            [2, 2],
            "float32",
            tf.errors.InvalidArgumentError,
            "indices are not sorted"
        ),
        # Additional test: out of bounds indices
        (
            "out_of_bounds",
            [[0, 0], [2, 2]],
            [1.0, 2.0],
            [2, 2],
            "float32",
            tf.errors.InvalidArgumentError,
            "out of bounds"
        ),
    ]
)
def test_invalid_input_validation(
    test_type, indices, values, shape, dtype_str, expected_error_type, expected_error_message
):
    """Test validation of invalid inputs for sparse operations."""
    # Convert dtype string to tf dtype
    dtype_map = {
        "float32": tf.float32,
        "float64": tf.float64,
        "int32": tf.int32,
    }
    dtype = dtype_map[dtype_str]
    
    # Create tensor components
    sparse_indices = tf.constant(indices, dtype=tf.int64)
    sparse_values = tf.constant(values, dtype=dtype)
    output_shape = tf.constant(shape, dtype=tf.int64)
    default_value = tf.constant(0.0, dtype=dtype)
    
    # Test 1: sparse_to_dense with validate_indices=True should raise error
    with pytest.raises(expected_error_type) as exc_info:
        sparse_ops.sparse_to_dense(
            sparse_indices=sparse_indices,
            output_shape=output_shape,
            sparse_values=sparse_values,
            default_value=default_value,
            validate_indices=True  # This should trigger validation
        )
    
    # Check error message contains expected text
    error_message = str(exc_info.value)
    assert expected_error_message.lower() in error_message.lower(), \
        f"Expected error message containing '{expected_error_message}', got: {error_message}"
    
    # Additional weak assertions from test plan
    # 1. error_type_match - verified by pytest.raises
    # 2. error_message_contains - verified above
    # 3. no_side_effects - verified by the fact that exception was raised
    
    # Test 2: sparse_to_dense with validate_indices=False should not raise error
    # (but may produce incorrect results)
    if test_type == "unsorted_indices":
        # With validate_indices=False, unsorted indices are accepted
        # but the behavior is undefined according to TensorFlow docs
        result = sparse_ops.sparse_to_dense(
            sparse_indices=sparse_indices,
            output_shape=output_shape,
            sparse_values=sparse_values,
            default_value=default_value,
            validate_indices=False  # Skip validation
        )
        
        # Verify the operation completed without error
        assert result is not None
        assert result.shape.as_list() == shape
        assert result.dtype == dtype
        
        # Note: The actual values may be incorrect due to unsorted indices,
        # but the operation doesn't crash
    
    # Test 3: SparseTensor creation with invalid indices
    # SparseTensor constructor doesn't validate indices by default
    sparse_tensor = tf.sparse.SparseTensor(
        indices=indices,
        values=values,
        dense_shape=shape
    )
    
    # But operations on invalid SparseTensor may fail
    if test_type == "unsorted_indices":
        # to_dense() on SparseTensor with unsorted indices should work
        # (TensorFlow may reorder internally)
        dense_result = tf.sparse.to_dense(sparse_tensor)
        assert dense_result.shape.as_list() == shape
        assert dense_result.dtype == dtype
    
    # Test 4: Check that valid indices don't raise errors
    if test_type == "unsorted_indices":
        # Create sorted version of indices
        sorted_indices = sorted(indices)  # Sort lexicographically
        sorted_sparse_indices = tf.constant(sorted_indices, dtype=tf.int64)
        
        # This should not raise an error
        valid_result = sparse_ops.sparse_to_dense(
            sparse_indices=sorted_sparse_indices,
            output_shape=output_shape,
            sparse_values=sparse_values,
            default_value=default_value,
            validate_indices=True
        )
        
        assert valid_result is not None
        assert valid_result.shape.as_list() == shape
        assert valid_result.dtype == dtype
    
    # Test 5: Edge case - empty indices (already tested in CASE_04)
    if test_type == "unsorted_indices" and len(indices) == 0:
        # Empty indices are always valid
        empty_indices = tf.constant([], dtype=tf.int64, shape=[0, len(shape)])
        empty_values = tf.constant([], dtype=dtype)
        
        empty_result = sparse_ops.sparse_to_dense(
            sparse_indices=empty_indices,
            output_shape=output_shape,
            sparse_values=empty_values,
            default_value=default_value,
            validate_indices=True
        )
        
        assert empty_result is not None
        assert empty_result.shape.as_list() == shape
        assert empty_result.dtype == dtype
        
        # All values should be default_value
        expected_all_default = np.full(shape, default_value.numpy(), 
                                      dtype=np.float32 if dtype == tf.float32 else np.float64)
        np.testing.assert_allclose(
            empty_result.numpy(),
            expected_all_default,
            rtol=FLOAT_TOLERANCE
        )
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:FOOTER START ====
# Footer block - cleanup and additional helpers

# Additional test utilities that might be useful for future extensions

def generate_random_sparse_tensor(shape, density=0.1, dtype=tf.float32):
    """Generate a random sparse tensor with given shape and density."""
    total_elements = np.prod(shape)
    nnz = max(1, int(total_elements * density))
    
    # Generate random indices
    indices = []
    for _ in range(nnz):
        idx = tuple(np.random.randint(dim) for dim in shape)
        indices.append(idx)
    
    # Remove duplicates
    indices = list(set(indices))
    
    # Generate random values
    if dtype in [tf.float32, tf.float64]:
        values = np.random.randn(len(indices)).astype(np.float32 if dtype == tf.float32 else np.float64)
    elif dtype in [tf.int32, tf.int64]:
        values = np.random.randint(-100, 100, size=len(indices), dtype=np.int32 if dtype == tf.int32 else np.int64)
    else:
        values = np.random.randn(len(indices)).astype(np.float32)
    
    return tf.sparse.SparseTensor(
        indices=indices,
        values=values,
        dense_shape=shape
    )

# Cleanup function if needed
def cleanup_test_resources():
    """Cleanup any test resources if needed."""
    # TensorFlow doesn't require explicit cleanup in eager mode
    pass

# Main execution guard
if __name__ == "__main__":
    # This allows running the tests directly with python
    pytest.main([__file__, "-v"])
# ==== BLOCK:FOOTER END ====