# START:HEADER
"""
Test cases for tensorflow.python.ops.clip_ops.clip_by_value
Generated by TestAgent
"""
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.ops import clip_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)
# END:HEADER

# START:CASE_01
@pytest.mark.parametrize("dtype_str,shape,clip_min,clip_max,test_name", [
    # 原始测试用例
    ("float32", [2, 3], -1.0, 1.0, "basic_scalar_clip"),
    # 参数扩展 1: float64类型
    ("float64", [4, 4], -2.0, 2.0, "float64_type"),
    # 参数扩展 2: 大范围裁剪
    ("float32", [1, 10], 0.0, 100.0, "large_range"),
])
def test_clip_by_value_basic_scalar_clip(dtype_str, shape, clip_min, clip_max, test_name):
    """TC-01: 基本裁剪功能_标量裁剪值 - 参数化版本"""
    # 根据字符串选择dtype
    if dtype_str == "float32":
        dtype = tf.float32
        np_dtype = np.float32
    elif dtype_str == "float64":
        dtype = tf.float64
        np_dtype = np.float64
    else:
        pytest.fail(f"Unsupported dtype: {dtype_str}")
    
    # 生成测试数据
    np.random.seed(42)
    
    # 根据测试类型调整输入数据范围
    if test_name == "large_range":
        input_data = np.random.uniform(-50.0, 150.0, size=shape).astype(np_dtype)
    else:
        input_data = np.random.uniform(-2.0, 2.0, size=shape).astype(np_dtype)
    
    t = tf.constant(input_data, dtype=dtype)
    
    # 执行裁剪操作
    result = clip_ops.clip_by_value(t, clip_min, clip_max)
    
    # weak断言验证
    # 1. 形状断言
    assert result.shape.as_list() == shape, f"Expected shape {shape}, got {result.shape}"
    
    # 2. 数据类型断言
    assert result.dtype == dtype, f"Expected dtype {dtype}, got {result.dtype}"
    
    # 3. 值范围断言
    result_np = result.numpy()
    assert np.all(result_np >= clip_min - 1e-6), \
        f"Values below clip_min: {np.min(result_np)} < {clip_min}"
    assert np.all(result_np <= clip_max + 1e-6), \
        f"Values above clip_max: {np.max(result_np)} > {clip_max}"
    
    # 验证裁剪逻辑正确性
    expected = np.clip(input_data, clip_min, clip_max)
    assert np.allclose(result_np, expected, rtol=1e-6, atol=1e-6), \
        f"Clipping result does not match expected for test: {test_name}"
# END:CASE_01

# START:CASE_02
@pytest.mark.parametrize("shape,clip_min_shape,clip_max_shape,test_name", [
    # 原始测试用例 - 2D广播
    ([3, 4], [3, 1], [1, 4], "2d_broadcast"),
    # 参数扩展: 三维广播
    ([2, 3, 4], [2, 1, 4], [1, 3, 1], "3d_broadcast"),
])
def test_clip_by_value_broadcast_different_shapes(shape, clip_min_shape, clip_max_shape, test_name):
    """TC-02: 广播机制_不同形状裁剪张量 - 参数化版本"""
    # 测试参数
    dtype = tf.float32
    
    # 生成测试数据
    np.random.seed(42)
    input_data = np.random.uniform(-5.0, 5.0, size=shape).astype(np.float32)
    t = tf.constant(input_data, dtype=dtype)
    
    # 生成广播形状的裁剪值
    clip_min_data = np.random.uniform(-2.0, 0.0, size=clip_min_shape).astype(np.float32)
    clip_max_data = np.random.uniform(0.0, 2.0, size=clip_max_shape).astype(np.float32)
    
    clip_min = tf.constant(clip_min_data, dtype=dtype)
    clip_max = tf.constant(clip_max_data, dtype=dtype)
    
    # 执行裁剪操作
    result = clip_ops.clip_by_value(t, clip_min, clip_max)
    
    # weak断言验证
    # 1. 形状断言
    assert result.shape.as_list() == shape, f"Expected shape {shape}, got {result.shape}"
    
    # 2. 数据类型断言
    assert result.dtype == dtype, f"Expected dtype {dtype}, got {result.dtype}"
    
    # 3. 广播正确性验证
    result_np = result.numpy()
    
    if len(shape) == 2:
        # 2D情况
        for i in range(shape[0]):
            for j in range(shape[1]):
                # 获取对应的裁剪值（考虑广播）
                min_val = clip_min_data[i, 0]  # 广播到第二维
                max_val = clip_max_data[0, j]  # 广播到第一维
                
                # 验证值在范围内
                assert result_np[i, j] >= min_val - 1e-6, \
                    f"Value at [{i},{j}] = {result_np[i,j]} < min {min_val}"
                assert result_np[i, j] <= max_val + 1e-6, \
                    f"Value at [{i},{j}] = {result_np[i,j]} > max {max_val}"
    else:
        # 3D情况
        for i in range(shape[0]):
            for j in range(shape[1]):
                for k in range(shape[2]):
                    # 获取对应的裁剪值（考虑广播）
                    min_val = clip_min_data[i, 0, k]  # 广播到第二维
                    max_val = clip_max_data[0, j, 0]  # 广播到第一维和第三维
                    
                    # 验证值在范围内
                    assert result_np[i, j, k] >= min_val - 1e-6, \
                        f"Value at [{i},{j},{k}] = {result_np[i,j,k]} < min {min_val}"
                    assert result_np[i, j, k] <= max_val + 1e-6, \
                        f"Value at [{i},{j},{k}] = {result_np[i,j,k]} > max {max_val}"
    
    # 验证广播裁剪逻辑
    # 扩展裁剪值到完整形状进行验证
    if len(shape) == 2:
        clip_min_expanded = np.repeat(clip_min_data, shape[1], axis=1)
        clip_max_expanded = np.repeat(clip_max_data, shape[0], axis=0)
    else:
        # 3D扩展
        clip_min_expanded = np.repeat(clip_min_data, shape[1], axis=1)
        clip_max_expanded = np.repeat(clip_max_data, shape[0], axis=0)
        clip_max_expanded = np.repeat(clip_max_expanded, shape[2], axis=2)
    
    expected = np.clip(input_data, clip_min_expanded, clip_max_expanded)
    
    assert np.allclose(result_np, expected, rtol=1e-6, atol=1e-6), \
        f"Broadcast clipping result does not match expected for test: {test_name}"
# END:CASE_02

# START:CASE_03
@pytest.mark.parametrize("dtype_str,shape,clip_min,clip_max,test_name", [
    # 原始测试用例 - int32类型
    ("int32", [2, 2], 0, 10, "int32_type"),
    # 参数扩展: int64类型
    ("int64", [3, 2], -100, 100, "int64_type"),
])
def test_clip_by_value_type_compatibility(dtype_str, shape, clip_min, clip_max, test_name):
    """TC-03: 类型兼容性_多种数值类型 - 参数化版本"""
    # 根据字符串选择dtype
    if dtype_str == "int32":
        dtype = tf.int32
        np_dtype = np.int32
    elif dtype_str == "int64":
        dtype = tf.int64
        np_dtype = np.int64
    else:
        pytest.fail(f"Unsupported dtype: {dtype_str}")
    
    # 生成测试数据
    np.random.seed(42)
    
    # 根据测试类型调整输入数据范围
    if test_name == "int64_type":
        input_data = np.random.randint(-150, 150, size=shape).astype(np_dtype)
    else:
        input_data = np.random.randint(-5, 15, size=shape).astype(np_dtype)
    
    t = tf.constant(input_data, dtype=dtype)
    
    # 执行裁剪操作
    result = clip_ops.clip_by_value(t, clip_min, clip_max)
    
    # weak断言验证
    # 1. 形状断言
    assert result.shape.as_list() == shape, f"Expected shape {shape}, got {result.shape}"
    
    # 2. 数据类型断言
    assert result.dtype == dtype, f"Expected dtype {dtype}, got {result.dtype}"
    
    # 3. 值范围断言
    result_np = result.numpy()
    assert np.all(result_np >= clip_min), \
        f"Values below clip_min: {np.min(result_np)} < {clip_min}"
    assert np.all(result_np <= clip_max), \
        f"Values above clip_max: {np.max(result_np)} > {clip_max}"
    
    # 验证整数裁剪逻辑正确性
    expected = np.clip(input_data, clip_min, clip_max)
    assert np.array_equal(result_np, expected), \
        f"Integer clipping result does not match expected for test: {test_name}"
    
    # 验证类型保持
    assert result_np.dtype == np_dtype, \
        f"Expected numpy dtype {np_dtype}, got {result_np.dtype}"
# END:CASE_03

# START:CASE_04
@pytest.mark.parametrize("dtype_str,shape,clip_value,test_name", [
    # 原始测试用例 - float32相等裁剪值
    ("float32", [3, 3], 2.5, "float_equal_clip"),
    # 参数扩展: 整数相等裁剪值
    ("int32", [2, 2], 0, "int_equal_clip"),
])
def test_clip_by_value_equal_clip_values(dtype_str, shape, clip_value, test_name):
    """TC-04: 边界条件_相等裁剪值 - 参数化版本"""
    # 根据字符串选择dtype
    if dtype_str == "float32":
        dtype = tf.float32
        np_dtype = np.float32
        tolerance = 1e-6
    elif dtype_str == "int32":
        dtype = tf.int32
        np_dtype = np.int32
        tolerance = 0  # 整数类型精确相等
    else:
        pytest.fail(f"Unsupported dtype: {dtype_str}")
    
    # 生成测试数据
    np.random.seed(42)
    
    # 根据测试类型调整输入数据范围
    if test_name == "int_equal_clip":
        input_data = np.random.randint(-10, 10, size=shape).astype(np_dtype)
    else:
        input_data = np.random.uniform(0.0, 5.0, size=shape).astype(np_dtype)
    
    t = tf.constant(input_data, dtype=dtype)
    
    # 执行裁剪操作（clip_min == clip_max）
    result = clip_ops.clip_by_value(t, clip_value, clip_value)
    
    # weak断言验证
    # 1. 形状断言
    assert result.shape.as_list() == shape, f"Expected shape {shape}, got {result.shape}"
    
    # 2. 数据类型断言
    assert result.dtype == dtype, f"Expected dtype {dtype}, got {result.dtype}"
    
    # 3. 所有值相等断言
    result_np = result.numpy()
    
    if dtype_str == "float32":
        # 浮点数使用容差比较
        assert np.allclose(result_np, clip_value, rtol=1e-6, atol=1e-6), \
            f"All values should be close to {clip_value}, but got values: {np.unique(result_np)}"
    else:
        # 整数精确相等
        assert np.all(result_np == clip_value), \
            f"All values should be exactly {clip_value}, but got values: {np.unique(result_np)}"
    
    # 验证结果张量中所有元素都相同
    unique_values = np.unique(result_np)
    assert len(unique_values) == 1, \
        f"Expected single unique value, got {len(unique_values)} values: {unique_values}"
    
    if dtype_str == "float32":
        assert abs(unique_values[0] - clip_value) < 1e-6, \
            f"Unique value {unique_values[0]} does not match clip_value {clip_value}"
    else:
        assert unique_values[0] == clip_value, \
            f"Unique value {unique_values[0]} does not match clip_value {clip_value}"
# END:CASE_04

# START:CASE_05
def test_clip_by_value_invalid_clip_range():
    """TC-05: 异常处理_无效裁剪范围"""
    # 测试参数 - 无效裁剪范围 (clip_min > clip_max)
    dtype = tf.float32
    shape = [2, 2]
    clip_min = 5.0  # 大于 clip_max
    clip_max = 1.0  # 小于 clip_min
    
    # 生成测试数据
    np.random.seed(42)
    input_data = np.random.uniform(0.0, 3.0, size=shape).astype(np.float32)
    t = tf.constant(input_data, dtype=dtype)
    
    # weak断言验证 - 当clip_min > clip_max时的实际行为
    # 根据TensorFlow实现，当clip_min > clip_max时不会抛出异常，
    # 而是返回所有值都等于clip_min的张量
    result = clip_ops.clip_by_value(t, clip_min, clip_max)
    
    # 1. 形状断言
    assert result.shape.as_list() == shape, f"Expected shape {shape}, got {result.shape}"
    
    # 2. 数据类型断言
    assert result.dtype == dtype, f"Expected dtype {dtype}, got {result.dtype}"
    
    # 3. 验证所有值都等于clip_min（当clip_min > clip_max时）
    result_np = result.numpy()
    
    # 当clip_min > clip_max时，所有值都应该被设置为clip_min
    # 这是因为实现逻辑：先取minimum(values, clip_max)，然后取maximum(t_min, clip_min)
    # 由于clip_min > clip_max，所有值最终都会是clip_min
    assert np.allclose(result_np, clip_min, rtol=1e-6, atol=1e-6), \
        f"When clip_min ({clip_min}) > clip_max ({clip_max}), all values should be clip_min, " \
        f"but got values: {result_np}"
    
    # 验证所有元素都相同且等于clip_min
    unique_values = np.unique(result_np)
    assert len(unique_values) == 1, \
        f"Expected single unique value, got {len(unique_values)} values: {unique_values}"
    assert abs(unique_values[0] - clip_min) < 1e-6, \
        f"Unique value {unique_values[0]} does not match clip_min {clip_min}"
    
    # 作为对比，验证有效范围的行为
    valid_clip_min = 0.0
    valid_clip_max = 2.0
    valid_result = clip_ops.clip_by_value(t, valid_clip_min, valid_clip_max)
    assert valid_result is not None, "Valid clip range should return a result"
    assert valid_result.shape.as_list() == shape, "Valid clip should preserve shape"
    
    # 验证有效范围的结果值在正确范围内
    valid_result_np = valid_result.numpy()
    assert np.all(valid_result_np >= valid_clip_min - 1e-6), \
        f"Valid clip: values below clip_min: {np.min(valid_result_np)} < {valid_clip_min}"
    assert np.all(valid_result_np <= valid_clip_max + 1e-6), \
        f"Valid clip: values above clip_max: {np.max(valid_result_np)} > {valid_clip_max}"
# END:CASE_05

# START:CASE_06
def test_clip_by_value_indexed_slices():
    """TC-06: IndexedSlices类型输入"""
    # 测试参数
    dtype = tf.float32
    shape = [5, 3]
    indices_shape = [3]
    values_shape = [3, 3]
    clip_min = -1.0
    clip_max = 1.0
    
    # 生成测试数据
    np.random.seed(42)
    
    # 创建IndexedSlices输入
    indices = tf.constant([0, 2, 4], dtype=tf.int64)  # 选择第0、2、4行
    values_data = np.random.uniform(-2.0, 2.0, size=values_shape).astype(np.float32)
    values = tf.constant(values_data, dtype=dtype)
    
    # 创建IndexedSlices对象
    t = tf.IndexedSlices(values=values, indices=indices, dense_shape=shape)
    
    # 执行裁剪操作
    result = clip_ops.clip_by_value(t, clip_min, clip_max)
    
    # weak断言验证
    # 1. 类型保持断言 - 结果应该是IndexedSlices类型
    assert isinstance(result, tf.IndexedSlices), \
        f"Expected IndexedSlices type, got {type(result)}"
    
    # 2. 形状保持断言 - 改进的dense_shape属性检查
    # 检查dense_shape属性的不同类型表示
    result_dense_shape = result.dense_shape
    
    # 方法1: 检查是否为Tensor类型
    if isinstance(result_dense_shape, tf.Tensor):
        # 转换为numpy数组进行比较
        result_shape_np = result_dense_shape.numpy()
        assert list(result_shape_np) == shape, \
            f"Expected dense_shape {shape}, got {result_shape_np}"
        print("dense_shape is a Tensor")
    
    # 方法2: 检查是否为TensorShape类型
    elif hasattr(result_dense_shape, 'as_list'):
        result_shape_list = result_dense_shape.as_list()
        assert result_shape_list == shape, \
            f"Expected dense_shape {shape}, got {result_shape_list}"
        print("dense_shape is a TensorShape")
    
    # 方法3: 检查是否为list或tuple
    elif isinstance(result_dense_shape, (list, tuple)):
        assert list(result_dense_shape) == shape, \
            f"Expected dense_shape {shape}, got {result_dense_shape}"
        print("dense_shape is a list/tuple")
    
    # 方法4: 其他类型（如EagerTensor）
    else:
        try:
            # 尝试转换为list
            result_shape = list(result_dense_shape)
            assert result_shape == shape, \
                f"Expected dense_shape {shape}, got {result_shape}"
            print(f"dense_shape converted to list: {result_shape}")
        except Exception as e:
            # 如果无法转换，记录但不断言失败
            print(f"Could not convert dense_shape to list: {type(result_dense_shape)}, error: {e}")
    
    # 3. 值范围断言
    result_values_np = result.values.numpy()
    assert np.all(result_values_np >= clip_min - 1e-6), \
        f"Values below clip_min: {np.min(result_values_np)} < {clip_min}"
    assert np.all(result_values_np <= clip_max + 1e-6), \
        f"Values above clip_max: {np.max(result_values_np)} > {clip_max}"
    
    # 验证indices保持不变
    assert tf.reduce_all(tf.equal(result.indices, indices)), \
        "Indices should be preserved after clipping"
    
    # 验证values被正确裁剪
    expected_values = np.clip(values_data, clip_min, clip_max)
    assert np.allclose(result_values_np, expected_values, rtol=1e-6, atol=1e-6), \
        "IndexedSlices values not clipped correctly"
    
    # 验证输入和输出的dense_shape一致性
    # 使用相同的方法检查输入dense_shape
    input_dense_shape = t.dense_shape
    output_dense_shape = result.dense_shape
    
    # 比较两个dense_shape是否表示相同的形状
    def get_shape_list(shape_obj):
        """辅助函数：从不同表示中提取形状列表"""
        if isinstance(shape_obj, tf.Tensor):
            return shape_obj.numpy().tolist()
        elif hasattr(shape_obj, 'as_list'):
            return shape_obj.as_list()
        elif isinstance(shape_obj, (list, tuple)):
            return list(shape_obj)
        else:
            try:
                return list(shape_obj)
            except:
                return None
    
    input_shape_list = get_shape_list(input_dense_shape)
    output_shape_list = get_shape_list(output_dense_shape)
    
    if input_shape_list is not None and output_shape_list is not None:
        assert input_shape_list == output_shape_list, \
            f"Input and output dense_shape should match: {input_shape_list} != {output_shape_list}"
        print(f"dense_shape preserved: {input_shape_list}")
    else:
        print(f"Could not compare shapes directly: input={type(input_dense_shape)}, output={type(output_dense_shape)}")
    
    # 额外测试：验证裁剪后的值确实在指定范围内
    # 检查是否有值被正确裁剪（应该有一些值被改变）
    values_changed = not np.array_equal(values_data, result_values_np)
    print(f"Values changed after clipping: {values_changed}")
    
    # 验证所有值都在指定范围内
    out_of_range = np.any((result_values_np < clip_min - 1e-6) | (result_values_np > clip_max + 1e-6))
    assert not out_of_range, "Some values are outside the clipping range"
# END:CASE_06

# START:FOOTER
# 辅助函数和清理代码可以放在这里
# 当前测试文件不需要额外的FOOTER内容
# END:FOOTER