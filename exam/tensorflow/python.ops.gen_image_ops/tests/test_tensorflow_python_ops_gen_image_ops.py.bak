"""
Test module for tensorflow.python.ops.gen_image_ops
Generated by ATTest
"""

import math
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.ops import gen_image_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# ==== BLOCK:HEADER START ====
"""
Test module for tensorflow.python.ops.gen_image_ops
Generated by ATTest
"""

import math
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.ops import gen_image_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)


def create_test_image(shape, dtype=np.float32, value_range=(0.0, 1.0)):
    """Create a test image tensor with random values."""
    low, high = value_range
    if dtype == np.uint8:
        data = np.random.randint(low=0, high=256, size=shape, dtype=np.uint8)
    else:
        data = np.random.uniform(low=low, high=high, size=shape).astype(dtype)
    return tf.constant(data, dtype=dtype)


def create_jpeg_bytes(width=32, height=32, channels=3):
    """Create a simple JPEG image in bytes format."""
    # Create a simple RGB image
    image = np.random.randint(0, 256, size=(height, width, channels), dtype=np.uint8)
    
    # Encode to JPEG using TensorFlow
    image_tensor = tf.constant(image)
    jpeg_bytes = tf.io.encode_jpeg(image_tensor, quality=95)
    
    return jpeg_bytes.numpy()


def create_test_boxes(num_boxes=10, dtype=np.float32):
    """Create test bounding boxes in [y1, x1, y2, x2] format."""
    boxes = np.random.uniform(0.0, 1.0, size=(num_boxes, 4)).astype(dtype)
    # Ensure y2 > y1 and x2 > x1
    for i in range(num_boxes):
        if boxes[i, 2] <= boxes[i, 0]:
            boxes[i, 2] = boxes[i, 0] + 0.1
        if boxes[i, 3] <= boxes[i, 1]:
            boxes[i, 3] = boxes[i, 1] + 0.1
    return tf.constant(boxes, dtype=dtype)


def create_test_scores(num_scores=10, dtype=np.float32):
    """Create test scores for bounding boxes."""
    scores = np.random.uniform(0.0, 1.0, size=num_scores).astype(dtype)
    return tf.constant(scores, dtype=dtype)


@pytest.fixture
def cleanup_tf_graph():
    """Clean up TensorFlow graph after each test."""
    yield
    tf.compat.v1.reset_default_graph()
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
@pytest.mark.parametrize(
    "channels,fancy_upscaling,try_recover_truncated,acceptable_fraction,dct_method",
    [
        # Base case from test plan
        (3, True, False, 1.0, ""),
        # Parameter extension for grayscale
        (1, False, True, 0.5, "INTEGER_FAST"),
    ]
)
def test_decode_jpeg_basic(
    channels,
    fancy_upscaling,
    try_recover_truncated,
    acceptable_fraction,
    dct_method,
    cleanup_tf_graph
):
    """Test decode_jpeg basic decoding functionality."""
    # Create a JPEG image
    jpeg_bytes = create_jpeg_bytes(width=32, height=32, channels=3)
    
    # Decode using TensorFlow
    decoded = gen_image_ops.decode_jpeg(
        contents=jpeg_bytes,
        channels=channels,
        fancy_upscaling=fancy_upscaling,
        try_recover_truncated=try_recover_truncated,
        acceptable_fraction=acceptable_fraction,
        dct_method=dct_method
    )
    
    # Weak assertions (shape, dtype, value_range, basic_property)
    # 1. Check shape
    assert decoded.shape.rank == 3, "Decoded image should be 3D"
    height, width, decoded_channels = decoded.shape
    assert height == 32, f"Expected height 32, got {height}"
    assert width == 32, f"Expected width 32, got {width}"
    assert decoded_channels == channels, f"Expected {channels} channels, got {decoded_channels}"
    
    # 2. Check dtype
    assert decoded.dtype == tf.uint8, f"Expected uint8 dtype, got {decoded.dtype}"
    
    # 3. Check value range
    decoded_np = decoded.numpy()
    assert decoded_np.min() >= 0, "Pixel values should be >= 0"
    assert decoded_np.max() <= 255, "Pixel values should be <= 255"
    
    # 4. Check basic properties
    assert tf.math.reduce_all(tf.math.is_finite(tf.cast(decoded, tf.float32))), "All pixel values should be finite"
    
    # Additional basic checks
    # Convert to float before computing std to avoid uint8 overflow issues
    decoded_float = tf.cast(decoded, tf.float32)
    assert tf.math.reduce_std(decoded_float) > 0, "Image should have some variation"
    
    print(f"decode_jpeg test passed with channels={channels}, "
          f"fancy_upscaling={fancy_upscaling}, "
          f"try_recover_truncated={try_recover_truncated}")
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
@pytest.mark.parametrize(
    "input_shape,output_shape,dtype,align_corners,half_pixel_centers",
    [
        # Base case from test plan
        ([1, 32, 32, 3], [1, 64, 64, 3], tf.float32, False, False),
        # Parameter extension for downscaling - fix invalid combination
        # When half_pixel_centers=True, align_corners must be False
        ([2, 16, 16, 1], [2, 8, 8, 1], tf.float32, False, True),
    ]
)
def test_resize_bilinear_size_adjustment(
    input_shape,
    output_shape,
    dtype,
    align_corners,
    half_pixel_centers,
    cleanup_tf_graph
):
    """Test resize_bilinear image resizing functionality."""
    # Create input image
    batch, in_height, in_width, channels = input_shape
    out_batch, out_height, out_width, out_channels = output_shape
    
    # Ensure batch and channels match
    assert batch == out_batch, "Batch size should match"
    assert channels == out_channels, "Number of channels should match"
    
    # Create test image
    image = create_test_image(input_shape, dtype=dtype.as_numpy_dtype)
    
    # Get size tensor
    size = tf.constant([out_height, out_width], dtype=tf.int32)
    
    # Resize using TensorFlow
    resized = gen_image_ops.resize_bilinear(
        images=image,
        size=size,
        align_corners=align_corners,
        half_pixel_centers=half_pixel_centers
    )
    
    # Weak assertions (shape, dtype, finite, value_range)
    # 1. Check shape
    assert resized.shape == tuple(output_shape), f"Expected shape {output_shape}, got {resized.shape}"
    
    # 2. Check dtype
    assert resized.dtype == dtype, f"Expected dtype {dtype}, got {resized.dtype}"
    
    # 3. Check finite values
    resized_np = resized.numpy()
    assert np.all(np.isfinite(resized_np)), "All values should be finite"
    
    # 4. Check value range (preserve input range)
    input_min = tf.reduce_min(image).numpy()
    input_max = tf.reduce_max(image).numpy()
    output_min = tf.reduce_min(resized).numpy()
    output_max = tf.reduce_max(resized).numpy()
    
    # Resizing should preserve value range approximately
    tolerance = 1e-5 if dtype == tf.float32 else 1e-10
    assert abs(output_min - input_min) < tolerance or output_min >= input_min, \
        f"Output min {output_min} should be >= input min {input_min}"
    assert abs(output_max - input_max) < tolerance or output_max <= input_max, \
        f"Output max {output_max} should be <= input max {input_max}"
    
    # Additional basic checks
    # Check that output is not all zeros (unless input is all zeros)
    if tf.reduce_sum(tf.abs(image)) > 0:
        assert tf.reduce_sum(tf.abs(resized)) > 0, "Resized image should not be all zeros"
    
    print(f"resize_bilinear test passed: {input_shape} -> {output_shape}, "
          f"dtype={dtype}, align_corners={align_corners}, "
          f"half_pixel_centers={half_pixel_centers}")
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_03 START ====
@pytest.mark.parametrize(
    "boxes_shape,scores_shape,max_output_size,iou_threshold,score_threshold,dtype",
    [
        # Base case from test plan
        ([10, 4], [10], 5, 0.5, 0.0, tf.float32),
        # Parameter extension for larger scale - use float32 instead of float64
        ([50, 4], [50], 10, 0.7, 0.3, tf.float32),
    ]
)
def test_non_max_suppression_bbox_suppression(
    boxes_shape,
    scores_shape,
    max_output_size,
    iou_threshold,
    score_threshold,
    dtype,
    cleanup_tf_graph
):
    """Test non_max_suppression bounding box suppression functionality."""
    num_boxes = boxes_shape[0]
    
    # Create test boxes and scores
    boxes = create_test_boxes(num_boxes=num_boxes, dtype=dtype.as_numpy_dtype)
    scores = create_test_scores(num_scores=num_boxes, dtype=dtype.as_numpy_dtype)
    
    # Apply non-max suppression using TensorFlow
    # Note: Using NonMaxSuppressionV3 which supports score_threshold
    selected_indices = gen_image_ops.non_max_suppression_v3(
        boxes=boxes,
        scores=scores,
        max_output_size=max_output_size,
        iou_threshold=iou_threshold,
        score_threshold=score_threshold
    )
    
    # Weak assertions (shape, dtype, value_range, basic_property)
    # 1. Check shape
    assert selected_indices.shape.rank == 1, "Selected indices should be 1D"
    num_selected = selected_indices.shape[0]
    assert num_selected <= max_output_size, f"Should select at most {max_output_size} boxes, got {num_selected}"
    
    # 2. Check dtype
    assert selected_indices.dtype == tf.int32, f"Expected int32 dtype, got {selected_indices.dtype}"
    
    # 3. Check value range
    selected_np = selected_indices.numpy()
    if len(selected_np) > 0:
        assert selected_np.min() >= 0, "Indices should be >= 0"
        assert selected_np.max() < num_boxes, f"Indices should be < {num_boxes}"
    
    # 4. Check basic properties
    # Check indices are unique
    unique_indices = np.unique(selected_np)
    assert len(unique_indices) == len(selected_np), "Indices should be unique"
    
    # Note: non_max_suppression does NOT guarantee sorted indices
    # Remove the assertion that indices are sorted
    
    # Check that selected boxes have scores above threshold
    if len(selected_np) > 0:
        selected_scores = tf.gather(scores, selected_indices).numpy()
        assert np.all(selected_scores >= score_threshold - 1e-7), \
            f"Selected boxes should have scores >= {score_threshold}"
    
    # Additional basic checks
    # Check that we didn't select more boxes than available
    assert num_selected <= num_boxes, f"Cannot select more boxes than available: {num_selected} > {num_boxes}"
    
    print(f"non_max_suppression test passed: {num_boxes} boxes, "
          f"max_output={max_output_size}, iou_threshold={iou_threshold}, "
          f"score_threshold={score_threshold}, selected={num_selected} boxes")
# ==== BLOCK:CASE_03 END ====

# ==== BLOCK:CASE_04 START ====
@pytest.mark.parametrize(
    "input_shape,dtype,contrast_factor",
    [
        # Base case from test plan
        ([1, 32, 32, 3], tf.float32, 2.0),
        # Parameter extension for batch processing - use float32 instead of float64
        ([4, 16, 16, 1], tf.float32, 0.5),
    ]
)
def test_adjust_contrastv2_contrast_adjustment(
    input_shape,
    dtype,
    contrast_factor,
    cleanup_tf_graph
):
    """Test adjust_contrastv2 image contrast adjustment functionality."""
    # Create test image
    image = create_test_image(input_shape, dtype=dtype.as_numpy_dtype, value_range=(0.1, 0.9))
    
    # Apply contrast adjustment using TensorFlow
    adjusted = gen_image_ops.adjust_contrastv2(
        images=image,
        contrast_factor=contrast_factor
    )
    
    # Weak assertions (shape, dtype, finite, value_range)
    # 1. Check shape
    assert adjusted.shape == tuple(input_shape), f"Expected shape {input_shape}, got {adjusted.shape}"
    
    # 2. Check dtype
    assert adjusted.dtype == dtype, f"Expected dtype {dtype}, got {adjusted.dtype}"
    
    # 3. Check finite values
    adjusted_np = adjusted.numpy()
    assert np.all(np.isfinite(adjusted_np)), "All values should be finite"
    
    # 4. Check value range
    # For contrast adjustment, output range depends on input and contrast factor
    # But values should still be finite and reasonable
    
    # Additional basic checks
    # Check that operation is not identity (unless contrast_factor == 1.0)
    if abs(contrast_factor - 1.0) > 1e-7:
        diff = tf.reduce_mean(tf.abs(adjusted - image)).numpy()
        assert diff > 1e-7, f"Contrast adjustment should change image when factor={contrast_factor}"
    
    # Check basic contrast adjustment properties
    # When contrast_factor > 1, variance should increase
    # When contrast_factor < 1, variance should decrease
    input_var = tf.math.reduce_variance(image).numpy()
    output_var = tf.math.reduce_variance(adjusted).numpy()
    
    if contrast_factor > 1.0:
        # Variance should increase or stay same
        assert output_var >= input_var - 1e-7, \
            f"Variance should increase when contrast_factor={contrast_factor} > 1"
    elif contrast_factor < 1.0:
        # Variance should decrease or stay same
        assert output_var <= input_var + 1e-7, \
            f"Variance should decrease when contrast_factor={contrast_factor} < 1"
    
    # Check that mean is preserved (contrast adjustment preserves mean)
    input_mean = tf.reduce_mean(image).numpy()
    output_mean = tf.reduce_mean(adjusted).numpy()
    tolerance = 1e-5 if dtype == tf.float32 else 1e-10
    assert abs(output_mean - input_mean) < tolerance, \
        f"Mean should be preserved: input={input_mean}, output={output_mean}"
    
    print(f"adjust_contrastv2 test passed: shape={input_shape}, "
          f"dtype={dtype}, contrast_factor={contrast_factor}, "
          f"input_var={input_var:.6f}, output_var={output_var:.6f}")
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
@pytest.mark.parametrize(
    "input_shape,boxes,box_indices,crop_size,method,extrapolation_value,dtype",
    [
        # Base case from test plan
        (
            [1, 64, 64, 3],
            [[0.25, 0.25, 0.75, 0.75]],
            [0],
            [32, 32],
            "bilinear",
            0.0,
            tf.float32
        ),
        # Parameter extension for multiple boxes - use float32 instead of float64
        (
            [3, 48, 48, 1],
            [[0.1, 0.1, 0.9, 0.9], [0.2, 0.2, 0.8, 0.8]],
            [0, 1],
            [24, 24],
            "nearest",
            0.5,
            tf.float32
        ),
    ]
)
def test_crop_and_resize_cropping_adjustment(
    input_shape,
    boxes,
    box_indices,
    crop_size,
    method,
    extrapolation_value,
    dtype,
    cleanup_tf_graph
):
    """Test crop_and_resize image cropping and resizing functionality."""
    batch, height, width, channels = input_shape
    crop_height, crop_width = crop_size
    num_boxes = len(boxes)
    
    # Create test image
    image = create_test_image(input_shape, dtype=dtype.as_numpy_dtype)
    
    # Convert boxes and indices to tensors
    boxes_tensor = tf.constant(boxes, dtype=dtype)
    box_indices_tensor = tf.constant(box_indices, dtype=tf.int32)
    crop_size_tensor = tf.constant(crop_size, dtype=tf.int32)
    
    # Apply crop and resize using TensorFlow
    cropped = gen_image_ops.crop_and_resize(
        image=image,
        boxes=boxes_tensor,
        box_ind=box_indices_tensor,
        crop_size=crop_size_tensor,
        method=method,
        extrapolation_value=extrapolation_value
    )
    
    # Weak assertions (shape, dtype, finite, value_range)
    # 1. Check shape
    expected_shape = (num_boxes, crop_height, crop_width, channels)
    assert cropped.shape == expected_shape, f"Expected shape {expected_shape}, got {cropped.shape}"
    
    # 2. Check dtype
    assert cropped.dtype == dtype, f"Expected dtype {dtype}, got {cropped.dtype}"
    
    # 3. Check finite values
    cropped_np = cropped.numpy()
    assert np.all(np.isfinite(cropped_np)), "All values should be finite"
    
    # 4. Check value range
    # For crop_and_resize with extrapolation, values might be outside input range
    # But should still be finite
    
    # Additional basic checks
    # Check that output is not all the same value (unless input is constant)
    # Use tf.math.reduce_std instead of tf.reduce_std
    if tf.math.reduce_std(image) > 1e-7:
        # Check each cropped region has some variation
        for i in range(num_boxes):
            crop_slice = cropped[i]
            if tf.math.reduce_std(crop_slice) < 1e-7:
                # If crop has low variation, check if it's due to extrapolation
                # or if the cropped region in original image was also constant
                pass
    
    # Check that box indices are valid
    assert tf.reduce_all(box_indices_tensor >= 0), "Box indices should be >= 0"
    assert tf.reduce_all(box_indices_tensor < batch), f"Box indices should be < batch size {batch}"
    
    # Check boxes are valid (y1 < y2, x1 < x2, all in [0, 1])
    boxes_np = boxes_tensor.numpy()
    for i in range(num_boxes):
        y1, x1, y2, x2 = boxes_np[i]
        assert 0.0 <= y1 <= 1.0, f"Box {i}: y1={y1} should be in [0, 1]"
        assert 0.0 <= x1 <= 1.0, f"Box {i}: x1={x1} should be in [0, 1]"
        assert 0.0 <= y2 <= 1.0, f"Box {i}: y2={y2} should be in [0, 1]"
        assert 0.0 <= x2 <= 1.0, f"Box {i}: x2={x2} should be in [0, 1]"
        assert y1 < y2, f"Box {i}: y1={y1} should be < y2={y2}"
        assert x1 < x2, f"Box {i}: x1={x1} should be < x2={x2}"
    
    print(f"crop_and_resize test passed: input_shape={input_shape}, "
          f"num_boxes={num_boxes}, crop_size={crop_size}, "
          f"method={method}, dtype={dtype}")
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:CASE_06 START ====
@pytest.mark.parametrize(
    "input_shape,dtype",
    [
        # Test single image
        ([32, 32, 3], tf.float32),
        # Test batch of images
        ([4, 16, 16, 3], tf.float32),
        # Test with float64
        ([1, 8, 8, 3], tf.float64),
    ]
)
def test_rgb_hsv_color_space_conversion(
    input_shape,
    dtype,
    cleanup_tf_graph
):
    """Test RGB to HSV and HSV to RGB color space conversion functionality."""
    # Create test RGB image with values in [0, 1] range
    # RGB values must be in [0, 1] for proper HSV conversion
    rgb_image = create_test_image(input_shape, dtype=dtype.as_numpy_dtype, value_range=(0.1, 0.9))
    
    # Convert RGB to HSV
    hsv_image = gen_image_ops.rgb_to_hsv(images=rgb_image)
    
    # Weak assertions for RGB to HSV conversion
    # 1. Check shape
    assert hsv_image.shape == tuple(input_shape), f"Expected shape {input_shape}, got {hsv_image.shape}"
    
    # 2. Check dtype
    assert hsv_image.dtype == dtype, f"Expected dtype {dtype}, got {hsv_image.dtype}"
    
    # 3. Check finite values
    hsv_np = hsv_image.numpy()
    assert np.all(np.isfinite(hsv_np)), "All HSV values should be finite"
    
    # 4. Check value range (HSV values should be in [0, 1])
    hsv_min = tf.reduce_min(hsv_image).numpy()
    hsv_max = tf.reduce_max(hsv_image).numpy()
    assert hsv_min >= 0.0 - 1e-7, f"HSV values should be >= 0, got min={hsv_min}"
    assert hsv_max <= 1.0 + 1e-7, f"HSV values should be <= 1, got max={hsv_max}"
    
    # Additional checks for HSV components
    # Hue (channel 0) should be in [0, 1)
    hue = hsv_image[..., 0]
    hue_min = tf.reduce_min(hue).numpy()
    hue_max = tf.reduce_max(hue).numpy()
    assert hue_min >= 0.0 - 1e-7, f"Hue should be >= 0, got min={hue_min}"
    assert hue_max <= 1.0 + 1e-7, f"Hue should be <= 1, got max={hue_max}"
    
    # Saturation (channel 1) should be in [0, 1]
    saturation = hsv_image[..., 1]
    sat_min = tf.reduce_min(saturation).numpy()
    sat_max = tf.reduce_max(saturation).numpy()
    assert sat_min >= 0.0 - 1e-7, f"Saturation should be >= 0, got min={sat_min}"
    assert sat_max <= 1.0 + 1e-7, f"Saturation should be <= 1, got max={sat_max}"
    
    # Value (channel 2) should be in [0, 1]
    value = hsv_image[..., 2]
    val_min = tf.reduce_min(value).numpy()
    val_max = tf.reduce_max(value).numpy()
    assert val_min >= 0.0 - 1e-7, f"Value should be >= 0, got min={val_min}"
    assert val_max <= 1.0 + 1e-7, f"Value should be <= 1, got max={val_max}"
    
    # Now convert HSV back to RGB
    rgb_reconstructed = gen_image_ops.hsv_to_rgb(images=hsv_image)
    
    # Weak assertions for HSV to RGB conversion
    # 1. Check shape
    assert rgb_reconstructed.shape == tuple(input_shape), f"Expected shape {input_shape}, got {rgb_reconstructed.shape}"
    
    # 2. Check dtype
    assert rgb_reconstructed.dtype == dtype, f"Expected dtype {dtype}, got {rgb_reconstructed.dtype}"
    
    # 3. Check finite values
    rgb_recon_np = rgb_reconstructed.numpy()
    assert np.all(np.isfinite(rgb_recon_np)), "All reconstructed RGB values should be finite"
    
    # 4. Check value range (RGB values should be in [0, 1])
    rgb_recon_min = tf.reduce_min(rgb_reconstructed).numpy()
    rgb_recon_max = tf.reduce_max(rgb_reconstructed).numpy()
    assert rgb_recon_min >= 0.0 - 1e-7, f"Reconstructed RGB should be >= 0, got min={rgb_recon_min}"
    assert rgb_recon_max <= 1.0 + 1e-7, f"Reconstructed RGB should be <= 1, got max={rgb_recon_max}"
    
    # Check that RGB -> HSV -> RGB conversion is approximately invertible
    # Due to floating point precision and HSV representation, there might be small differences
    tolerance = 1e-5 if dtype == tf.float32 else 1e-10
    diff = tf.reduce_max(tf.abs(rgb_reconstructed - rgb_image)).numpy()
    assert diff < tolerance, f"RGB->HSV->RGB conversion should be invertible, max diff={diff}"
    
    # Check specific color conversions
    # Test pure red: RGB = [1, 0, 0] -> HSV ≈ [0, 1, 1]
    pure_red = tf.constant([[[1.0, 0.0, 0.0]]], dtype=dtype)
    red_hsv = gen_image_ops.rgb_to_hsv(images=pure_red)
    # Hue should be close to 0 for red
    red_hue = red_hsv[0, 0, 0].numpy()
    assert abs(red_hue) < 0.01 or abs(red_hue - 1.0) < 0.01, f"Red hue should be close to 0 or 1, got {red_hue}"
    # Saturation should be 1
    red_sat = red_hsv[0, 0, 1].numpy()
    assert abs(red_sat - 1.0) < 1e-5, f"Red saturation should be 1, got {red_sat}"
    # Value should be 1
    red_val = red_hsv[0, 0, 2].numpy()
    assert abs(red_val - 1.0) < 1e-5, f"Red value should be 1, got {red_val}"
    
    # Test pure green: RGB = [0, 1, 0] -> HSV ≈ [1/3, 1, 1]
    pure_green = tf.constant([[[0.0, 1.0, 0.0]]], dtype=dtype)
    green_hsv = gen_image_ops.rgb_to_hsv(images=pure_green)
    # Hue should be close to 1/3 for green
    green_hue = green_hsv[0, 0, 0].numpy()
    assert abs(green_hue - 1.0/3.0) < 0.01, f"Green hue should be close to 1/3, got {green_hue}"
    
    # Test pure blue: RGB = [0, 0, 1] -> HSV ≈ [2/3, 1, 1]
    pure_blue = tf.constant([[[0.0, 0.0, 1.0]]], dtype=dtype)
    blue_hsv = gen_image_ops.rgb_to_hsv(images=pure_blue)
    # Hue should be close to 2/3 for blue
    blue_hue = blue_hsv[0, 0, 0].numpy()
    assert abs(blue_hue - 2.0/3.0) < 0.01, f"Blue hue should be close to 2/3, got {blue_hue}"
    
    print(f"RGB/HSV color space conversion test passed: shape={input_shape}, "
          f"dtype={dtype}, max_diff={diff:.6f}")
# ==== BLOCK:CASE_06 END ====

# ==== BLOCK:CASE_07 START ====
@pytest.mark.parametrize(
    "input_shape,dtype,delta,scale",
    [
        # Test hue adjustment with small delta
        ([1, 32, 32, 3], tf.float32, 0.1, 1.0),
        # Test saturation adjustment
        ([1, 32, 32, 3], tf.float32, 0.0, 1.5),
        # Test both hue and saturation adjustments
        ([4, 16, 16, 3], tf.float32, -0.2, 0.8),
        # Test with half precision
        ([1, 8, 8, 3], tf.float16, 0.05, 1.2),
    ]
)
def test_adjust_hue_saturation_color_adjustment(
    input_shape,
    dtype,
    delta,
    scale,
    cleanup_tf_graph
):
    """Test adjust_hue and adjust_saturation color adjustment functionality."""
    # Create test RGB image with values in [0, 1] range
    # RGB values must be in [0, 1] for proper HSV conversion
    rgb_image = create_test_image(input_shape, dtype=dtype.as_numpy_dtype, value_range=(0.1, 0.9))
    
    # Test hue adjustment if delta != 0
    if abs(delta) > 1e-7:
        # Adjust hue
        hue_adjusted = gen_image_ops.adjust_hue(
            images=rgb_image,
            delta=tf.constant(delta, dtype=tf.float32)
        )
        
        # Weak assertions for hue adjustment
        # 1. Check shape
        assert hue_adjusted.shape == tuple(input_shape), f"Expected shape {input_shape}, got {hue_adjusted.shape}"
        
        # 2. Check dtype
        assert hue_adjusted.dtype == dtype, f"Expected dtype {dtype}, got {hue_adjusted.dtype}"
        
        # 3. Check finite values
        hue_adj_np = hue_adjusted.numpy()
        assert np.all(np.isfinite(hue_adj_np)), "All hue-adjusted values should be finite"
        
        # 4. Check value range (RGB values should be in [0, 1])
        hue_adj_min = tf.reduce_min(hue_adjusted).numpy()
        hue_adj_max = tf.reduce_max(hue_adjusted).numpy()
        assert hue_adj_min >= 0.0 - 1e-5, f"Hue-adjusted RGB should be >= 0, got min={hue_adj_min}"
        assert hue_adj_max <= 1.0 + 1e-5, f"Hue-adjusted RGB should be <= 1, got max={hue_adj_max}"
        
        # Additional checks for hue adjustment
        # Hue adjustment should preserve luminance (brightness) approximately
        # Convert to grayscale using standard weights: 0.299*R + 0.587*G + 0.114*B
        weights = tf.constant([0.299, 0.587, 0.114], dtype=dtype)
        orig_luminance = tf.reduce_sum(rgb_image * weights, axis=-1)
        hue_adj_luminance = tf.reduce_sum(hue_adjusted * weights, axis=-1)
        
        luminance_diff = tf.reduce_max(tf.abs(orig_luminance - hue_adj_luminance)).numpy()
        tolerance = 0.01 if dtype == tf.float16 else 0.001
        assert luminance_diff < tolerance, f"Hue adjustment should preserve luminance, diff={luminance_diff}"
        
        # Check that hue adjustment actually changes the image (unless delta is 0)
        diff = tf.reduce_max(tf.abs(hue_adjusted - rgb_image)).numpy()
        assert diff > 1e-5, f"Hue adjustment with delta={delta} should change the image"
        
        print(f"Hue adjustment test passed: shape={input_shape}, dtype={dtype}, delta={delta}, "
              f"luminance_diff={luminance_diff:.6f}")
    
    # Test saturation adjustment if scale != 1.0
    if abs(scale - 1.0) > 1e-7:
        # Adjust saturation
        sat_adjusted = gen_image_ops.adjust_saturation(
            images=rgb_image,
            scale=tf.constant(scale, dtype=tf.float32)
        )
        
        # Weak assertions for saturation adjustment
        # 1. Check shape
        assert sat_adjusted.shape == tuple(input_shape), f"Expected shape {input_shape}, got {sat_adjusted.shape}"
        
        # 2. Check dtype
        assert sat_adjusted.dtype == dtype, f"Expected dtype {dtype}, got {sat_adjusted.dtype}"
        
        # 3. Check finite values
        sat_adj_np = sat_adjusted.numpy()
        assert np.all(np.isfinite(sat_adj_np)), "All saturation-adjusted values should be finite"
        
        # 4. Check value range (RGB values should be in [0, 1])
        sat_adj_min = tf.reduce_min(sat_adjusted).numpy()
        sat_adj_max = tf.reduce_max(sat_adjusted).numpy()
        assert sat_adj_min >= 0.0 - 1e-5, f"Saturation-adjusted RGB should be >= 0, got min={sat_adj_min}"
        assert sat_adj_max <= 1.0 + 1e-5, f"Saturation-adjusted RGB should be <= 1, got max={sat_adj_max}"
        
        # Additional checks for saturation adjustment
        # When scale > 1, saturation should increase
        # When scale < 1, saturation should decrease
        # We can check this by computing colorfulness or saturation metrics
        
        # Convert to HSV to check saturation changes
        rgb_image_float = tf.cast(rgb_image, tf.float32)
        sat_adjusted_float = tf.cast(sat_adjusted, tf.float32)
        
        # Compute saturation using simplified formula: max(R,G,B) - min(R,G,B)
        orig_max = tf.reduce_max(rgb_image_float, axis=-1)
        orig_min = tf.reduce_min(rgb_image_float, axis=-1)
        orig_saturation = orig_max - orig_min
        
        adj_max = tf.reduce_max(sat_adjusted_float, axis=-1)
        adj_min = tf.reduce_min(sat_adjusted_float, axis=-1)
        adj_saturation = adj_max - adj_min
        
        # Check saturation change direction
        if scale > 1.0:
            # Saturation should increase or stay same
            saturation_increased = tf.reduce_all(adj_saturation >= orig_saturation - 1e-5)
            assert saturation_increased, f"Saturation should increase when scale={scale} > 1"
        elif scale < 1.0:
            # Saturation should decrease or stay same
            saturation_decreased = tf.reduce_all(adj_saturation <= orig_saturation + 1e-5)
            assert saturation_decreased, f"Saturation should decrease when scale={scale} < 1"
        
        # Check that saturation adjustment actually changes the image (unless scale is 1.0)
        diff = tf.reduce_max(tf.abs(sat_adjusted - rgb_image)).numpy()
        assert diff > 1e-5, f"Saturation adjustment with scale={scale} should change the image"
        
        print(f"Saturation adjustment test passed: shape={input_shape}, dtype={dtype}, scale={scale}")
    
    # Test combined hue and saturation adjustment
    if abs(delta) > 1e-7 and abs(scale - 1.0) > 1e-7:
        # First adjust hue
        hue_adjusted = gen_image_ops.adjust_hue(
            images=rgb_image,
            delta=tf.constant(delta, dtype=tf.float32)
        )
        
        # Then adjust saturation
        both_adjusted = gen_image_ops.adjust_saturation(
            images=hue_adjusted,
            scale=tf.constant(scale, dtype=tf.float32)
        )
        
        # Check combined adjustment
        assert both_adjusted.shape == tuple(input_shape), f"Expected shape {input_shape}, got {both_adjusted.shape}"
        assert both_adjusted.dtype == dtype, f"Expected dtype {dtype}, got {both_adjusted.dtype}"
        
        both_adj_np = both_adjusted.numpy()
        assert np.all(np.isfinite(both_adj_np)), "All combined-adjusted values should be finite"
        
        both_adj_min = tf.reduce_min(both_adjusted).numpy()
        both_adj_max = tf.reduce_max(both_adjusted).numpy()
        assert both_adj_min >= 0.0 - 1e-5, f"Combined-adjusted RGB should be >= 0, got min={both_adj_min}"
        assert both_adj_max <= 1.0 + 1e-5, f"Combined-adjusted RGB should be <= 1, got max={both_adj_max}"
        
        print(f"Combined hue and saturation adjustment test passed: "
              f"shape={input_shape}, dtype={dtype}, delta={delta}, scale={scale}")
# ==== BLOCK:CASE_07 END ====

# ==== BLOCK:CASE_08 START ====
# ==== DEFERRED: Placeholder for future test cases ====
# This block is reserved for deferred test cases
# Will be populated in later iterations if needed
# ==== BLOCK:CASE_08 END ====

# ==== BLOCK:CASE_09 START ====
# ==== DEFERRED: Placeholder for future test cases ====
# This block is reserved for deferred test cases
# Will be populated in later iterations if needed
# ==== BLOCK:CASE_09 END ====

# ==== BLOCK:CASE_10 START ====
# ==== DEFERRED: Placeholder for future test cases ====
# This block is reserved for deferred test cases
# Will be populated in later iterations if needed
# ==== BLOCK:CASE_10 END ====

# ==== BLOCK:FOOTER START ====
# ==== Test execution entry point (if needed) ====
if __name__ == "__main__":
    # This allows running the test file directly
    pytest.main([__file__, "-v"])
# ==== BLOCK:FOOTER END ====