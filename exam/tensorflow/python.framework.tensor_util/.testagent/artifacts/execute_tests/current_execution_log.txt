=== Run Tests ===
.................F...                                                    [100%]
================================== FAILURES ===================================
____________ test_empty_and_boundary_shapes[42-None-python scalar] ____________

values = 42, shape = None, description = 'python scalar'

    @pytest.mark.parametrize("values,shape,description", [
        # Empty list with no shape
        ([], None, "empty list no shape"),
        # Empty list with shape [0]
        ([], [0], "empty list shape [0]"),
        # Empty list with shape [0, 3]
        ([], [0, 3], "empty list shape [0, 3]"),
        # Empty numpy array
        (np.array([]), None, "empty numpy array"),
        # Zero-dimensional scalar (numpy scalar)
        (np.int32(5), None, "numpy scalar"),
        # Python scalar
        (42, None, "python scalar"),
        # Single element list
        ([7], None, "single element list"),
        # Large shape but empty values
        ([], [100, 0, 50], "large shape with zero dimension"),
    ])
    def test_empty_and_boundary_shapes(values, shape, description):
        """TC-05: Empty values and boundary shape handling.
    
        Test that make_tensor_proto correctly handles edge cases:
        - Empty lists and arrays
        - Zero-dimensional scalars
        - Shapes with zero dimensions
        - Single element inputs
    
        Weak assertions:
        1. no_crash: Function should not crash on boundary inputs
        2. shape_correct: Inferred or specified shape should be correct
        3. dtype_inferred: Data type should be inferred correctly
        """
        try:
            # Weak assertion 1: no_crash - function should complete without errors
            proto = tensor_util.make_tensor_proto(
                values=values,
                dtype=None,  # Let it infer dtype
                shape=shape,
                verify_shape=False,
                allow_broadcast=False
            )
    
            # Check that we got a TensorProto
            assert isinstance(proto, tensor_pb2.TensorProto), \
                f"{description}: Should return TensorProto"
    
            # Determine expected shape
            if shape is not None:
                expected_shape = shape
            elif isinstance(values, list):
                if len(values) == 0:
                    # Empty list - shape depends on implementation
                    # TensorFlow might infer shape as [0] or handle specially
                    expected_shape = [0]
                else:
                    # Non-empty list
                    if isinstance(values[0], list):
                        # Nested list
                        expected_shape = [len(values), len(values[0])]
                    else:
                        # Flat list
                        expected_shape = [len(values)]
            elif isinstance(values, np.ndarray):
                expected_shape = list(values.shape)
            else:
                # Scalar value
                expected_shape = []
    
            # Weak assertion 2: shape_correct - check shape
            actual_shape = [dim.size for dim in proto.tensor_shape.dim]
    
            # For empty arrays with no shape specified, TensorFlow might infer [0]
            # For scalars, shape should be empty list []
            if description == "python scalar" or description == "numpy scalar":
                assert actual_shape == [], f"{description}: Scalar should have empty shape, got {actual_shape}"
            elif description == "empty list no shape":
                # TensorFlow might infer [0] for empty list
                assert actual_shape == [0] or actual_shape == [], \
                    f"{description}: Empty list should have shape [0] or [], got {actual_shape}"
            else:
                # For other cases, shape should match expected
                assert actual_shape == expected_shape, \
                    f"{description}: Expected shape {expected_shape}, got {actual_shape}"
    
            # Weak assertion 3: dtype_inferred - check dtype is inferred
            # Convert values to numpy array to check dtype
            if isinstance(values, list):
                if len(values) == 0:
                    # Empty list - TensorFlow might use float32 or int32 default
                    # We just check that dtype is set
                    assert proto.dtype is not None, f"{description}: Dtype should be set"
                else:
                    # Non-empty list - check dtype matches values
                    expected_dtype = tf.as_dtype(np.array(values).dtype).as_datatype_enum
                    assert proto.dtype == expected_dtype, \
                        f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
            elif isinstance(values, np.ndarray):
                expected_dtype = tf.as_dtype(values.dtype).as_datatype_enum
                assert proto.dtype == expected_dtype, \
                    f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
            else:
                # Scalar - check dtype matches scalar type
>               expected_dtype = tf.as_dtype(type(values)).as_datatype_enum

tests\test_tensorflow_python_framework_tensor_util.py:547: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

type_value = <class 'int'>

    @tf_export("dtypes.as_dtype", "as_dtype")
    def as_dtype(type_value):
      """Converts the given `type_value` to a `DType`.
    
      Note: `DType` values are interned. When passed a new `DType` object,
      `as_dtype` always returns the interned value.
    
      Args:
        type_value: A value that can be converted to a `tf.DType` object. This may
          currently be a `tf.DType` object, a [`DataType`
          enum](https://www.tensorflow.org/code/tensorflow/core/framework/types.proto),
            a string type name, or a [`numpy.dtype`](https://numpy.org/doc/stable/reference/generated/numpy.dtype.html).
    
      Returns:
        A `DType` corresponding to `type_value`.
    
      Raises:
        TypeError: If `type_value` cannot be converted to a `DType`.
      """
      if isinstance(type_value, DType):
        return _INTERN_TABLE[type_value.as_datatype_enum]
    
      if isinstance(type_value, np.dtype):
        try:
          return _NP_TO_TF[type_value.type]
        except KeyError:
          pass
    
      try:
        return _ANY_TO_TF[type_value]
      except (KeyError, TypeError):
        # TypeError indicates that type_value is not hashable.
        pass
    
      if hasattr(type_value, "dtype"):
        try:
          return _NP_TO_TF[np.dtype(type_value.dtype).type]
        except (KeyError, TypeError):
          pass
    
      if isinstance(type_value, _dtypes.DType):
        return _INTERN_TABLE[type_value.as_datatype_enum]
    
>     raise TypeError(f"Cannot convert the argument `type_value`: {type_value!r} "
                      "to a TensorFlow DType.")
E     TypeError: Cannot convert the argument `type_value`: <class 'int'> to a TensorFlow DType.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\dtypes.py:721: TypeError

During handling of the above exception, another exception occurred:

values = 42, shape = None, description = 'python scalar'

    @pytest.mark.parametrize("values,shape,description", [
        # Empty list with no shape
        ([], None, "empty list no shape"),
        # Empty list with shape [0]
        ([], [0], "empty list shape [0]"),
        # Empty list with shape [0, 3]
        ([], [0, 3], "empty list shape [0, 3]"),
        # Empty numpy array
        (np.array([]), None, "empty numpy array"),
        # Zero-dimensional scalar (numpy scalar)
        (np.int32(5), None, "numpy scalar"),
        # Python scalar
        (42, None, "python scalar"),
        # Single element list
        ([7], None, "single element list"),
        # Large shape but empty values
        ([], [100, 0, 50], "large shape with zero dimension"),
    ])
    def test_empty_and_boundary_shapes(values, shape, description):
        """TC-05: Empty values and boundary shape handling.
    
        Test that make_tensor_proto correctly handles edge cases:
        - Empty lists and arrays
        - Zero-dimensional scalars
        - Shapes with zero dimensions
        - Single element inputs
    
        Weak assertions:
        1. no_crash: Function should not crash on boundary inputs
        2. shape_correct: Inferred or specified shape should be correct
        3. dtype_inferred: Data type should be inferred correctly
        """
        try:
            # Weak assertion 1: no_crash - function should complete without errors
            proto = tensor_util.make_tensor_proto(
                values=values,
                dtype=None,  # Let it infer dtype
                shape=shape,
                verify_shape=False,
                allow_broadcast=False
            )
    
            # Check that we got a TensorProto
            assert isinstance(proto, tensor_pb2.TensorProto), \
                f"{description}: Should return TensorProto"
    
            # Determine expected shape
            if shape is not None:
                expected_shape = shape
            elif isinstance(values, list):
                if len(values) == 0:
                    # Empty list - shape depends on implementation
                    # TensorFlow might infer shape as [0] or handle specially
                    expected_shape = [0]
                else:
                    # Non-empty list
                    if isinstance(values[0], list):
                        # Nested list
                        expected_shape = [len(values), len(values[0])]
                    else:
                        # Flat list
                        expected_shape = [len(values)]
            elif isinstance(values, np.ndarray):
                expected_shape = list(values.shape)
            else:
                # Scalar value
                expected_shape = []
    
            # Weak assertion 2: shape_correct - check shape
            actual_shape = [dim.size for dim in proto.tensor_shape.dim]
    
            # For empty arrays with no shape specified, TensorFlow might infer [0]
            # For scalars, shape should be empty list []
            if description == "python scalar" or description == "numpy scalar":
                assert actual_shape == [], f"{description}: Scalar should have empty shape, got {actual_shape}"
            elif description == "empty list no shape":
                # TensorFlow might infer [0] for empty list
                assert actual_shape == [0] or actual_shape == [], \
                    f"{description}: Empty list should have shape [0] or [], got {actual_shape}"
            else:
                # For other cases, shape should match expected
                assert actual_shape == expected_shape, \
                    f"{description}: Expected shape {expected_shape}, got {actual_shape}"
    
            # Weak assertion 3: dtype_inferred - check dtype is inferred
            # Convert values to numpy array to check dtype
            if isinstance(values, list):
                if len(values) == 0:
                    # Empty list - TensorFlow might use float32 or int32 default
                    # We just check that dtype is set
                    assert proto.dtype is not None, f"{description}: Dtype should be set"
                else:
                    # Non-empty list - check dtype matches values
                    expected_dtype = tf.as_dtype(np.array(values).dtype).as_datatype_enum
                    assert proto.dtype == expected_dtype, \
                        f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
            elif isinstance(values, np.ndarray):
                expected_dtype = tf.as_dtype(values.dtype).as_datatype_enum
                assert proto.dtype == expected_dtype, \
                    f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
            else:
                # Scalar - check dtype matches scalar type
                expected_dtype = tf.as_dtype(type(values)).as_datatype_enum
                assert proto.dtype == expected_dtype, \
                    f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
    
            print(f"Test passed for {description}: shape={actual_shape}, dtype={proto.dtype}")
    
        except Exception as e:
            # Some edge cases might raise exceptions - that's acceptable
            # but we should document which ones
            if description in ["empty list shape [0, 3]", "large shape with zero dimension"]:
                # These might fail due to shape/value mismatch
                print(f"Expected exception for {description}: {type(e).__name__}: {str(e)}")
            else:
                # Other cases should not raise exceptions
>               raise AssertionError(f"{description}: Unexpected exception: {type(e).__name__}: {str(e)}")
E               AssertionError: python scalar: Unexpected exception: TypeError: Cannot convert the argument `type_value`: <class 'int'> to a TensorFlow DType.

tests\test_tensorflow_python_framework_tensor_util.py:561: AssertionError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                                    Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------------------------------
test_behavior.py                                            0      0      0      0   100%
test_bfloat16.py                                           23     23      2      0     0%   1-36
tests\test_tensorflow_python_framework_tensor_util.py     189     32     56      6    79%   21-28, 33-44, 48-70, 126, 132, 432->441, 503, 558, 602-603
---------------------------------------------------------------------------------------------------
TOTAL                                                     212     55     58      6    71%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_framework_tensor_util.py::test_empty_and_boundary_shapes[42-None-python scalar]
1 failed, 20 passed in 1.64s

Error: exit 1