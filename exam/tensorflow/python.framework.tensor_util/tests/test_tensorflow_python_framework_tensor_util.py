# ==== BLOCK:HEADER START ====
"""
Test cases for tensorflow.python.framework.tensor_util module.
Generated by ATTest for target: tensorflow.python.framework.tensor_util
"""

import math
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.framework import tensor_util
from tensorflow.core.framework import tensor_pb2
from tensorflow.python.framework import dtypes

# Set random seed for reproducibility
np.random.seed(42)

# Helper functions for assertions
def assert_tensor_proto_basic(proto, expected_dtype, expected_shape=None):
    """Basic assertions for TensorProto (weak assertions)."""
    assert isinstance(proto, tensor_pb2.TensorProto), "Result should be TensorProto"
    assert proto.dtype == expected_dtype, f"Expected dtype {expected_dtype}, got {proto.dtype}"
    
    if expected_shape is not None:
        actual_shape = [dim.size for dim in proto.tensor_shape.dim]
        assert actual_shape == expected_shape, f"Expected shape {expected_shape}, got {actual_shape}"
    
    return proto

def assert_values_preserved(proto, expected_values, rtol=1e-6, atol=1e-8):
    """Check that values are preserved in the TensorProto."""
    # Convert proto back to numpy array for comparison
    actual_array = tensor_util.MakeNdarray(proto)
    
    if isinstance(expected_values, list):
        expected_array = np.array(expected_values)
    else:
        expected_array = expected_values
    
    # For numeric types, use appropriate tolerance
    if np.issubdtype(actual_array.dtype, np.floating):
        np.testing.assert_allclose(actual_array, expected_array, rtol=rtol, atol=atol)
    else:
        np.testing.assert_array_equal(actual_array, expected_array)

def create_test_tensor_proto(values, dtype=None):
    """Helper to create a TensorProto for testing."""
    if dtype is None:
        # Infer dtype from values
        if isinstance(values, list):
            array = np.array(values)
        else:
            array = values
        dtype = tf.as_dtype(array.dtype).as_datatype_enum
    
    proto = tensor_pb2.TensorProto()
    proto.dtype = dtype
    
    # Set shape
    if isinstance(values, list):
        shape = np.array(values).shape
    else:
        shape = values.shape
    
    for dim in shape:
        proto.tensor_shape.dim.add().size = dim
    
    # Set values (simplified - actual implementation would serialize properly)
    # This is just for creating test input
    return proto
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
@pytest.mark.parametrize("values,dtype_str,expected_dtype,shape,description", [
    # Basic Python lists (original test cases)
    ([1, 2, 3, 4], "int32", dtypes.int32.as_datatype_enum, None, "int32 list"),
    ([1.0, 2.0, 3.0], "float32", dtypes.float32.as_datatype_enum, None, "float32 list"),
    ([True, False, True], "bool", dtypes.bool.as_datatype_enum, None, "bool list"),
    
    # Parameter extension 1: numpy ndarray with float64
    (np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]], dtype=np.float64), 
     "float64", dtypes.float64.as_datatype_enum, [3, 3], "numpy float64 array"),
    
    # Parameter extension 2: string array
    ([["hello", "world"], ["foo", "bar"]], 
     "string", dtypes.string.as_datatype_enum, [2, 2], "string array"),
])
def test_basic_data_type_conversion(values, dtype_str, expected_dtype, shape, description):
    """TC-01: Basic data type conversion (weak assertions).
    
    Test that make_tensor_proto correctly converts various inputs
    to TensorProto with appropriate data types.
    
    Includes parameter extensions:
    1. numpy ndarray input with float64 dtype
    2. string data type support
    """
    # Convert string dtype to actual dtype
    dtype = getattr(dtypes, dtype_str)
    
    # Create tensor proto
    proto = tensor_util.make_tensor_proto(
        values=values,
        dtype=dtype,
        shape=shape,
        verify_shape=False,
        allow_broadcast=False
    )
    
    # Weak assertions
    # 1. proto_type: Result should be TensorProto
    assert isinstance(proto, tensor_pb2.TensorProto), \
        f"{description}: Result should be TensorProto"
    
    # 2. dtype_match: Check dtype matches expected
    assert proto.dtype == expected_dtype, \
        f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
    
    # 3. shape_match: Check shape is inferred correctly
    if shape is not None:
        expected_shape = shape
    elif isinstance(values, list):
        # For lists, infer shape
        if isinstance(values[0], list):
            # 2D list
            expected_shape = [len(values), len(values[0])]
        else:
            # 1D list
            expected_shape = [len(values)]
    else:
        # For numpy arrays
        expected_shape = list(values.shape)
    
    actual_shape = [dim.size for dim in proto.tensor_shape.dim]
    assert actual_shape == expected_shape, \
        f"{description}: Expected shape {expected_shape}, got {actual_shape}"
    
    # 4. values_preserved: Check values are preserved
    actual_array = tensor_util.MakeNdarray(proto)
    
    # Prepare expected array
    if isinstance(values, list):
        expected_array = np.array(values)
    else:
        expected_array = values
    
    # Different comparison strategies based on dtype
    if dtype_str in ["float32", "float64"]:
        # Float comparison with tolerance
        np.testing.assert_allclose(actual_array, expected_array, rtol=1e-6, atol=1e-8,
                                  err_msg=f"{description}: Values not preserved")
    elif dtype_str == "string":
        # String comparison - TensorFlow returns bytes for string tensors
        # Convert both to bytes for comparison
        actual_list = actual_array.tolist()
        expected_list = expected_array.tolist()
        
        # Convert expected strings to bytes for comparison
        expected_bytes = [[s.encode('utf-8') if isinstance(s, str) else s 
                          for s in row] for row in expected_list]
        
        assert actual_list == expected_bytes, \
            f"{description}: String values not preserved. Expected {expected_bytes}, got {actual_list}"
    else:
        # Exact comparison for int and bool
        np.testing.assert_array_equal(actual_array, expected_array,
                                     err_msg=f"{description}: Values not preserved")
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
@pytest.mark.parametrize("values,shape,should_succeed", [
    ([[1, 2], [3, 4]], [2, 2], True),   # Matching shape
    ([[1, 2], [3, 4]], [2, 3], False),  # Mismatched shape
])
def test_shape_validation_and_broadcast_exclusivity(values, shape, should_succeed):
    """TC-02: Shape validation and broadcast exclusivity (weak assertions).
    
    Test that verify_shape=True enforces shape matching and that
    verify_shape and allow_broadcast are mutually exclusive.
    """
    if should_succeed:
        # Test 1: Shape matches, should succeed
        proto = tensor_util.make_tensor_proto(
            values=values,
            dtype=dtypes.int32,
            shape=shape,
            verify_shape=True,
            allow_broadcast=False
        )
        
        # Weak assertions for successful case
        # 1. shape_validation: Shape should match
        actual_shape = [dim.size for dim in proto.tensor_shape.dim]
        assert actual_shape == shape
        
        # 2. no_broadcast_when_disabled: Values should match exactly
        actual_array = tensor_util.MakeNdarray(proto)
        expected_array = np.array(values)
        np.testing.assert_array_equal(actual_array, expected_array)
        
    else:
        # Test 2: Shape doesn't match, should raise TypeError
        # According to tensor_util.make_tensor_proto source code,
        # when verify_shape=True and shape doesn't match, it raises TypeError
        with pytest.raises(TypeError) as exc_info:
            tensor_util.make_tensor_proto(
                values=values,
                dtype=dtypes.int32,
                shape=shape,
                verify_shape=True,
                allow_broadcast=False
            )
        
        # 3. error_on_mismatch: Should raise error for shape mismatch
        error_msg = str(exc_info.value).lower()
        # Check for shape-related error messages
        # The actual error message might be "too many elements provided" or similar
        # We'll check for any error that indicates shape mismatch
        assert any(keyword in error_msg for keyword in ["shape", "size", "expected", "element", "dimension"]), \
            f"Error message should indicate shape mismatch, got: {error_msg}"

def test_verify_shape_and_allow_broadcast_mutually_exclusive():
    """Test that verify_shape and allow_broadcast cannot both be True."""
    values = [[1, 2], [3, 4]]
    
    with pytest.raises(ValueError) as exc_info:
        tensor_util.make_tensor_proto(
            values=values,
            dtype=dtypes.int32,
            shape=[2, 2],
            verify_shape=True,
            allow_broadcast=True
        )
    
    # Check error message indicates mutual exclusivity
    error_msg = str(exc_info.value).lower()
    assert "allow_broadcast" in error_msg and "verify_shape" in error_msg

def test_broadcast_functionality():
    """Parameter extension: Broadcast functionality verification.
    
    Test that allow_broadcast=True enables scalar and length-1 vector
    broadcasting to the specified shape.
    """
    # Test 1: Scalar broadcasting to [1, 1] shape
    scalar_value = 5
    proto = tensor_util.make_tensor_proto(
        values=scalar_value,
        dtype=dtypes.int32,
        shape=[1, 1],
        verify_shape=False,
        allow_broadcast=True
    )
    
    # Check shape
    actual_shape = [dim.size for dim in proto.tensor_shape.dim]
    assert actual_shape == [1, 1], f"Expected shape [1, 1], got {actual_shape}"
    
    # Check value - should be broadcasted
    actual_array = tensor_util.MakeNdarray(proto)
    expected_array = np.array([[5]], dtype=np.int32)
    np.testing.assert_array_equal(actual_array, expected_array)
    
    # Test 2: Length-1 vector broadcasting to [2, 2] shape
    vector_value = [7]
    proto2 = tensor_util.make_tensor_proto(
        values=vector_value,
        dtype=dtypes.int32,
        shape=[2, 2],
        verify_shape=False,
        allow_broadcast=True
    )
    
    # Check shape
    actual_shape2 = [dim.size for dim in proto2.tensor_shape.dim]
    assert actual_shape2 == [2, 2], f"Expected shape [2, 2], got {actual_shape2}"
    
    # Check value - should be broadcasted
    actual_array2 = tensor_util.MakeNdarray(proto2)
    expected_array2 = np.array([[7, 7], [7, 7]], dtype=np.int32)
    np.testing.assert_array_equal(actual_array2, expected_array2)
    
    # Test 3: Without allow_broadcast, scalar with shape [2,2] should work
    # but values will be replicated to fill the shape
    proto3 = tensor_util.make_tensor_proto(
        values=scalar_value,
        dtype=dtypes.int32,
        shape=[2, 2],
        verify_shape=False,
        allow_broadcast=False
    )
    
    # Check shape
    actual_shape3 = [dim.size for dim in proto3.tensor_shape.dim]
    assert actual_shape3 == [2, 2], f"Expected shape [2, 2], got {actual_shape3}"
    
    # Check value - scalar should be replicated to fill shape
    actual_array3 = tensor_util.MakeNdarray(proto3)
    expected_array3 = np.array([[5, 5], [5, 5]], dtype=np.int32)
    np.testing.assert_array_equal(actual_array3, expected_array3)
    
    # Test 4: Without allow_broadcast, length-1 vector with shape [2,2] should work
    # but values will be replicated to fill the shape
    proto4 = tensor_util.make_tensor_proto(
        values=vector_value,
        dtype=dtypes.int32,
        shape=[2, 2],
        verify_shape=False,
        allow_broadcast=False
    )
    
    # Check shape
    actual_shape4 = [dim.size for dim in proto4.tensor_shape.dim]
    assert actual_shape4 == [2, 2], f"Expected shape [2, 2], got {actual_shape4}"
    
    # Check value - vector should be replicated to fill shape
    actual_array4 = tensor_util.MakeNdarray(proto4)
    expected_array4 = np.array([[7, 7], [7, 7]], dtype=np.int32)
    np.testing.assert_array_equal(actual_array4, expected_array4)
    
    # Test 5: Test actual shape mismatch (not scalar or length-1)
    # This should raise an error even with allow_broadcast=False
    mismatched_values = [[1, 2, 3], [4, 5, 6]]  # shape [2, 3]
    with pytest.raises((ValueError, TypeError)) as exc_info:
        tensor_util.make_tensor_proto(
            values=mismatched_values,
            dtype=dtypes.int32,
            shape=[2, 2],  # Mismatched shape
            verify_shape=False,
            allow_broadcast=False
        )
    
    # Should raise error about shape mismatch
    # The actual error message is "too many elements provided. takes at most 4, but got 6."
    error_msg = str(exc_info.value).lower()
    # Check for element count or shape mismatch indicators
    assert any(keyword in error_msg for keyword in ["element", "shape", "size", "expected", "provided", "takes"]), \
        f"Error message should indicate element count or shape mismatch, got: {error_msg}"
    
    # Specifically check for the actual error message pattern
    assert "too many" in error_msg or "element" in error_msg, \
        f"Error message should mention 'too many' or 'element', got: {error_msg}"
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_03 START ====
def test_tensorproto_input_direct_return():
    """TC-03: TensorProto input directly returns the same object (weak assertions).
    
    Test that when values is already a TensorProto, make_tensor_proto
    returns it directly without modification.
    """
    # Create a test TensorProto
    test_proto = tensor_pb2.TensorProto()
    test_proto.dtype = dtypes.float32.as_datatype_enum
    test_proto.tensor_shape.dim.add().size = 2
    test_proto.tensor_shape.dim.add().size = 3
    
    # Set some float values
    test_proto.float_val.extend([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])
    
    # Call make_tensor_proto with the TensorProto as input
    result = tensor_util.make_tensor_proto(
        values=test_proto,
        dtype=dtypes.int32,  # Should be ignored
        shape=[3, 2],        # Should be ignored
        verify_shape=True,   # Should be ignored
        allow_broadcast=False  # Should be ignored
    )
    
    # Weak assertions
    # 1. same_object_returned: Should return the exact same object
    assert result is test_proto, "Should return the same TensorProto object"
    
    # 2. no_modification: Object should not be modified
    assert result.dtype == dtypes.float32.as_datatype_enum, "Dtype should not change"
    assert [dim.size for dim in result.tensor_shape.dim] == [2, 3], "Shape should not change"
    assert list(result.float_val) == [1.0, 2.0, 3.0, 4.0, 5.0, 6.0], "Values should not change"
    
    # 3. identity_check: Verify it's the same object identity
    assert id(result) == id(test_proto), "Object identity should be preserved"
# ==== BLOCK:CASE_03 END ====

# ==== BLOCK:CASE_04 START ====
@pytest.mark.parametrize("dtype_str,values_factory", [
    ("float16", lambda: np.array([1.0, 2.0, 3.0, 4.0], dtype=np.float16)),
    ("bfloat16", lambda: tf.constant([1.5, 2.5, 3.5, 4.5], dtype=tf.bfloat16).numpy()),
])
def test_special_data_type_support(dtype_str, values_factory):
    """TC-04: Special data type support (weak assertions).
    
    Test that make_tensor_proto correctly handles special data types
    like float16 and bfloat16.
    
    Weak assertions:
    1. dtype_supported: Function should not crash with special dtypes
    2. values_approximate: Values should be preserved approximately
    3. no_crash: Function should complete without errors
    """
    # Create numpy array with special dtype
    values = values_factory()
    
    # Get TensorFlow dtype
    dtype = getattr(dtypes, dtype_str)
    
    # Weak assertion 3: no_crash - function should complete without errors
    proto = tensor_util.make_tensor_proto(
        values=values,
        dtype=dtype,
        shape=None,
        verify_shape=False,
        allow_broadcast=False
    )
    
    # Weak assertion 1: dtype_supported - check dtype is correctly set
    assert proto.dtype == dtype.as_datatype_enum, \
        f"Expected dtype {dtype.as_datatype_enum}, got {proto.dtype}"
    
    # Check shape is inferred correctly
    expected_shape = list(values.shape)
    actual_shape = [dim.size for dim in proto.tensor_shape.dim]
    assert actual_shape == expected_shape, \
        f"Expected shape {expected_shape}, got {actual_shape}"
    
    # Convert back to numpy array for value comparison
    actual_array = tensor_util.MakeNdarray(proto)
    
    # Weak assertion 2: values_approximate - check values are preserved approximately
    # For float16 and bfloat16, we need larger tolerance due to lower precision
    if dtype_str == "float16":
        # float16 has about 3 decimal digits of precision
        np.testing.assert_allclose(actual_array, values, rtol=1e-3, atol=1e-3)
    elif dtype_str == "bfloat16":
        # bfloat16 has about 2 decimal digits of precision (7 bits mantissa)
        # Note: MakeNdarray may return float32 for bfloat16 in some TensorFlow versions
        # We need to convert values to float32 for comparison
        values_float32 = values.astype(np.float32)
        np.testing.assert_allclose(actual_array, values_float32, rtol=1e-2, atol=1e-2)
    
    # Additional check: verify the returned array has a compatible dtype
    # For bfloat16, MakeNdarray may return float32, which is acceptable
    print(f"Test passed for {dtype_str}: shape={actual_shape}, actual_dtype={actual_array.dtype}, expected_dtype={values.dtype}")
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
@pytest.mark.parametrize("values,shape,description", [
    # Empty list with no shape
    ([], None, "empty list no shape"),
    # Empty list with shape [0]
    ([], [0], "empty list shape [0]"),
    # Empty list with shape [0, 3]
    ([], [0, 3], "empty list shape [0, 3]"),
    # Empty numpy array
    (np.array([]), None, "empty numpy array"),
    # Zero-dimensional scalar (numpy scalar)
    (np.int32(5), None, "numpy scalar"),
    # Python scalar
    (42, None, "python scalar"),
    # Single element list
    ([7], None, "single element list"),
    # Large shape but empty values
    ([], [100, 0, 50], "large shape with zero dimension"),
])
def test_empty_and_boundary_shapes(values, shape, description):
    """TC-05: Empty values and boundary shape handling.
    
    Test that make_tensor_proto correctly handles edge cases:
    - Empty lists and arrays
    - Zero-dimensional scalars
    - Shapes with zero dimensions
    - Single element inputs
    
    Weak assertions:
    1. no_crash: Function should not crash on boundary inputs
    2. shape_correct: Inferred or specified shape should be correct
    3. dtype_inferred: Data type should be inferred correctly
    """
    try:
        # Weak assertion 1: no_crash - function should complete without errors
        proto = tensor_util.make_tensor_proto(
            values=values,
            dtype=None,  # Let it infer dtype
            shape=shape,
            verify_shape=False,
            allow_broadcast=False
        )
        
        # Check that we got a TensorProto
        assert isinstance(proto, tensor_pb2.TensorProto), \
            f"{description}: Should return TensorProto"
        
        # Determine expected shape
        if shape is not None:
            expected_shape = shape
        elif isinstance(values, list):
            if len(values) == 0:
                # Empty list - shape depends on implementation
                # TensorFlow might infer shape as [0] or handle specially
                expected_shape = [0]
            else:
                # Non-empty list
                if isinstance(values[0], list):
                    # Nested list
                    expected_shape = [len(values), len(values[0])]
                else:
                    # Flat list
                    expected_shape = [len(values)]
        elif isinstance(values, np.ndarray):
            expected_shape = list(values.shape)
        else:
            # Scalar value
            expected_shape = []
        
        # Weak assertion 2: shape_correct - check shape
        actual_shape = [dim.size for dim in proto.tensor_shape.dim]
        
        # For empty arrays with no shape specified, TensorFlow might infer [0]
        # For scalars, shape should be empty list []
        if description == "python scalar" or description == "numpy scalar":
            assert actual_shape == [], f"{description}: Scalar should have empty shape, got {actual_shape}"
        elif description == "empty list no shape":
            # TensorFlow might infer [0] for empty list
            assert actual_shape == [0] or actual_shape == [], \
                f"{description}: Empty list should have shape [0] or [], got {actual_shape}"
        else:
            # For other cases, shape should match expected
            assert actual_shape == expected_shape, \
                f"{description}: Expected shape {expected_shape}, got {actual_shape}"
        
        # Weak assertion 3: dtype_inferred - check dtype is inferred
        # Convert values to numpy array to check dtype
        if isinstance(values, list):
            if len(values) == 0:
                # Empty list - TensorFlow might use float32 or int32 default
                # We just check that dtype is set
                assert proto.dtype is not None, f"{description}: Dtype should be set"
            else:
                # Non-empty list - check dtype matches values
                expected_dtype = tf.as_dtype(np.array(values).dtype).as_datatype_enum
                assert proto.dtype == expected_dtype, \
                    f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
        elif isinstance(values, np.ndarray):
            expected_dtype = tf.as_dtype(values.dtype).as_datatype_enum
            assert proto.dtype == expected_dtype, \
                f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
        else:
            # Scalar - check dtype matches scalar type
            expected_dtype = tf.as_dtype(type(values)).as_datatype_enum
            assert proto.dtype == expected_dtype, \
                f"{description}: Expected dtype {expected_dtype}, got {proto.dtype}"
        
        print(f"Test passed for {description}: shape={actual_shape}, dtype={proto.dtype}")
        
    except Exception as e:
        # Some edge cases might raise exceptions - that's acceptable
        # but we should document which ones
        if description in ["empty list shape [0, 3]", "large shape with zero dimension"]:
            # These might fail due to shape/value mismatch
            print(f"Expected exception for {description}: {type(e).__name__}: {str(e)}")
        else:
            # Other cases should not raise exceptions
            raise AssertionError(f"{description}: Unexpected exception: {type(e).__name__}: {str(e)}")

def test_none_values_not_supported():
    """Test that None values raise appropriate error."""
    with pytest.raises(ValueError) as exc_info:
        tensor_util.make_tensor_proto(
            values=None,
            dtype=dtypes.int32,
            shape=None,
            verify_shape=False,
            allow_broadcast=False
        )
    
    error_msg = str(exc_info.value).lower()
    assert "none" in error_msg, f"Error should mention None values, got: {error_msg}"
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:CASE_06 START ====
# ==== DEFERRED: TC-06 ====
# This test case is deferred and will be implemented in later iterations.
# Test plan: To be defined based on requirements and test plan
pass
# ==== BLOCK:CASE_06 END ====

# ==== BLOCK:CASE_07 START ====
# ==== DEFERRED: TC-07 ====
# This test case is deferred and will be implemented in later iterations.
# Test plan: To be defined based on requirements and test plan
pass
# ==== BLOCK:CASE_07 END ====

# ==== BLOCK:CASE_08 START ====
# ==== DEFERRED: TC-08 ====
# This test case is deferred and will be implemented in later iterations.
# Test plan: To be defined based on requirements and test plan
pass
# ==== BLOCK:CASE_08 END ====

# ==== BLOCK:FOOTER START ====
if __name__ == "__main__":
    # Simple test runner for debugging
    import sys
    pytest.main([__file__] + sys.argv[1:])
# ==== BLOCK:FOOTER END ====