=== Run Tests ===
..F..                                                                    [100%]
================================== FAILURES ===================================
_______ TestDefFunctionG1.test_variable_creation_and_state_preservation _______

self = <test_tensorflow_python_eager_def_function_g1.TestDefFunctionG1 object at 0x000002051F5E1640>

    def test_variable_creation_and_state_preservation(self):
        """CASE_03: 变量创建与状态保持 - 测试变量创建和状态保持"""
        # Test stateful counter function
        # According to tf.function documentation, variables can only be created
        # on the first call to the function
    
        # Method 1: Using a class to hold state (recommended pattern)
        class CounterModule:
            def __init__(self):
                self.counter = None
    
            @def_function.function
            def __call__(self):
                # Variable should be created only on first call
                if self.counter is None:
                    self.counter = tf.Variable(0, dtype=tf.int32)
                self.counter.assign_add(1)
                return self.counter.read_value()
    
        # Create module instance
        module = CounterModule()
    
        # Weak assertions
        # 1. variable_created_once: Variable should be created on first call
        # First call - should create variable
        result1 = module()
        assert result1.numpy() == 1, f"First call should return 1, got {result1.numpy()}"
    
        # Store the variable reference to check it's the same object
        var_ref = module.counter
    
        # Second call - should use existing variable, not create new one
        result2 = module()
        assert result2.numpy() == 2, f"Second call should return 2, got {result2.numpy()}"
    
        # Verify it's the same variable object
        assert module.counter is var_ref, "Variable should be the same object on subsequent calls"
    
        # 2. state_preserved: State should be preserved between calls
        # Third call - should increment again
        result3 = module()
        assert result3.numpy() == 3, f"Third call should return 3, got {result3.numpy()}"
    
        # Verify the variable value is preserved
        assert module.counter.numpy() == 3, f"Variable value should be 3, got {module.counter.numpy()}"
    
        # 3. callable: Verify function is callable
        assert callable(module), "Module instance should be callable"
    
        # 4. basic_execution: Test basic execution with different patterns
        # Method 2: Using closure with nonlocal variable (alternative pattern)
        counter_var = None
    
        @def_function.function
        def closure_counter():
            nonlocal counter_var
            if counter_var is None:
                counter_var = tf.Variable(0, dtype=tf.int32)
            counter_var.assign_add(1)
            return counter_var.read_value()
    
        # Reset for clean test
        counter_var = None
    
        # Test closure pattern
        closure_result1 = closure_counter()
        assert closure_result1.numpy() == 1, f"Closure first call should return 1, got {closure_result1.numpy()}"
    
        closure_result2 = closure_counter()
        assert closure_result2.numpy() == 2, f"Closure second call should return 2, got {closure_result2.numpy()}"
    
        # Method 3: Test with initial value parameter
        @def_function.function
        def counter_with_initial(initial_value):
            # This creates a new variable each time due to different Python values
            # This is expected behavior - different Python values cause retracing
            counter = tf.Variable(initial_value, dtype=tf.int32)
            counter.assign_add(1)
            return counter.read_value()
    
        # Test with different initial values (will create different variables)
>       result_a = counter_with_initial(10)

tests\test_tensorflow_python_eager_def_function_g1.py:217: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\util\traceback_utils.py:153: in error_handler
    raise e.with_traceback(filtered_tb) from None
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = (10,), kwargs = {}

    def autograph_handler(*args, **kwargs):
      """Calls a converted version of original_func."""
      # TODO(mdan): Push this block higher in tf.function's call stack.
      try:
        return autograph.converted_call(
            original_func,
            args,
            kwargs,
            options=autograph.ConversionOptions(
                recursive=True,
                optional_features=autograph_options,
                user_requested=True,
            ))
      except Exception as e:  # pylint:disable=broad-except
        if hasattr(e, "ag_error_metadata"):
>         raise e.ag_error_metadata.to_exception(e)
E         ValueError: in user code:
E         
E             File "D:\Project\TestAgent-CLI-main\exam\tensorflow\python.eager.def_function\tests\test_tensorflow_python_eager_def_function_g1.py", line 212, in counter_with_initial  *
E                 counter = tf.Variable(initial_value, dtype=tf.int32)
E         
E             ValueError: tf.function only supports singleton tf.Variables created on the first call. Make sure the tf.Variable is only created once or created outside tf.function. See https://www.tensorflow.org/guide/function#creating_tfvariables for more information.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\func_graph.py:1147: ValueError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                                    Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------------------------------
tests\test_tensorflow_python_eager_def_function_g1.py     199     53     16      1    68%   35, 78, 150-153, 192-195, 212-214, 218-263, 273-276, 300-303, 315-321, 375, 407, 421, 446
---------------------------------------------------------------------------------------------------
TOTAL                                                     199     53     16      1    68%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_eager_def_function_g1.py::TestDefFunctionG1::test_variable_creation_and_state_preservation
1 failed, 4 passed in 1.97s

Error: exit 1