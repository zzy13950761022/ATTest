=== Run Tests ===
FFFF.F                                                                   [100%]
================================== FAILURES ===================================
__________ TestXLACompileCore.test_basic_compilation[float32-shape0] __________

self = <test_tensorflow_python_compiler_xla_xla_core.TestXLACompileCore object at 0x0000017612B4A940>
dtype = <class 'numpy.float32'>, shape = (2, 3)

    @pytest.mark.parametrize("dtype,shape", [
        (np.float32, (2, 3)),  # 基础测试用例
        (np.float64, (5, 5)),  # 扩展数据类型和形状
        (np.float32, (10, 10)),  # 扩展计算复杂度
    ])
    def test_basic_compilation(self, dtype, shape):
        """测试基本编译功能验证"""
        # 定义简单的算术计算函数
        def simple_arithmetic(x, y):
            return x + y, x * y, x - y
    
        # 创建测试输入
        x = create_test_tensor(shape, dtype)
        y = create_test_tensor(shape, dtype)
    
        # 直接调用计算函数作为基准
        direct_results = simple_arithmetic(x, y)
    
        # 使用 xla.compile 编译计算
        compiled_fn = xla.compile(simple_arithmetic, inputs=[x, y])
    
        # 验证输出类型和结构
>       assert isinstance(compiled_fn, tuple), "编译结果应该是元组"
E       AssertionError: 编译结果应该是元组
E       assert False
E        +  where False = isinstance([<tf.Tensor: shape=(2, 3), dtype=float32, numpy=\narray([[ 2.075927  ,  0.6291704 ,  0.17821419],\n       [ 2.06559   , ...umpy=\narray([[-1.0824987 , -0.905699  ,  1.117163  ],\n       [ 0.98046976,  0.2292643 ,  0.23159279]], dtype=float32)>], tuple)

tests\test_tensorflow_python_compiler_xla_xla_core.py:68: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-18 15:23:51.397451: I tensorflow/core/platform/cpu_feature_guard.cc:151] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX AVX2
To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.
2026-01-18 15:23:51.444644: I tensorflow/compiler/xla/service/service.cc:171] XLA service 0x17612f5b9a0 initialized for platform Host (this does not guarantee that XLA will be used). Devices:
2026-01-18 15:23:51.444694: I tensorflow/compiler/xla/service/service.cc:179]   StreamExecutor device (0): Host, Default Version
2026-01-18 15:23:51.459190: I tensorflow/compiler/jit/xla_compilation_cache.cc:399] Compiled cluster using XLA!  This line is logged at most once for the lifetime of the process.
------------------------------ Captured log call ------------------------------
WARNING  tensorflow:deprecation.py:337 From D:\Project\TestAgent-CLI-main\exam\tensorflow\python.compiler.xla.xla\tests\test_tensorflow_python_compiler_xla_xla_core.py:65: compile (from tensorflow.python.compiler.xla.xla) is deprecated and will be removed in a future version.
Instructions for updating:
xla.experimental.compile is deprecated. Consider using tf.function(jit_compile=True)
__________ TestXLACompileCore.test_basic_compilation[float64-shape1] __________

self = <test_tensorflow_python_compiler_xla_xla_core.TestXLACompileCore object at 0x0000017612B4A9A0>
dtype = <class 'numpy.float64'>, shape = (5, 5)

    @pytest.mark.parametrize("dtype,shape", [
        (np.float32, (2, 3)),  # 基础测试用例
        (np.float64, (5, 5)),  # 扩展数据类型和形状
        (np.float32, (10, 10)),  # 扩展计算复杂度
    ])
    def test_basic_compilation(self, dtype, shape):
        """测试基本编译功能验证"""
        # 定义简单的算术计算函数
        def simple_arithmetic(x, y):
            return x + y, x * y, x - y
    
        # 创建测试输入
        x = create_test_tensor(shape, dtype)
        y = create_test_tensor(shape, dtype)
    
        # 直接调用计算函数作为基准
        direct_results = simple_arithmetic(x, y)
    
        # 使用 xla.compile 编译计算
        compiled_fn = xla.compile(simple_arithmetic, inputs=[x, y])
    
        # 验证输出类型和结构
>       assert isinstance(compiled_fn, tuple), "编译结果应该是元组"
E       AssertionError: 编译结果应该是元组
E       assert False
E        +  where False = isinstance([<tf.Tensor: shape=(5, 5), dtype=float64, numpy=\narray([[-1.71770785, -3.24146629, -1.5280566 ,  0.17617905, -0.841462...8, -1.32269327, -1.53298673,  2.69149571],\n       [ 0.29571515, -1.38897436, -0.15300022, -0.74166941,  0.39452257]])>], tuple)

tests\test_tensorflow_python_compiler_xla_xla_core.py:68: AssertionError
__________ TestXLACompileCore.test_basic_compilation[float32-shape2] __________

self = <test_tensorflow_python_compiler_xla_xla_core.TestXLACompileCore object at 0x0000017612B4AB80>
dtype = <class 'numpy.float32'>, shape = (10, 10)

    @pytest.mark.parametrize("dtype,shape", [
        (np.float32, (2, 3)),  # 基础测试用例
        (np.float64, (5, 5)),  # 扩展数据类型和形状
        (np.float32, (10, 10)),  # 扩展计算复杂度
    ])
    def test_basic_compilation(self, dtype, shape):
        """测试基本编译功能验证"""
        # 定义简单的算术计算函数
        def simple_arithmetic(x, y):
            return x + y, x * y, x - y
    
        # 创建测试输入
        x = create_test_tensor(shape, dtype)
        y = create_test_tensor(shape, dtype)
    
        # 直接调用计算函数作为基准
        direct_results = simple_arithmetic(x, y)
    
        # 使用 xla.compile 编译计算
        compiled_fn = xla.compile(simple_arithmetic, inputs=[x, y])
    
        # 验证输出类型和结构
>       assert isinstance(compiled_fn, tuple), "编译结果应该是元组"
E       AssertionError: 编译结果应该是元组
E       assert False
E        +  where False = isinstance([<tf.Tensor: shape=(10, 10), dtype=float32, numpy=\narray([[ 0.05226064, -2.0168889 ,  1.7759019 ,  1.769021  ,  0.7500...3011735,  0.59886336,\n         1.1815023 , -1.6351229 , -0.11808044, -0.04775119,  0.84660995]],\n      dtype=float32)>], tuple)

tests\test_tensorflow_python_compiler_xla_xla_core.py:68: AssertionError
________ TestXLACompileCore.test_none_and_empty_inputs[none-identity] _________

self = <test_tensorflow_python_compiler_xla_xla_core.TestXLACompileCore object at 0x0000017612B4AD30>
inputs_type = 'none', computation_type = 'identity'

    @pytest.mark.parametrize("inputs_type,computation_type", [
        ("none", "identity"),  # inputs=None
        ("empty_list", "identity"),  # inputs=[]
        ("none", "multi_input"),  # 多输入函数的None输入处理
    ])
    def test_none_and_empty_inputs(self, inputs_type, computation_type):
        """测试None与空输入处理"""
    
        if computation_type == "identity":
            # 定义恒等函数
            def identity(x):
                return x
    
            # 根据输入类型准备输入
            if inputs_type == "none":
                inputs = None
                # 创建测试张量用于直接调用
                test_tensor = create_test_tensor((1,), np.float32)
                direct_result = identity(test_tensor)
>               compiled_result = xla.compile(identity, inputs=None)

tests\test_tensorflow_python_compiler_xla_xla_core.py:116: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\util\deprecation.py:344: in new_func
    return func(*args, **kwargs)
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\compiler\xla\xla.py:120: in compile
    return xla_compile_wrapper()
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\util\traceback_utils.py:153: in error_handler
    raise e.with_traceback(filtered_tb) from None
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = (), kwargs = {}

    def autograph_handler(*args, **kwargs):
      """Calls a converted version of original_func."""
      # TODO(mdan): Push this block higher in tf.function's call stack.
      try:
        return autograph.converted_call(
            original_func,
            args,
            kwargs,
            options=autograph.ConversionOptions(
                recursive=True,
                optional_features=autograph_options,
                user_requested=True,
            ))
      except Exception as e:  # pylint:disable=broad-except
        if hasattr(e, "ag_error_metadata"):
>         raise e.ag_error_metadata.to_exception(e)
E         TypeError: in user code:
E         
E         
E             TypeError: identity() missing 1 required positional argument: 'x'

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\func_graph.py:1147: TypeError
_______ TestXLACompileCore.test_none_and_empty_inputs[none-multi_input] _______

self = <test_tensorflow_python_compiler_xla_xla_core.TestXLACompileCore object at 0x0000017612B68070>
inputs_type = 'none', computation_type = 'multi_input'

    @pytest.mark.parametrize("inputs_type,computation_type", [
        ("none", "identity"),  # inputs=None
        ("empty_list", "identity"),  # inputs=[]
        ("none", "multi_input"),  # 多输入函数的None输入处理
    ])
    def test_none_and_empty_inputs(self, inputs_type, computation_type):
        """测试None与空输入处理"""
    
        if computation_type == "identity":
            # 定义恒等函数
            def identity(x):
                return x
    
            # 根据输入类型准备输入
            if inputs_type == "none":
                inputs = None
                # 创建测试张量用于直接调用
                test_tensor = create_test_tensor((1,), np.float32)
                direct_result = identity(test_tensor)
                compiled_result = xla.compile(identity, inputs=None)
            elif inputs_type == "empty_list":
                inputs = []
                # 对于空列表输入，函数应该接受0个参数
                def identity_no_args():
                    return tf.constant(1.0, dtype=np.float32)
    
                direct_result = identity_no_args()
                compiled_result = xla.compile(identity_no_args, inputs=[])
            else:
                raise ValueError(f"Unknown inputs_type: {inputs_type}")
    
        elif computation_type == "multi_input":
            # 定义多输入函数
            def multi_input(x, y):
                return x + y, x * y
    
            # inputs=None 的情况
            if inputs_type == "none":
                inputs = None
                # 创建测试张量
                x = create_test_tensor((2, 2), np.float32)
                y = create_test_tensor((2, 2), np.float32)
                direct_result = multi_input(x, y)
>               compiled_result = xla.compile(multi_input, inputs=None)

tests\test_tensorflow_python_compiler_xla_xla_core.py:140: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\util\deprecation.py:344: in new_func
    return func(*args, **kwargs)
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\compiler\xla\xla.py:120: in compile
    return xla_compile_wrapper()
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\util\traceback_utils.py:153: in error_handler
    raise e.with_traceback(filtered_tb) from None
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

args = (), kwargs = {}

    def autograph_handler(*args, **kwargs):
      """Calls a converted version of original_func."""
      # TODO(mdan): Push this block higher in tf.function's call stack.
      try:
        return autograph.converted_call(
            original_func,
            args,
            kwargs,
            options=autograph.ConversionOptions(
                recursive=True,
                optional_features=autograph_options,
                user_requested=True,
            ))
      except Exception as e:  # pylint:disable=broad-except
        if hasattr(e, "ag_error_metadata"):
>         raise e.ag_error_metadata.to_exception(e)
E         TypeError: in user code:
E         
E         
E             TypeError: multi_input() missing 2 required positional arguments: 'x' and 'y'

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\framework\func_graph.py:1147: TypeError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                                    Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------------------------------
test_actual_behavior.py                                     0      0      0      0   100%
test_fix_verification.py                                    7      7      0      0     0%   1-16
test_none_behavior.py                                      24     24      0      0     0%   1-33
tests\test_tensorflow_python_compiler_xla_xla_core.py      90     25     38     11    66%   24-27, 39, 69-93, 126, 142-145, 152-155, 157-158, 161->exit, 164-167, 168->exit, 186
---------------------------------------------------------------------------------------------------
TOTAL                                                     121     56     38     11    53%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_compiler_xla_xla_core.py::TestXLACompileCore::test_basic_compilation[float32-shape0]
FAILED tests\test_tensorflow_python_compiler_xla_xla_core.py::TestXLACompileCore::test_basic_compilation[float64-shape1]
FAILED tests\test_tensorflow_python_compiler_xla_xla_core.py::TestXLACompileCore::test_basic_compilation[float32-shape2]
FAILED tests\test_tensorflow_python_compiler_xla_xla_core.py::TestXLACompileCore::test_none_and_empty_inputs[none-identity]
FAILED tests\test_tensorflow_python_compiler_xla_xla_core.py::TestXLACompileCore::test_none_and_empty_inputs[none-multi_input]
5 failed, 1 passed in 2.13s

Error: exit 1