=== Run Tests ===
........F.                                                               [100%]
================================== FAILURES ===================================
_______________________ test_different_mock_func_usage ________________________

custom_class = <class 'test_tensorflow_python_framework_tensor_conversion_registry_g1.custom_class.<locals>.CustomClass'>
different_mock_func = <function different_mock_func.<locals>.conversion_func at 0x0000016DD6F35CA0>
mock_conversion_func = <function mock_conversion_func.<locals>.conversion_func at 0x0000016DD6F4C8B0>

    def test_different_mock_func_usage(custom_class, different_mock_func, mock_conversion_func):
        """Test usage of different_mock_func fixture and additional test branches.
    
        TC-06: 未使用的fixture和测试分支
        Weak asserts: registration_success, function_comparison, priority_handling
        """
        # Test 1: Register different_mock_func and verify it works
        tensor_conversion_registry.register_tensor_conversion_function(
            base_type=custom_class,
            conversion_func=different_mock_func,
            priority=75
        )
    
        # Query for conversion functions
        conversion_funcs = tensor_conversion_registry.get(custom_class)
    
        # Weak assertion 1: registration_success
        assert isinstance(conversion_funcs, list), "Should return a list"
        assert len(conversion_funcs) > 0, "Should have registered function"
    
        # Check that different_mock_func is in the results
        found_different_func = False
        for base_type, func in conversion_funcs:
            if func is different_mock_func:
                found_different_func = True
                break
        assert found_different_func, "different_mock_func should be in query results"
    
        # Test calling the function
        test_value = custom_class()
        result = different_mock_func(test_value, dtype=None, name="test", as_ref=False)
        assert result is not None, "different_mock_func should return a mock object"
        # MagicMock.name returns another Mock object, not a string
        # So we need to check the mock's configuration instead
        assert result._mock_name == "different_func", "Mock should have correct name configuration"
    
        # Test 2: Register multiple functions and verify ordering
        # Clear registry first
        with tensor_conversion_registry._tensor_conversion_func_lock:
            tensor_conversion_registry._tensor_conversion_func_registry.clear()
            tensor_conversion_registry._tensor_conversion_func_cache.clear()
    
        # Register three functions with different priorities
        tensor_conversion_registry.register_tensor_conversion_function(
            base_type=custom_class,
            conversion_func=mock_conversion_func,
            priority=100  # Lowest priority (highest number)
        )
    
        tensor_conversion_registry.register_tensor_conversion_function(
            base_type=custom_class,
            conversion_func=different_mock_func,
            priority=50  # Middle priority
        )
    
        # Register a third function
        def third_mock_func(value, dtype=None, name=None, as_ref=False):
            return mock.MagicMock(name="third_func")
    
        tensor_conversion_registry.register_tensor_conversion_function(
            base_type=custom_class,
            conversion_func=third_mock_func,
            priority=10  # Highest priority (lowest number)
        )
    
        # Get all functions
        all_funcs = tensor_conversion_registry.get(custom_class)
        assert len(all_funcs) == 3, "Should have three registered functions"
    
        # Weak assertion 2: function_comparison
        # Verify all three functions are present
        funcs_found = {
            'mock_conversion_func': False,
            'different_mock_func': False,
            'third_mock_func': False
        }
    
        for base_type, func in all_funcs:
            if func is mock_conversion_func:
                funcs_found['mock_conversion_func'] = True
            elif func is different_mock_func:
                funcs_found['different_mock_func'] = True
            elif func is third_mock_func:
                funcs_found['third_mock_func'] = True
    
        assert all(funcs_found.values()), "All three functions should be found"
    
        # Weak assertion 3: priority_handling
        # Verify order: third_mock_func (10) < different_mock_func (50) < mock_conversion_func (100)
        func_indices = {}
        for i, (base_type, func) in enumerate(all_funcs):
            if func is mock_conversion_func:
                func_indices['mock_conversion_func'] = i
            elif func is different_mock_func:
                func_indices['different_mock_func'] = i
            elif func is third_mock_func:
                func_indices['third_mock_func'] = i
    
        assert func_indices['third_mock_func'] < func_indices['different_mock_func'], \
            "third_mock_func (priority 10) should come before different_mock_func (priority 50)"
        assert func_indices['different_mock_func'] < func_indices['mock_conversion_func'], \
            "different_mock_func (priority 50) should come before mock_conversion_func (priority 100)"
    
        # Test 3: Edge case - same priority, different registration order
        # Clear registry again
        with tensor_conversion_registry._tensor_conversion_func_lock:
            tensor_conversion_registry._tensor_conversion_func_registry.clear()
            tensor_conversion_registry._tensor_conversion_func_cache.clear()
    
        # Register two functions with same priority
        def same_priority_func1(value, dtype=None, name=None, as_ref=False):
            return mock.MagicMock(name="same1")
    
        def same_priority_func2(value, dtype=None, name=None, as_ref=False):
            return mock.MagicMock(name="same2")
    
        tensor_conversion_registry.register_tensor_conversion_function(
            base_type=custom_class,
            conversion_func=same_priority_func1,
            priority=100
        )
    
        tensor_conversion_registry.register_tensor_conversion_function(
            base_type=custom_class,
            conversion_func=same_priority_func2,
            priority=100  # Same priority
        )
    
        same_priority_funcs = tensor_conversion_registry.get(custom_class)
        assert len(same_priority_funcs) == 2, "Should have two functions with same priority"
    
        # Functions with same priority should maintain registration order
        # first registered should come first
        first_func = same_priority_funcs[0][1]
        second_func = same_priority_funcs[1][1]
    
        # Check order (might be same_priority_func1 then same_priority_func2)
        # We can't guarantee which is which by object identity, but we can check
        # that they're different functions
        assert first_func is not second_func, "Should have two different functions"
    
        # Enhanced test for same priority registration order
        def test_same_priority_registration_order():
            """Test that functions with same priority maintain registration order."""
            # Clear registry
            with tensor_conversion_registry._tensor_conversion_func_lock:
                tensor_conversion_registry._tensor_conversion_func_registry.clear()
                tensor_conversion_registry._tensor_conversion_func_cache.clear()
    
            # Create three functions with same priority but different names
            funcs_same_priority = []
            for i in range(3):
                def make_func(idx):
                    def func(value, dtype=None, name=None, as_ref=False):
                        return mock.MagicMock(name=f"same_priority_func_{idx}")
                    return func
    
                funcs_same_priority.append(make_func(i))
    
            # Register them in order 0, 1, 2
            for i, func in enumerate(funcs_same_priority):
                tensor_conversion_registry.register_tensor_conversion_function(
                    base_type=custom_class,
                    conversion_func=func,
                    priority=100  # Same priority for all
                )
    
            # Get all functions
            all_same_priority_funcs = tensor_conversion_registry.get(custom_class)
            assert len(all_same_priority_funcs) == 3, "Should have three functions with same priority"
    
            # Verify registration order is preserved
            # Since we can't easily identify lambda functions by object identity,
            # we'll call them and check the mock names
            registered_order = []
            for _, func in all_same_priority_funcs:
                # Call function to get mock name
                result = func(None, dtype=None, name="test", as_ref=False)
                # MagicMock.name returns another Mock object, check _mock_name instead
                mock_name = result._mock_name
                registered_order.append(mock_name)
    
            # Should be in order: same_priority_func_0, same_priority_func_1, same_priority_func_2
            # Check that all expected names are present
            expected_names = {f"same_priority_func_{i}" for i in range(3)}
            actual_names = set(registered_order)
            assert expected_names == actual_names, f"Expected names {expected_names}, got {actual_names}"
    
            # Test with more complex scenario: mix of same and different priorities
            with tensor_conversion_registry._tensor_conversion_func_lock:
                tensor_conversion_registry._tensor_conversion_func_registry.clear()
                tensor_conversion_registry._tensor_conversion_func_cache.clear()
    
            # Register functions in this order:
            # 1. priority 100, name "A"
            # 2. priority 50, name "B" (higher priority)
            # 3. priority 100, name "C" (same as A)
            # 4. priority 75, name "D"
            # 5. priority 100, name "E" (same as A and C)
    
            func_a = lambda v, d=None, n=None, a=False: mock.MagicMock(name="A")
            func_b = lambda v, d=None, n=None, a=False: mock.MagicMock(name="B")
            func_c = lambda v, d=None, n=None, a=False: mock.MagicMock(name="C")
            func_d = lambda v, d=None, n=None, a=False: mock.MagicMock(name="D")
            func_e = lambda v, d=None, n=None, a=False: mock.MagicMock(name="E")
    
            registration_order = [
                (func_a, 100, "A"),
                (func_b, 50, "B"),
                (func_c, 100, "C"),
                (func_d, 75, "D"),
                (func_e, 100, "E")
            ]
    
            for func, priority, name in registration_order:
                tensor_conversion_registry.register_tensor_conversion_function(
                    base_type=custom_class,
                    conversion_func=func,
                    priority=priority
                )
    
            # Get all functions
            mixed_funcs = tensor_conversion_registry.get(custom_class)
            assert len(mixed_funcs) == 5, "Should have five registered functions"
    
            # Expected order by priority then registration:
            # 1. B (priority 50) - highest priority
            # 2. D (priority 75) - middle priority
            # 3. A (priority 100, registered first)
            # 4. C (priority 100, registered third)
            # 5. E (priority 100, registered fifth)
    
            # Get mock names in order
            actual_order = []
            for _, func in mixed_funcs:
                result = func(None, dtype=None, name="test", as_ref=False)
                # Use _mock_name instead of name
                actual_order.append(result._mock_name)
    
            # Verify B comes first (highest priority)
            assert actual_order[0] == "B", f"B (priority 50) should come first, got {actual_order[0]}"
    
            # Verify D comes second (priority 75)
            assert actual_order[1] == "D", f"D (priority 75) should come second, got {actual_order[1]}"
    
            # Verify A, C, E come last in registration order (all priority 100)
            # They should be in the order they were registered: A, C, E
            priority_100_funcs = actual_order[2:]
            assert priority_100_funcs == ["A", "C", "E"], \
                f"Priority 100 functions should be in registration order A, C, E, got {priority_100_funcs}"
    
            return True
    
        # Run the enhanced same priority test
>       assert test_same_priority_registration_order(), "Same priority registration order test failed"

tests\test_tensorflow_python_framework_tensor_conversion_registry_g1.py:714: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

    def test_same_priority_registration_order():
        """Test that functions with same priority maintain registration order."""
        # Clear registry
        with tensor_conversion_registry._tensor_conversion_func_lock:
            tensor_conversion_registry._tensor_conversion_func_registry.clear()
            tensor_conversion_registry._tensor_conversion_func_cache.clear()
    
        # Create three functions with same priority but different names
        funcs_same_priority = []
        for i in range(3):
            def make_func(idx):
                def func(value, dtype=None, name=None, as_ref=False):
                    return mock.MagicMock(name=f"same_priority_func_{idx}")
                return func
    
            funcs_same_priority.append(make_func(i))
    
        # Register them in order 0, 1, 2
        for i, func in enumerate(funcs_same_priority):
            tensor_conversion_registry.register_tensor_conversion_function(
                base_type=custom_class,
                conversion_func=func,
                priority=100  # Same priority for all
            )
    
        # Get all functions
        all_same_priority_funcs = tensor_conversion_registry.get(custom_class)
        assert len(all_same_priority_funcs) == 3, "Should have three functions with same priority"
    
        # Verify registration order is preserved
        # Since we can't easily identify lambda functions by object identity,
        # we'll call them and check the mock names
        registered_order = []
        for _, func in all_same_priority_funcs:
            # Call function to get mock name
            result = func(None, dtype=None, name="test", as_ref=False)
            # MagicMock.name returns another Mock object, check _mock_name instead
            mock_name = result._mock_name
            registered_order.append(mock_name)
    
        # Should be in order: same_priority_func_0, same_priority_func_1, same_priority_func_2
        # Check that all expected names are present
        expected_names = {f"same_priority_func_{i}" for i in range(3)}
        actual_names = set(registered_order)
        assert expected_names == actual_names, f"Expected names {expected_names}, got {actual_names}"
    
        # Test with more complex scenario: mix of same and different priorities
        with tensor_conversion_registry._tensor_conversion_func_lock:
            tensor_conversion_registry._tensor_conversion_func_registry.clear()
            tensor_conversion_registry._tensor_conversion_func_cache.clear()
    
        # Register functions in this order:
        # 1. priority 100, name "A"
        # 2. priority 50, name "B" (higher priority)
        # 3. priority 100, name "C" (same as A)
        # 4. priority 75, name "D"
        # 5. priority 100, name "E" (same as A and C)
    
        func_a = lambda v, d=None, n=None, a=False: mock.MagicMock(name="A")
        func_b = lambda v, d=None, n=None, a=False: mock.MagicMock(name="B")
        func_c = lambda v, d=None, n=None, a=False: mock.MagicMock(name="C")
        func_d = lambda v, d=None, n=None, a=False: mock.MagicMock(name="D")
        func_e = lambda v, d=None, n=None, a=False: mock.MagicMock(name="E")
    
        registration_order = [
            (func_a, 100, "A"),
            (func_b, 50, "B"),
            (func_c, 100, "C"),
            (func_d, 75, "D"),
            (func_e, 100, "E")
        ]
    
        for func, priority, name in registration_order:
            tensor_conversion_registry.register_tensor_conversion_function(
                base_type=custom_class,
                conversion_func=func,
                priority=priority
            )
    
        # Get all functions
        mixed_funcs = tensor_conversion_registry.get(custom_class)
        assert len(mixed_funcs) == 5, "Should have five registered functions"
    
        # Expected order by priority then registration:
        # 1. B (priority 50) - highest priority
        # 2. D (priority 75) - middle priority
        # 3. A (priority 100, registered first)
        # 4. C (priority 100, registered third)
        # 5. E (priority 100, registered fifth)
    
        # Get mock names in order
        actual_order = []
        for _, func in mixed_funcs:
>           result = func(None, dtype=None, name="test", as_ref=False)
E           TypeError: <lambda>() got an unexpected keyword argument 'dtype'

tests\test_tensorflow_python_framework_tensor_conversion_registry_g1.py:695: TypeError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                                                      Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------------------------------------------------
tests\test_tensorflow_python_framework_tensor_conversion_registry_g1.py     389     71     96     21    77%   144->148, 145->144, 206->220, 215-217, 220->229, 266->271, 267->266, 272->277, 273->272, 313-315, 318->322, 329, 341->345, 342->341, 362->368, 394->398, 398->403, 412, 433-434, 482->486, 483->482, 517, 542->537, 555->550, 571, 574, 697-711, 717-814
---------------------------------------------------------------------------------------------------------------------
TOTAL                                                                       389     71     96     21    77%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_framework_tensor_conversion_registry_g1.py::test_different_mock_func_usage
1 failed, 9 passed in 1.62s

Error: exit 1