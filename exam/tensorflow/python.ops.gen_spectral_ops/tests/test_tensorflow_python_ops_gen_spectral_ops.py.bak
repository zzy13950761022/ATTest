"""
Test cases for tensorflow.python.ops.gen_spectral_ops
Generated by ATTest
"""

import math
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.ops import gen_spectral_ops

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# ==== BLOCK:HEADER START ====
# Helper functions
def create_test_tensor(shape, dtype, complex_input=False):
    """Create test tensor with given shape and dtype."""
    if dtype in (tf.complex64, tf.complex128):
        real_part = tf.random.normal(shape, dtype=tf.float32 if dtype == tf.complex64 else tf.float64)
        imag_part = tf.random.normal(shape, dtype=tf.float32 if dtype == tf.complex64 else tf.float64)
        return tf.complex(real_part, imag_part)
    else:
        return tf.random.normal(shape, dtype=dtype)

def numpy_fft_wrapper(input_tensor, fft_length=None, inverse=False, real=False):
    """Wrapper for numpy FFT functions."""
    numpy_array = input_tensor.numpy()
    
    if real:
        if inverse:
            # IRFFT: complex to real
            return np.fft.irfft(numpy_array, n=fft_length)
        else:
            # RFFT: real to complex
            return np.fft.rfft(numpy_array, n=fft_length)
    else:
        if inverse:
            # IFFT
            return np.fft.ifft(numpy_array)
        else:
            # FFT
            return np.fft.fft(numpy_array)

def assert_tensor_properties(tensor, expected_shape=None, expected_dtype=None, 
                           finite_check=True, name=""):
    """Assert basic tensor properties."""
    if expected_shape is not None:
        assert tensor.shape == expected_shape, f"{name}: shape mismatch: {tensor.shape} != {expected_shape}"
    
    if expected_dtype is not None:
        assert tensor.dtype == expected_dtype, f"{name}: dtype mismatch: {tensor.dtype} != {expected_dtype}"
    
    if finite_check:
        if tensor.dtype in (tf.complex64, tf.complex128):
            # For complex numbers, check both real and imaginary parts
            real_finite = tf.reduce_all(tf.math.is_finite(tf.math.real(tensor)))
            imag_finite = tf.reduce_all(tf.math.is_finite(tf.math.imag(tensor)))
            assert real_finite and imag_finite, f"{name}: tensor contains non-finite values in real or imaginary part"
        else:
            # For real numbers, use standard is_finite
            assert tf.reduce_all(tf.math.is_finite(tensor)), f"{name}: tensor contains non-finite values"

# Tolerance constants
FLOAT32_TOL = 1e-6
FLOAT64_TOL = 1e-12
COMPLEX64_TOL = 1e-6
COMPLEX128_TOL = 1e-12
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
@pytest.mark.parametrize("dtype,shape,function_name", [
    (tf.complex64, [8], "fft"),
    (tf.complex128, [16], "fft"),  # param extension: extended_precision
    (tf.complex64, [8], "ifft"),   # param extension: inverse_transform
])
def test_basic_fft_transform(dtype, shape, function_name):
    """Test basic FFT/IFFT transform correctness."""
    # Create test input
    input_tensor = create_test_tensor(shape, dtype)
    
    # Get the function from gen_spectral_ops
    if function_name == "fft":
        tf_func = gen_spectral_ops.fft
        inverse = False
    elif function_name == "ifft":
        tf_func = gen_spectral_ops.ifft
        inverse = True
    else:
        pytest.fail(f"Unknown function: {function_name}")
    
    # Apply TensorFlow FFT
    tf_result = tf_func(input_tensor)
    
    # Apply numpy FFT for comparison
    numpy_result = numpy_fft_wrapper(input_tensor, inverse=inverse)
    
    # Weak assertions (round 1)
    # 1. Shape assertion
    assert tf_result.shape == input_tensor.shape, \
        f"Shape mismatch: {tf_result.shape} != {input_tensor.shape}"
    
    # 2. Dtype assertion
    assert tf_result.dtype == dtype, \
        f"Dtype mismatch: {tf_result.dtype} != {dtype}"
    
    # 3. Finite check - handle complex types properly
    if dtype in (tf.complex64, tf.complex128):
        # For complex numbers, check both real and imaginary parts
        real_finite = tf.reduce_all(tf.math.is_finite(tf.math.real(tf_result)))
        imag_finite = tf.reduce_all(tf.math.is_finite(tf.math.imag(tf_result)))
        assert real_finite and imag_finite, \
            "Result contains non-finite values in real or imaginary part"
    else:
        # For real numbers, use standard is_finite
        assert tf.reduce_all(tf.math.is_finite(tf_result)), \
            "Result contains non-finite values"
    
    # 4. Basic property: magnitude preservation (Parseval's theorem)
    input_energy = tf.reduce_sum(tf.abs(input_tensor) ** 2)
    result_energy = tf.reduce_sum(tf.abs(tf_result) ** 2)
    
    # For FFT, energy should be scaled by N
    if not inverse:
        expected_energy = input_energy * shape[-1]
    else:
        expected_energy = input_energy / shape[-1]
    
    # Use appropriate tolerance based on dtype
    if dtype in (tf.complex64, tf.float32):
        tol = FLOAT32_TOL
    else:
        tol = FLOAT64_TOL
    
    assert tf.abs(result_energy - expected_energy) < tol * tf.abs(expected_energy), \
        f"Energy not preserved: {result_energy} != {expected_energy}"
    
    print(f"✓ {function_name} test passed for dtype={dtype}, shape={shape}")
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
@pytest.mark.parametrize("dtype,shape,fft_length,function_name", [
    (tf.float32, [16], 8, "rfft"),
    (tf.complex64, [9], 16, "irfft"),  # param extension: odd_length, inverse_real
])
def test_real_fft_with_length_control(dtype, shape, fft_length, function_name):
    """Test RFFT/IRFFT real transforms with length control."""
    # Create test input
    if function_name == "rfft":
        # RFFT expects real input
        input_tensor = create_test_tensor(shape, dtype, complex_input=False)
        tf_func = gen_spectral_ops.rfft
        inverse = False
        real_transform = True
    elif function_name == "irfft":
        # IRFFT expects complex input
        input_tensor = create_test_tensor(shape, tf.complex64, complex_input=True)
        tf_func = gen_spectral_ops.irfft
        inverse = True
        real_transform = True
    else:
        pytest.fail(f"Unknown function: {function_name}")
    
    # Create fft_length as a tensor with shape [1]
    fft_length_tensor = tf.constant([fft_length], dtype=tf.int32)
    
    # Apply TensorFlow RFFT/IRFFT
    tf_result = tf_func(input_tensor, fft_length=fft_length_tensor)
    
    # Apply numpy RFFT/IRFFT for comparison
    numpy_result = numpy_fft_wrapper(
        input_tensor, 
        fft_length=fft_length, 
        inverse=inverse, 
        real=True
    )
    
    # Weak assertions (round 1)
    # 1. Shape assertion
    if function_name == "rfft":
        expected_shape = list(shape)
        expected_shape[-1] = fft_length // 2 + 1
        expected_shape = tuple(expected_shape)
    else:  # irfft
        expected_shape = list(shape)
        expected_shape[-1] = fft_length
        expected_shape = tuple(expected_shape)
    
    assert tf_result.shape == expected_shape, \
        f"Shape mismatch: {tf_result.shape} != {expected_shape}"
    
    # 2. Dtype assertion
    if function_name == "rfft":
        expected_dtype = tf.complex64 if dtype == tf.float32 else tf.complex128
    else:  # irfft
        expected_dtype = tf.float32
    
    assert tf_result.dtype == expected_dtype, \
        f"Dtype mismatch: {tf_result.dtype} != {expected_dtype}"
    
    # 3. Finite check
    if expected_dtype in (tf.complex64, tf.complex128):
        # For complex numbers, check both real and imaginary parts
        real_finite = tf.reduce_all(tf.math.is_finite(tf.math.real(tf_result)))
        imag_finite = tf.reduce_all(tf.math.is_finite(tf.math.imag(tf_result)))
        assert real_finite and imag_finite, \
            "Result contains non-finite values in real or imaginary part"
    else:
        # For real numbers, use standard is_finite
        assert tf.reduce_all(tf.math.is_finite(tf_result)), \
            "Result contains non-finite values"
    
    # 4. Length control assertion
    if function_name == "rfft":
        # For RFFT, output length should be fft_length//2 + 1
        assert tf_result.shape[-1] == fft_length // 2 + 1, \
            f"RFFT output length incorrect: {tf_result.shape[-1]} != {fft_length // 2 + 1}"
    else:  # irfft
        # For IRFFT, output length should be fft_length
        assert tf_result.shape[-1] == fft_length, \
            f"IRFFT output length incorrect: {tf_result.shape[-1]} != {fft_length}"
    
    # 5. Hermitian symmetry check for RFFT
    if function_name == "rfft":
        # RFFT of real input should have Hermitian symmetry
        # (excluding DC and Nyquist components for even length)
        result_np = tf_result.numpy()
        
        if fft_length % 2 == 0:  # Even length
            # Check symmetry for k = 1 to N/2-1
            for k in range(1, fft_length // 2):
                conj_idx = fft_length - k
                if conj_idx < result_np.shape[-1]:
                    val1 = result_np[..., k]
                    val2 = np.conj(result_np[..., conj_idx])
                    diff = np.abs(val1 - val2)
                    assert np.all(diff < FLOAT32_TOL), \
                        f"Hermitian symmetry violated at k={k}"
    
    print(f"✓ {function_name} test passed for dtype={dtype}, shape={shape}, fft_length={fft_length}")
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_03 START ====
@pytest.mark.parametrize("dtype,shape,function_name", [
    (tf.complex64, [4, 8], "batch_fft"),
    (tf.complex64, [3, 8, 8], "batch_fft2d"),  # param extension: 2d_transform, batch_dimension
])
def test_batch_fft_dimension_preservation(dtype, shape, function_name):
    """Test batch FFT dimension preservation using batch_fft/batch_fft2d."""
    # Create test input - batch_fft/batch_fft2d support complex64
    input_tensor = create_test_tensor(shape, dtype)
    
    # Get the function from gen_spectral_ops
    if function_name == "batch_fft":
        tf_func = gen_spectral_ops.batch_fft
        # batch_fft applies FFT to the last dimension
        dims = 1
    elif function_name == "batch_fft2d":
        tf_func = gen_spectral_ops.batch_fft2d
        # batch_fft2d applies FFT to the last 2 dimensions
        dims = 2
    else:
        pytest.fail(f"Unknown function: {function_name}")
    
    # Apply TensorFlow batch FFT
    tf_result = tf_func(input_tensor)
    
    # Weak assertions (round 1)
    # 1. Shape assertion - all dimensions should be preserved
    assert tf_result.shape == input_tensor.shape, \
        f"Shape mismatch: {tf_result.shape} != {input_tensor.shape}"
    
    # 2. Dtype assertion - should preserve input dtype
    assert tf_result.dtype == dtype, \
        f"Dtype mismatch: {tf_result.dtype} != {dtype}"
    
    # 3. Finite check for complex numbers
    real_finite = tf.reduce_all(tf.math.is_finite(tf.math.real(tf_result)))
    imag_finite = tf.reduce_all(tf.math.is_finite(tf.math.imag(tf_result)))
    assert real_finite and imag_finite, \
        "Result contains non-finite values in real or imaginary part"
    
    # 4. Batch dimension preservation
    # Check that batch dimensions (all except last 'dims') are preserved
    batch_dims = len(shape) - dims
    if batch_dims > 0:
        # Compare batch dimensions
        for i in range(batch_dims):
            assert tf_result.shape[i] == shape[i], \
                f"Batch dimension {i} not preserved: {tf_result.shape[i]} != {shape[i]}"
    
    # 5. Basic property: FFT should be linear
    # Test linearity: FFT(a*x + b*y) = a*FFT(x) + b*FFT(y)
    # Create two random tensors
    x = create_test_tensor(shape, dtype)
    y = create_test_tensor(shape, dtype)
    
    # Random scalars
    if dtype == tf.complex64:
        scalar_dtype = tf.float32
    else:  # complex128
        scalar_dtype = tf.float64
    
    a = tf.complex(tf.random.normal([], dtype=scalar_dtype), 
                   tf.random.normal([], dtype=scalar_dtype))
    b = tf.complex(tf.random.normal([], dtype=scalar_dtype), 
                   tf.random.normal([], dtype=scalar_dtype))
    
    # Linearity test
    linear_combination = a * x + b * y
    fft_linear = tf_func(linear_combination)
    
    fft_x = tf_func(x)
    fft_y = tf_func(y)
    expected_fft_linear = a * fft_x + b * fft_y
    
    # Check linearity with tolerance
    diff = tf.abs(fft_linear - expected_fft_linear)
    max_diff = tf.reduce_max(diff)
    
    # Use appropriate tolerance based on dtype
    # For complex64, use 1e-5 tolerance for linearity test (more lenient)
    # For complex128, use 1e-10 tolerance
    if dtype == tf.complex64:
        tolerance = 1e-5  # Increased from 1e-6 to 1e-5 for linearity test
    else:  # complex128
        tolerance = 1e-10
    
    assert max_diff < tolerance, \
        f"Linearity property violated: max diff = {max_diff}, tolerance = {tolerance}"
    
    print(f"✓ {function_name} test passed for shape={shape}, dtype={dtype}")
# ==== BLOCK:CASE_03 END ====

# ==== BLOCK:CASE_04 START ====
@pytest.mark.parametrize("dtype,shape,function_name", [
    (tf.float64, [8], "fft"),
])
def test_data_type_boundary_verification(dtype, shape, function_name):
    """Test data type boundary verification using fft with float64."""
    # Create test input - fft supports complex64 and complex128
    # For float64 input, we need to convert to complex128
    real_input = tf.random.normal(shape, dtype=dtype)
    # Create complex input from real input (add zero imaginary part)
    complex_dtype = tf.complex128 if dtype == tf.float64 else tf.complex64
    input_tensor = tf.complex(real_input, tf.zeros_like(real_input))
    
    # Get the function from gen_spectral_ops
    tf_func = gen_spectral_ops.fft
    
    # Apply TensorFlow FFT
    tf_result = tf_func(input_tensor)
    
    # Weak assertions (round 1)
    # 1. Shape assertion - all dimensions should be preserved
    assert tf_result.shape == input_tensor.shape, \
        f"Shape mismatch: {tf_result.shape} != {input_tensor.shape}"
    
    # 2. Dtype assertion - should preserve input dtype
    assert tf_result.dtype == complex_dtype, \
        f"Dtype mismatch: {tf_result.dtype} != {complex_dtype}"
    
    # 3. Finite check for complex numbers
    real_finite = tf.reduce_all(tf.math.is_finite(tf.math.real(tf_result)))
    imag_finite = tf.reduce_all(tf.math.is_finite(tf.math.imag(tf_result)))
    assert real_finite and imag_finite, \
        "Result contains non-finite values in real or imaginary part"
    
    # 4. Precision bound check - verify higher precision gives reasonable results
    # Compare with numpy FFT as oracle
    numpy_result = np.fft.fft(input_tensor.numpy())
    
    # Calculate relative error
    tf_numpy_diff = tf.abs(tf_result - tf.constant(numpy_result, dtype=complex_dtype))
    tf_numpy_abs = tf.abs(tf_result)
    
    # Avoid division by zero
    safe_denominator = tf.where(tf_numpy_abs > 0, tf_numpy_abs, tf.ones_like(tf_numpy_abs))
    relative_error = tf_numpy_diff / safe_denominator
    
    max_relative_error = tf.reduce_max(relative_error)
    
    # For float64/complex128, expect higher precision
    if dtype == tf.float64:
        tolerance = 1e-12  # Higher precision tolerance for float64
    else:
        tolerance = 1e-6   # Standard tolerance for float32
    
    assert max_relative_error < tolerance, \
        f"Precision bound exceeded: max relative error = {max_relative_error}, tolerance = {tolerance}"
    
    print(f"✓ {function_name} test passed for shape={shape}, dtype={dtype}")
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
@pytest.mark.parametrize("dtype,shape,fft_length", [
    (tf.float32, [10], 16),
])
def test_fft_length_padding_behavior(dtype, shape, fft_length):
    """Test fft_length padding behavior using rfft."""
    # Create test input - rfft supports float32 and float64
    input_tensor = tf.random.normal(shape, dtype=dtype)
    
    # Get the function from gen_spectral_ops
    tf_func = gen_spectral_ops.rfft
    
    # Apply TensorFlow RFFT with fft_length as a tensor with shape [1]
    # fft_length must be a tensor of shape [1], not a scalar
    fft_length_tensor = tf.constant([fft_length], dtype=tf.int32)
    tf_result = tf_func(input_tensor, fft_length=fft_length_tensor)
    
    # Weak assertions (round 1)
    # 1. Shape assertion - rfft output shape should be [..., fft_length//2 + 1]
    expected_shape = list(shape)
    expected_shape[-1] = fft_length // 2 + 1
    expected_shape = tuple(expected_shape)
    
    assert tf_result.shape == expected_shape, \
        f"Shape mismatch: {tf_result.shape} != {expected_shape}"
    
    # 2. Dtype assertion - rfft returns complex64 for float32 input
    expected_dtype = tf.complex64 if dtype == tf.float32 else tf.complex128
    assert tf_result.dtype == expected_dtype, \
        f"Dtype mismatch: {tf_result.dtype} != {expected_dtype}"
    
    # 3. Finite check for complex numbers
    real_finite = tf.reduce_all(tf.math.is_finite(tf.math.real(tf_result)))
    imag_finite = tf.reduce_all(tf.math.is_finite(tf.math.imag(tf_result)))
    assert real_finite and imag_finite, \
        "Result contains non-finite values in real or imaginary part"
    
    # 4. Length control check - verify fft_length parameter works correctly
    # Compare with numpy RFFT as oracle
    numpy_result = np.fft.rfft(input_tensor.numpy(), n=fft_length)
    
    # Calculate relative error
    tf_numpy_diff = tf.abs(tf_result - tf.constant(numpy_result, dtype=expected_dtype))
    tf_numpy_abs = tf.abs(tf_result)
    
    # Avoid division by zero
    safe_denominator = tf.where(tf_numpy_abs > 0, tf_numpy_abs, tf.ones_like(tf_numpy_abs))
    relative_error = tf_numpy_diff / safe_denominator
    
    max_relative_error = tf.reduce_max(relative_error)
    
    # Tolerance for float32/complex64
    tolerance = 1e-6
    
    assert max_relative_error < tolerance, \
        f"Length control verification failed: max relative error = {max_relative_error}, tolerance = {tolerance}"
    
    # 5. Padding behavior check - verify that padding with zeros doesn't affect first part
    # For input length 10 and fft_length 16, first 10 elements should match non-padded RFFT
    numpy_result_no_padding = np.fft.rfft(input_tensor.numpy())
    
    # Compare first min(shape[-1], fft_length//2+1) elements
    compare_length = min(shape[-1] // 2 + 1, fft_length // 2 + 1)
    
    tf_first_part = tf_result[..., :compare_length]
    numpy_first_part = numpy_result_no_padding[..., :compare_length]
    
    diff_first_part = tf.abs(tf_first_part - tf.constant(numpy_first_part, dtype=expected_dtype))
    max_diff_first_part = tf.reduce_max(diff_first_part)
    
    assert max_diff_first_part < tolerance, \
        f"Padding behavior check failed: max diff in first part = {max_diff_first_part}, tolerance = {tolerance}"
    
    print(f"✓ rfft test passed for shape={shape}, dtype={dtype}, fft_length={fft_length}")
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:FOOTER START ====
# Additional helper tests for edge cases

def test_invalid_inputs():
    """Test invalid inputs raise appropriate errors."""
    # Test 1: Non-numeric input - use a Python object that can't be converted to tensor
    with pytest.raises((TypeError, ValueError)):
        # Pass a Python object that can't be converted to tensor
        gen_spectral_ops.fft(object())
    
    # Test 2: Invalid dtype (int32 instead of complex)
    with pytest.raises((TypeError, tf.errors.InvalidArgumentError)):
        invalid_tensor = tf.constant([1, 2, 3], dtype=tf.int32)
        gen_spectral_ops.fft(invalid_tensor)
    
    # Test 3: Invalid fft_length for RFFT (negative value)
    with pytest.raises((ValueError, tf.errors.InvalidArgumentError)):
        real_tensor = tf.random.normal([8], dtype=tf.float32)
        # fft_length needs to be a tensor with shape [1]
        invalid_fft_length = tf.constant([-1], dtype=tf.int32)
        gen_spectral_ops.rfft(real_tensor, fft_length=invalid_fft_length)
    
    # Test 4: Complex input for RFFT (RFFT expects real input)
    with pytest.raises((ValueError, tf.errors.InvalidArgumentError)):
        complex_tensor = tf.complex(
            tf.random.normal([8], dtype=tf.float32),
            tf.random.normal([8], dtype=tf.float32)
        )
        fft_length_tensor = tf.constant([8], dtype=tf.int32)
        gen_spectral_ops.rfft(complex_tensor, fft_length=fft_length_tensor)
    
    # Test 5: Zero fft_length
    with pytest.raises((ValueError, tf.errors.InvalidArgumentError)):
        real_tensor = tf.random.normal([8], dtype=tf.float32)
        zero_fft_length = tf.constant([0], dtype=tf.int32)
        gen_spectral_ops.rfft(real_tensor, fft_length=zero_fft_length)

def test_edge_cases():
    """Test edge cases like small sizes and special values."""
    # Test 1: Minimum valid size (1)
    small_tensor = tf.constant([1.0 + 2.0j], dtype=tf.complex64)
    result = gen_spectral_ops.fft(small_tensor)
    assert result.shape == (1,)
    assert result.dtype == tf.complex64
    # FFT of single element should be the element itself
    assert tf.abs(result[0] - small_tensor[0]) < FLOAT32_TOL
    
    # Test 2: All zeros
    zero_tensor = tf.zeros([8], dtype=tf.complex64)
    result = gen_spectral_ops.fft(zero_tensor)
    assert tf.reduce_all(tf.abs(result) < FLOAT32_TOL)
    
    # Test 3: DC component only
    dc_tensor = tf.ones([8], dtype=tf.complex64)
    result = gen_spectral_ops.fft(dc_tensor)
    # FFT of all ones should be impulse at DC
    assert tf.abs(result[0] - 8.0) < FLOAT32_TOL  # DC component
    for i in range(1, 8):
        assert tf.abs(result[i]) < FLOAT32_TOL  # Other components should be zero

if __name__ == "__main__":
    # Simple test runner for debugging
    import sys
    pytest.main([__file__, "-v"])
# ==== BLOCK:FOOTER END ====