"""
Test for tensorflow.python.ops.stateful_random_ops module.
Generated by TestAgent.
"""

import math
import numpy as np
import pytest
import tensorflow as tf
from tensorflow.python.ops import stateful_random_ops

# ==== BLOCK:HEADER START ====
# Test fixtures and helper functions
@pytest.fixture
def tf_session():
    """Ensure TensorFlow session is properly initialized."""
    # TensorFlow 2.x uses eager execution by default
    return None

def assert_tensor_equal(t1, t2, rtol=1e-5, atol=1e-8):
    """Assert two tensors are equal within tolerance."""
    if hasattr(t1, 'numpy'):
        t1 = t1.numpy()
    if hasattr(t2, 'numpy'):
        t2 = t2.numpy()
    np.testing.assert_allclose(t1, t2, rtol=rtol, atol=atol)

def assert_tensor_shape(tensor, expected_shape):
    """Assert tensor has expected shape."""
    if hasattr(tensor, 'shape'):
        shape = tensor.shape
    else:
        shape = np.array(tensor).shape
    assert shape == tuple(expected_shape), f"Expected shape {expected_shape}, got {shape}"

def assert_tensor_dtype(tensor, expected_dtype):
    """Assert tensor has expected dtype."""
    if hasattr(tensor, 'dtype'):
        dtype = tensor.dtype
    else:
        dtype = type(tensor)
    if isinstance(expected_dtype, str):
        expected_dtype = getattr(tf, expected_dtype)
    assert dtype == expected_dtype, f"Expected dtype {expected_dtype}, got {dtype}"
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
@pytest.mark.parametrize("seed,alg,shape,dtype,device", [
    (1234, stateful_random_ops.RNG_ALG_PHILOX, [2, 3], tf.float32, "cpu"),
])
def test_generator_from_seed_basic(seed, alg, shape, dtype, device):
    """TC-01: Generator.from_seed 基本功能 (weak assertions)"""
    # Skip if device not available
    if device == "gpu" and not tf.config.list_physical_devices('GPU'):
        pytest.skip("GPU not available")
    
    # Create generator from seed
    generator = tf.random.Generator.from_seed(seed=seed, alg=alg)
    
    # Weak assertion: generator_created
    assert generator is not None, "Generator should be created"
    assert isinstance(generator, tf.random.Generator), "Should be a Generator instance"
    
    # Weak assertion: state_exists
    state = generator.state
    assert state is not None, "Generator should have state"
    assert hasattr(state, 'numpy'), "State should be a TensorFlow variable"
    
    # Generate random numbers
    random_output = generator.normal(shape=shape, dtype=dtype)
    
    # Weak assertion: output_shape
    assert_tensor_shape(random_output, shape)
    
    # Weak assertion: output_dtype
    assert_tensor_dtype(random_output, dtype)
    
    # Weak assertion: finite_values
    random_numpy = random_output.numpy()
    assert np.all(np.isfinite(random_numpy)), "All random values should be finite"
    
    # Additional basic checks
    assert random_numpy.size == np.prod(shape), f"Expected {np.prod(shape)} elements, got {random_numpy.size}"
    
    # Check state shape is correct for algorithm
    state_value = state.numpy()
    if alg == stateful_random_ops.RNG_ALG_PHILOX:
        expected_state_size = stateful_random_ops.PHILOX_STATE_SIZE
    else:  # RNG_ALG_THREEFRY
        expected_state_size = stateful_random_ops.THREEFRY_STATE_SIZE
    assert len(state_value) == expected_state_size, \
        f"State should have {expected_state_size} elements for algorithm {alg}"
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
@pytest.mark.parametrize("seed,alg,shape,dtype,device", [
    (5678, stateful_random_ops.RNG_ALG_PHILOX, [3, 2], tf.float64, "cpu"),
])
def test_same_seed_same_sequence(seed, alg, shape, dtype, device):
    """TC-02: 相同种子产生相同序列 (weak assertions)"""
    # Skip if device not available
    if device == "gpu" and not tf.config.list_physical_devices('GPU'):
        pytest.skip("GPU not available")
    
    # Create two generators with same seed
    generator1 = tf.random.Generator.from_seed(seed=seed, alg=alg)
    generator2 = tf.random.Generator.from_seed(seed=seed, alg=alg)
    
    # Weak assertion: same_seed_same_output
    # Generate same number of random values from both generators
    output1 = generator1.normal(shape=shape, dtype=dtype)
    output2 = generator2.normal(shape=shape, dtype=dtype)
    
    # Check they produce the same output
    assert_tensor_equal(output1, output2, rtol=1e-5, atol=1e-8)
    
    # Weak assertion: different_seed_different_output
    # Create third generator with different seed
    generator3 = tf.random.Generator.from_seed(seed=seed + 1, alg=alg)
    output3 = generator3.normal(shape=shape, dtype=dtype)
    
    # Check it produces different output (very low probability of collision)
    output1_np = output1.numpy()
    output3_np = output3.numpy()
    assert not np.allclose(output1_np, output3_np, rtol=1e-5, atol=1e-8), \
        "Different seeds should produce different random sequences"
    
    # Weak assertion: sequence_reproducible
    # Reset generator1 and generate sequence again
    generator1_reset = tf.random.Generator.from_seed(seed=seed, alg=alg)
    output1_again = generator1_reset.normal(shape=shape, dtype=dtype)
    
    # Should get same result as before
    assert_tensor_equal(output1, output1_again, rtol=1e-5, atol=1e-8)
    
    # Additional check: state should also be same after same operations
    state1 = generator1.state.numpy()
    state2 = generator2.state.numpy()
    state1_reset = generator1_reset.state.numpy()
    
    # After same operations, states should match
    np.testing.assert_array_equal(state1, state2)
    np.testing.assert_array_equal(state1, state1_reset)
    
    # Different seed should have different initial state
    state3 = generator3.state.numpy()
    assert not np.array_equal(state1, state3), \
        "Different seeds should result in different initial states"
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_03 START ====
@pytest.mark.parametrize("seed,alg,shape,dtype,device", [
    (9999, stateful_random_ops.RNG_ALG_PHILOX, [4], tf.float32, "cpu"),
])
def test_state_update_verification(seed, alg, shape, dtype, device):
    """TC-03: 状态更新验证 (weak assertions)"""
    # Skip if device not available
    if device == "gpu" and not tf.config.list_physical_devices('GPU'):
        pytest.skip("GPU not available")
    
    # Create generator
    generator = tf.random.Generator.from_seed(seed=seed, alg=alg)
    
    # Get initial state
    initial_state = generator.state.numpy().copy()
    
    # Weak assertion: state_not_none
    assert initial_state is not None, "Initial state should not be None"
    
    # Weak assertion: state_shape_correct
    if alg == stateful_random_ops.RNG_ALG_PHILOX:
        expected_state_size = stateful_random_ops.PHILOX_STATE_SIZE
    else:  # RNG_ALG_THREEFRY
        expected_state_size = stateful_random_ops.THREEFRY_STATE_SIZE
    assert len(initial_state) == expected_state_size, \
        f"State should have {expected_state_size} elements for algorithm {alg}"
    
    # Weak assertion: state_dtype_int64
    state_var = generator.state
    assert state_var.dtype == tf.int64, f"State should be int64, got {state_var.dtype}"
    
    # Generate random numbers
    random_output = generator.normal(shape=shape, dtype=dtype)
    
    # Get state after generation
    state_after = generator.state.numpy().copy()
    
    # Weak assertion: state_changes_after_call
    assert not np.array_equal(initial_state, state_after), \
        "State should change after generating random numbers"
    
    # Additional checks
    assert random_output is not None, "Random output should be generated"
    assert_tensor_shape(random_output, shape)
    assert_tensor_dtype(random_output, dtype)
    
    # Generate more random numbers and check state changes again
    state_before_second = state_after.copy()
    random_output2 = generator.normal(shape=shape, dtype=dtype)
    state_after_second = generator.state.numpy().copy()
    
    assert not np.array_equal(state_before_second, state_after_second), \
        "State should change after second random generation"
    
    # Verify outputs are different (very low probability of collision)
    output1_np = random_output.numpy()
    output2_np = random_output2.numpy()
    assert not np.allclose(output1_np, output2_np, rtol=1e-5, atol=1e-8), \
        "Consecutive random generations should produce different values"
    
    # Check state dtype consistency
    assert state_after.dtype == np.int64, f"State should be int64, got {state_after.dtype}"
    assert state_after_second.dtype == np.int64, f"State should be int64, got {state_after_second.dtype}"
    
    # Verify state values are within reasonable bounds
    assert np.all(np.abs(initial_state) < 2**63), "State values should be within int64 range"
    assert np.all(np.abs(state_after) < 2**63), "State values should be within int64 range"
    assert np.all(np.abs(state_after_second) < 2**63), "State values should be within int64 range"
# ==== BLOCK:CASE_03 END ====

# ==== BLOCK:CASE_04 START ====
@pytest.mark.parametrize("seed,alg,shape,dtype,device", [
    (1111, stateful_random_ops.RNG_ALG_PHILOX, [2, 2], tf.float32, "cpu"),
    (2222, stateful_random_ops.RNG_ALG_THREEFRY, [6], tf.float32, "cpu"),
])
def test_two_algorithms_basic_functionality(seed, alg, shape, dtype, device):
    """TC-04: 两种算法基本功能 (weak assertions)"""
    # Skip if device not available
    if device == "gpu" and not tf.config.list_physical_devices('GPU'):
        pytest.skip("GPU not available")
    
    # Check if THREEFRY algorithm is supported in current TensorFlow version
    # Some TensorFlow versions/builds may not support THREEFRY
    if alg == stateful_random_ops.RNG_ALG_THREEFRY:
        try:
            # Test if THREEFRY can be created
            test_gen = tf.random.Generator.from_seed(seed=seed, alg=alg)
            # If creation succeeds, test if it can generate numbers
            test_output = test_gen.normal(shape=[1], dtype=tf.float32)
        except (ValueError, tf.errors.InvalidArgumentError, tf.errors.UnimplementedError) as e:
            # THREEFRY not supported in this version
            pytest.skip(f"THREEFRY algorithm not supported in this TensorFlow version: {e}")
    
    # Weak assertion: algorithm_parameter_accepted
    # Create generator with specified algorithm
    generator = tf.random.Generator.from_seed(seed=seed, alg=alg)
    
    # Check generator created successfully
    assert generator is not None, "Generator should be created"
    assert isinstance(generator, tf.random.Generator), "Should be a Generator instance"
    
    # Weak assertion: philox_works / threefry_works
    # Verify algorithm-specific constants
    if alg == stateful_random_ops.RNG_ALG_PHILOX:
        # Check PHILOX algorithm works
        assert alg == stateful_random_ops.RNG_ALG_PHILOX, "Should be PHILOX algorithm"
        expected_state_size = stateful_random_ops.PHILOX_STATE_SIZE
    else:  # RNG_ALG_THREEFRY
        # Check THREEFRY algorithm works
        assert alg == stateful_random_ops.RNG_ALG_THREEFRY, "Should be THREEFRY algorithm"
        expected_state_size = stateful_random_ops.THREEFRY_STATE_SIZE
    
    # Check state size matches algorithm
    state = generator.state
    state_value = state.numpy()
    assert len(state_value) == expected_state_size, \
        f"State should have {expected_state_size} elements for algorithm {alg}"
    
    # Weak assertion: output_valid
    # Generate random numbers
    random_output = generator.normal(shape=shape, dtype=dtype)
    
    # Check output properties
    assert random_output is not None, "Random output should be generated"
    assert_tensor_shape(random_output, shape)
    assert_tensor_dtype(random_output, dtype)
    
    # Check values are finite
    random_numpy = random_output.numpy()
    assert np.all(np.isfinite(random_numpy)), "All random values should be finite"
    
    # Additional algorithm-specific checks
    # Check state dtype
    assert state.dtype == tf.int64, f"State should be int64, got {state.dtype}"
    
    # Check state values are within reasonable bounds
    assert np.all(np.abs(state_value) < 2**63), "State values should be within int64 range"
    
    # Generate more random numbers to verify algorithm continues to work
    random_output2 = generator.normal(shape=shape, dtype=dtype)
    assert_tensor_shape(random_output2, shape)
    assert_tensor_dtype(random_output2, dtype)
    
    # Verify outputs are different (very low probability of collision)
    output1_np = random_output.numpy()
    output2_np = random_output2.numpy()
    assert not np.allclose(output1_np, output2_np, rtol=1e-5, atol=1e-8), \
        "Consecutive random generations should produce different values"
    
    # Check state updated after generation
    state_after = generator.state.numpy()
    assert not np.array_equal(state_value, state_after), \
        "State should change after generating random numbers"
    
    # Verify algorithm constants are accessible
    assert hasattr(stateful_random_ops, 'RNG_ALG_PHILOX'), "PHILOX constant should be available"
    assert hasattr(stateful_random_ops, 'RNG_ALG_THREEFRY'), "THREEFRY constant should be available"
    assert hasattr(stateful_random_ops, 'PHILOX_STATE_SIZE'), "PHILOX_STATE_SIZE should be available"
    assert hasattr(stateful_random_ops, 'THREEFRY_STATE_SIZE'), "THREEFRY_STATE_SIZE should be available"
    
    # Verify DEFAULT_ALGORITHM is defined
    assert hasattr(stateful_random_ops, 'DEFAULT_ALGORITHM'), "DEFAULT_ALGORITHM should be available"
    
    # Check that algorithm values are different
    assert stateful_random_ops.RNG_ALG_PHILOX != stateful_random_ops.RNG_ALG_THREEFRY, \
        "PHILOX and THREEFRY should have different algorithm values"
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
@pytest.mark.parametrize("invalid_alg,invalid_shape,invalid_dtype,device", [
    (99, [-1, 2], "invalid_type", "cpu"),
    ("invalid_string", [0, 0], "complex128", "cpu"),
])
def test_error_input_triggers_exceptions(invalid_alg, invalid_shape, invalid_dtype, device):
    """TC-05: 错误输入触发异常 (weak assertions)"""
    # Skip if device not available
    if device == "gpu" and not tf.config.list_physical_devices('GPU'):
        pytest.skip("GPU not available")
    
    # Test 1: Invalid algorithm should raise exception
    # Weak assertion: invalid_alg_raises
    # Accept broader exception types since different TensorFlow versions may raise different exceptions
    with pytest.raises((ValueError, TypeError, tf.errors.InvalidArgumentError, 
                       tf.errors.UnimplementedError, tf.errors.NotFoundError)) as exc_info:
        tf.random.Generator.from_seed(seed=1234, alg=invalid_alg)
    
    # Weak assertion: exception_type_correct
    # Check that an exception was raised
    assert exc_info.value is not None, "Should raise exception for invalid algorithm"
    
    # Test 2: Invalid shape should raise exception
    # Weak assertion: invalid_shape_raises
    # First create a valid generator
    valid_generator = tf.random.Generator.from_seed(seed=1234, alg=stateful_random_ops.RNG_ALG_PHILOX)
    
    with pytest.raises((ValueError, TypeError, tf.errors.InvalidArgumentError,
                       tf.errors.UnimplementedError)) as exc_info:
        # Try to generate random numbers with invalid shape
        valid_generator.normal(shape=invalid_shape, dtype=tf.float32)
    
    # Check that an exception was raised
    assert exc_info.value is not None, "Should raise exception for invalid shape"
    
    # Test 3: Invalid dtype should raise exception
    # Weak assertion: invalid_dtype_raises
    # Try different approaches for invalid dtype
    if invalid_dtype == "invalid_type":
        # Pass a string that's not a valid dtype
        with pytest.raises((ValueError, TypeError, tf.errors.InvalidArgumentError,
                           tf.errors.UnimplementedError)) as exc_info:
            valid_generator.normal(shape=[2, 2], dtype=invalid_dtype)
    elif invalid_dtype == "complex128":
        # Complex dtype might not be supported for normal distribution
        # Some versions may raise different exceptions
        with pytest.raises((ValueError, TypeError, tf.errors.InvalidArgumentError,
                           tf.errors.UnimplementedError, tf.errors.NotFoundError)) as exc_info:
            valid_generator.normal(shape=[2, 2], dtype=tf.complex128)
    
    # Check that an exception was raised
    assert exc_info.value is not None, "Should raise exception for invalid dtype"
    
    # Additional error case tests
    
    # Test 4: Invalid seed type - handle different TensorFlow versions
    # Some versions may accept string seeds, others may not
    try:
        # Try to create generator with string seed
        tf.random.Generator.from_seed(seed="invalid_seed", alg=stateful_random_ops.RNG_ALG_PHILOX)
        # If no exception, it means this version accepts string seeds
        # This is acceptable behavior
        string_seed_accepted = True
    except (ValueError, TypeError, tf.errors.InvalidArgumentError,
            tf.errors.UnimplementedError):
        string_seed_accepted = False
    
    # Test 5: Negative shape dimensions (already tested in param)
    # Verify that negative dimensions are caught
    if -1 in invalid_shape:
        with pytest.raises((ValueError, TypeError, tf.errors.InvalidArgumentError,
                           tf.errors.UnimplementedError)) as exc_info:
            valid_generator.normal(shape=invalid_shape, dtype=tf.float32)
        assert exc_info.value is not None, "Should raise exception for negative shape dimensions"
    
    # Test 6: Zero shape dimensions
    if 0 in invalid_shape:
        # Note: TensorFlow might allow zero-sized tensors, but let's test it
        try:
            result = valid_generator.normal(shape=invalid_shape, dtype=tf.float32)
            # If no exception, verify it's a zero-sized tensor
            assert result.shape == tuple(invalid_shape), f"Expected shape {invalid_shape}, got {result.shape}"
            assert tf.size(result) == 0, "Should be zero-sized tensor"
        except (ValueError, TypeError, tf.errors.InvalidArgumentError,
                tf.errors.UnimplementedError):
            # Some versions might reject zero dimensions
            pass
    
    # Test 7: Verify valid inputs still work after error tests
    # This ensures the generator state is not corrupted by error tests
    valid_output = valid_generator.normal(shape=[2, 2], dtype=tf.float32)
    assert valid_output is not None, "Valid generation should work after error tests"
    assert_tensor_shape(valid_output, [2, 2])
    assert_tensor_dtype(valid_output, tf.float32)
    
    # Test 8: Invalid algorithm as string (for the second parameter set)
    # Handle the case where string algorithm might be accepted in some versions
    if isinstance(invalid_alg, str) and invalid_alg == "invalid_string":
        try:
            # Try to create generator with string algorithm
            tf.random.Generator.from_seed(seed=1234, alg=invalid_alg)
            # If no exception, it means this version accepts string algorithms
            # This could happen if TensorFlow accepts algorithm names as strings
            string_alg_accepted = True
        except (ValueError, TypeError, tf.errors.InvalidArgumentError,
                tf.errors.UnimplementedError, tf.errors.NotFoundError):
            string_alg_accepted = False
        
        # If string algorithm was accepted, we should verify it's a valid algorithm
        if string_alg_accepted:
            # Try to see if it's actually a valid algorithm name
            try:
                # Check if it's "philox" or "threefry"
                if invalid_alg.lower() in ["philox", "threefry"]:
                    # This is actually a valid algorithm name
                    # Create generator and verify it works
                    gen = tf.random.Generator.from_seed(seed=1234, alg=invalid_alg)
                    output = gen.normal(shape=[1], dtype=tf.float32)
                    assert output is not None, "String algorithm should work if accepted"
                else:
                    # Invalid string algorithm name - should have raised exception
                    # But didn't, which is unexpected
                    print(f"Warning: Invalid string algorithm '{invalid_alg}' was accepted without exception")
            except Exception:
                # If there's an error later, that's expected
                pass
    
    # Test 9: Verify error messages contain relevant information
    # Re-run one error case to check error message
    with pytest.raises((ValueError, TypeError, tf.errors.InvalidArgumentError,
                       tf.errors.UnimplementedError)) as exc_info:
        tf.random.Generator.from_seed(seed=1234, alg=99)
    
    error_msg = str(exc_info.value).lower()
    # Check for keywords that might appear in error messages
    # Note: exact error messages may vary between TensorFlow versions
    relevant_terms = ['algorithm', 'alg', 'invalid', 'value', 'not', 'supported', 
                     'unimplemented', 'found', 'unknown', 'rng']
    # At least one relevant term should appear
    term_found = any(term in error_msg for term in relevant_terms)
    # Don't assert strictly as error messages may change
    if not term_found:
        print(f"Warning: Error message doesn't contain expected terms: {error_msg}")
    
    # Test 10: Test with None values
    # Some versions might accept None as seed (using random seed)
    try:
        tf.random.Generator.from_seed(seed=None, alg=stateful_random_ops.RNG_ALG_PHILOX)
        # If no exception, None seed is accepted
        none_seed_accepted = True
    except (ValueError, TypeError, tf.errors.InvalidArgumentError):
        none_seed_accepted = False
    
    # Final check: Create a valid generator to ensure environment is still functional
    final_generator = tf.random.Generator.from_seed(seed=9999, alg=stateful_random_ops.RNG_ALG_PHILOX)
    final_output = final_generator.normal(shape=[3], dtype=tf.float32)
    assert final_output is not None, "Should be able to create generator and generate after all tests"
    assert_tensor_shape(final_output, [3])
    assert_tensor_dtype(final_output, tf.float32)
    
    # Summary check: At least some error tests should have raised exceptions
    # We don't assert specific counts because behavior varies by TensorFlow version
    print(f"Test completed: invalid_alg={invalid_alg}, invalid_shape={invalid_shape}, invalid_dtype={invalid_dtype}")
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:FOOTER START ====
# Additional test cases and cleanup
if __name__ == "__main__":
    pytest.main([__file__, "-v"])
# ==== BLOCK:FOOTER END ====