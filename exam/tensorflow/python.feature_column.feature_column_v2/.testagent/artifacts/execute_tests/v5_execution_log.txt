=== Run Tests ===
...F...FF.....sss..                                                      [100%]
================================== FAILURES ===================================
_ test_categorical_column_with_vocabulary_list_basic_creation[category-vocabulary_list1-dtype1-None-2-False] _

key = 'category', vocabulary_list = [1, 2, 3, 4, 5], dtype = tf.int64
default_value = None, num_oov_buckets = 2, expect_error = False

    @pytest.mark.parametrize(
        "key,vocabulary_list,dtype,default_value,num_oov_buckets,expect_error",
        [
            # Base case from test plan - default_value only
            ("department", ["math", "philosophy", "english"], None, -1, 0, False),
            # Parameter extension - num_oov_buckets only (cannot have both default_value and num_oov_buckets)
            # Note: When num_oov_buckets > 0, TensorFlow sets default_value to -1 internally
            # So we need to explicitly set default_value=None to avoid conflict
            ("category", [1, 2, 3, 4, 5], tf.int64, None, 2, False),
            # Test case with both default_value and num_oov_buckets - should raise ValueError
            ("invalid", ["a", "b", "c"], None, 0, 2, True),
        ]
    )
    def test_categorical_column_with_vocabulary_list_basic_creation(
        key, vocabulary_list, dtype, default_value, num_oov_buckets, expect_error
    ):
        """Test categorical_column_with_vocabulary_list basic creation (CASE_02)"""
        # Import the function
        from tensorflow.python.feature_column.feature_column_v2 import categorical_column_with_vocabulary_list
    
        if expect_error:
            # Test that ValueError is raised when both default_value and num_oov_buckets are specified
            with pytest.raises(ValueError) as exc_info:
                column = categorical_column_with_vocabulary_list(
                    key=key,
                    vocabulary_list=vocabulary_list,
                    dtype=dtype,
                    default_value=default_value,
                    num_oov_buckets=num_oov_buckets
                )
            # Check error message mentions the conflict
            error_msg = str(exc_info.value).lower()
            assert "default_value" in error_msg or "num_oov_buckets" in error_msg
            return
    
        # Create the column
        # Note: TensorFlow's categorical_column_with_vocabulary_list has special handling:
        # - If default_value is None and num_oov_buckets > 0, default_value is set to -1 internally
        # - If default_value is provided, num_oov_buckets must be 0
>       column = categorical_column_with_vocabulary_list(
            key=key,
            vocabulary_list=vocabulary_list,
            dtype=dtype,
            default_value=default_value,
            num_oov_buckets=num_oov_buckets
        )

tests\test_tensorflow_python_feature_column_feature_column_v2.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

key = 'category', vocabulary_list = [1, 2, 3, 4, 5], dtype = tf.int64
default_value = None, num_oov_buckets = 2

    @tf_export('feature_column.categorical_column_with_vocabulary_list')
    def categorical_column_with_vocabulary_list(key,
                                                vocabulary_list,
                                                dtype=None,
                                                default_value=-1,
                                                num_oov_buckets=0):
      """A `CategoricalColumn` with in-memory vocabulary.
    
      Use this when your inputs are in string or integer format, and you have an
      in-memory vocabulary mapping each value to an integer ID. By default,
      out-of-vocabulary values are ignored. Use either (but not both) of
      `num_oov_buckets` and `default_value` to specify how to include
      out-of-vocabulary values.
    
      For input dictionary `features`, `features[key]` is either `Tensor` or
      `SparseTensor`. If `Tensor`, missing values can be represented by `-1` for int
      and `''` for string, which will be dropped by this feature column.
    
      Example with `num_oov_buckets`:
      In the following example, each input in `vocabulary_list` is assigned an ID
      0-3 corresponding to its index (e.g., input 'B' produces output 2). All other
      inputs are hashed and assigned an ID 4-5.
    
      ```python
      colors = categorical_column_with_vocabulary_list(
          key='colors', vocabulary_list=('R', 'G', 'B', 'Y'),
          num_oov_buckets=2)
      columns = [colors, ...]
      features = tf.io.parse_example(..., features=make_parse_example_spec(columns))
      linear_prediction, _, _ = linear_model(features, columns)
      ```
    
      Example with `default_value`:
      In the following example, each input in `vocabulary_list` is assigned an ID
      0-4 corresponding to its index (e.g., input 'B' produces output 3). All other
      inputs are assigned `default_value` 0.
    
    
      ```python
      colors = categorical_column_with_vocabulary_list(
          key='colors', vocabulary_list=('X', 'R', 'G', 'B', 'Y'), default_value=0)
      columns = [colors, ...]
      features = tf.io.parse_example(..., features=make_parse_example_spec(columns))
      linear_prediction, _, _ = linear_model(features, columns)
      ```
    
      And to make an embedding with either:
    
      ```python
      columns = [embedding_column(colors, 3),...]
      features = tf.io.parse_example(..., features=make_parse_example_spec(columns))
      dense_tensor = input_layer(features, columns)
      ```
    
      Args:
        key: A unique string identifying the input feature. It is used as the column
          name and the dictionary key for feature parsing configs, feature `Tensor`
          objects, and feature columns.
        vocabulary_list: An ordered iterable defining the vocabulary. Each feature
          is mapped to the index of its value (if present) in `vocabulary_list`.
          Must be castable to `dtype`.
        dtype: The type of features. Only string and integer types are supported. If
          `None`, it will be inferred from `vocabulary_list`.
        default_value: The integer ID value to return for out-of-vocabulary feature
          values, defaults to `-1`. This can not be specified with a positive
          `num_oov_buckets`.
        num_oov_buckets: Non-negative integer, the number of out-of-vocabulary
          buckets. All out-of-vocabulary inputs will be assigned IDs in the range
          `[len(vocabulary_list), len(vocabulary_list)+num_oov_buckets)` based on a
          hash of the input value. A positive `num_oov_buckets` can not be specified
          with `default_value`.
    
      Returns:
        A `CategoricalColumn` with in-memory vocabulary.
    
      Raises:
        ValueError: if `vocabulary_list` is empty, or contains duplicate keys.
        ValueError: `num_oov_buckets` is a negative integer.
        ValueError: `num_oov_buckets` and `default_value` are both specified.
        ValueError: if `dtype` is not integer or string.
      """
      if (vocabulary_list is None) or (len(vocabulary_list) < 1):
        raise ValueError(
            'vocabulary_list {} must be non-empty, column_name: {}'.format(
                vocabulary_list, key))
      if len(set(vocabulary_list)) != len(vocabulary_list):
        raise ValueError(
            'Duplicate keys in vocabulary_list {}, column_name: {}'.format(
                vocabulary_list, key))
      vocabulary_dtype = dtypes.as_dtype(np.array(vocabulary_list).dtype)
      if num_oov_buckets:
        if default_value != -1:
>         raise ValueError(
              'Can\'t specify both num_oov_buckets and default_value in {}.'.format(
                  key))
E         ValueError: Can't specify both num_oov_buckets and default_value in category.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\feature_column\feature_column_v2.py:1574: ValueError
_____ test_embedding_column_dimension_validation[department-16-mean-True] _____

categorical_column_key = 'department', dimension = 16, combiner = 'mean'
trainable = True

    @pytest.mark.parametrize(
        "categorical_column_key,dimension,combiner,trainable",
        [
            # Base case from test plan
            ("department", 16, "mean", True),
            # Parameter extension
            ("product", 32, "sqrtn", False),
        ]
    )
    def test_embedding_column_dimension_validation(categorical_column_key, dimension, combiner, trainable):
        """Test embedding_column dimension validation (CASE_04)"""
        # Import functions
        from tensorflow.python.feature_column.feature_column_v2 import (
            categorical_column_with_vocabulary_list, embedding_column
        )
    
        # First create a categorical column
        categorical_column = categorical_column_with_vocabulary_list(
            key=categorical_column_key,
            vocabulary_list=["item1", "item2", "item3", "item4", "item5"]
        )
    
        # Create the embedding column
        column = embedding_column(
            categorical_column=categorical_column,
            dimension=dimension,
            combiner=combiner,
            trainable=trainable
        )
    
        # Assert basic properties (weak assertions)
        assert column is not None
    
        # Check categorical_column - embedding column should have reference to categorical column
        assert hasattr(column, 'categorical_column')
        assert column.categorical_column is categorical_column
    
        # Check dimension
        assert hasattr(column, 'dimension')
        assert column.dimension == dimension
    
        # Check combiner
        assert hasattr(column, 'combiner')
        assert column.combiner == combiner
    
        # Check trainable
        assert hasattr(column, 'trainable')
        assert column.trainable == trainable
    
        # Check if it's an EmbeddingColumn by checking for specific attributes
        # Embedding columns should have initializer attribute
        assert hasattr(column, 'initializer')
    
        # Check that column has a name (derived from categorical column)
        assert hasattr(column, 'name')
        # The name should contain the categorical column key
        assert categorical_column_key in column.name
    
        # Check that column has parse_example_spec attribute (not method)
        assert hasattr(column, 'parse_example_spec')
        # parse_example_spec is a property, not a callable method
        # It should return a dictionary
        parse_spec = column.parse_example_spec
        assert isinstance(parse_spec, dict)
        # IMPORTANT: For embedding columns, parse_example_spec returns the categorical column's key
        # not the embedding column's name. This is because embedding columns transform
        # the categorical column's values.
        assert categorical_column_key in parse_spec
        # The value should be a FixedLenFeature or VarLenFeature
        spec_value = parse_spec[categorical_column_key]
        assert hasattr(spec_value, 'dtype')
        # VarLenFeature doesn't have shape attribute, FixedLenFeature does
    
        # Check that column has transform_feature method
        assert hasattr(column, 'transform_feature')
        assert callable(column.transform_feature)
    
        # Check for other embedding-specific attributes
        assert hasattr(column, 'max_norm')
        # max_norm might be None
    
        # Verify dimension validation
        # Test with invalid dimension (0 or negative)
        with pytest.raises(ValueError) as exc_info:
            embedding_column(
                categorical_column=categorical_column,
                dimension=0,
                combiner=combiner,
                trainable=trainable
            )
        error_msg = str(exc_info.value).lower()
        assert "dimension" in error_msg or "positive" in error_msg
    
        # Test with invalid combiner
        with pytest.raises(ValueError) as exc_info:
>           embedding_column(
                categorical_column=categorical_column,
                dimension=dimension,
                combiner="invalid_combiner",
                trainable=trainable
            )
E           Failed: DID NOT RAISE <class 'ValueError'>

tests\test_tensorflow_python_feature_column_feature_column_v2.py:371: Failed
_____ test_embedding_column_dimension_validation[product-32-sqrtn-False] ______

categorical_column_key = 'product', dimension = 32, combiner = 'sqrtn'
trainable = False

    @pytest.mark.parametrize(
        "categorical_column_key,dimension,combiner,trainable",
        [
            # Base case from test plan
            ("department", 16, "mean", True),
            # Parameter extension
            ("product", 32, "sqrtn", False),
        ]
    )
    def test_embedding_column_dimension_validation(categorical_column_key, dimension, combiner, trainable):
        """Test embedding_column dimension validation (CASE_04)"""
        # Import functions
        from tensorflow.python.feature_column.feature_column_v2 import (
            categorical_column_with_vocabulary_list, embedding_column
        )
    
        # First create a categorical column
        categorical_column = categorical_column_with_vocabulary_list(
            key=categorical_column_key,
            vocabulary_list=["item1", "item2", "item3", "item4", "item5"]
        )
    
        # Create the embedding column
        column = embedding_column(
            categorical_column=categorical_column,
            dimension=dimension,
            combiner=combiner,
            trainable=trainable
        )
    
        # Assert basic properties (weak assertions)
        assert column is not None
    
        # Check categorical_column - embedding column should have reference to categorical column
        assert hasattr(column, 'categorical_column')
        assert column.categorical_column is categorical_column
    
        # Check dimension
        assert hasattr(column, 'dimension')
        assert column.dimension == dimension
    
        # Check combiner
        assert hasattr(column, 'combiner')
        assert column.combiner == combiner
    
        # Check trainable
        assert hasattr(column, 'trainable')
        assert column.trainable == trainable
    
        # Check if it's an EmbeddingColumn by checking for specific attributes
        # Embedding columns should have initializer attribute
        assert hasattr(column, 'initializer')
    
        # Check that column has a name (derived from categorical column)
        assert hasattr(column, 'name')
        # The name should contain the categorical column key
        assert categorical_column_key in column.name
    
        # Check that column has parse_example_spec attribute (not method)
        assert hasattr(column, 'parse_example_spec')
        # parse_example_spec is a property, not a callable method
        # It should return a dictionary
        parse_spec = column.parse_example_spec
        assert isinstance(parse_spec, dict)
        # IMPORTANT: For embedding columns, parse_example_spec returns the categorical column's key
        # not the embedding column's name. This is because embedding columns transform
        # the categorical column's values.
        assert categorical_column_key in parse_spec
        # The value should be a FixedLenFeature or VarLenFeature
        spec_value = parse_spec[categorical_column_key]
        assert hasattr(spec_value, 'dtype')
        # VarLenFeature doesn't have shape attribute, FixedLenFeature does
    
        # Check that column has transform_feature method
        assert hasattr(column, 'transform_feature')
        assert callable(column.transform_feature)
    
        # Check for other embedding-specific attributes
        assert hasattr(column, 'max_norm')
        # max_norm might be None
    
        # Verify dimension validation
        # Test with invalid dimension (0 or negative)
        with pytest.raises(ValueError) as exc_info:
            embedding_column(
                categorical_column=categorical_column,
                dimension=0,
                combiner=combiner,
                trainable=trainable
            )
        error_msg = str(exc_info.value).lower()
        assert "dimension" in error_msg or "positive" in error_msg
    
        # Test with invalid combiner
        with pytest.raises(ValueError) as exc_info:
>           embedding_column(
                categorical_column=categorical_column,
                dimension=dimension,
                combiner="invalid_combiner",
                trainable=trainable
            )
E           Failed: DID NOT RAISE <class 'ValueError'>

tests\test_tensorflow_python_feature_column_feature_column_v2.py:371: Failed

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                                               Stmts   Miss Branch BrPart  Cover   Missing
--------------------------------------------------------------------------------------------------------------
tests\test_tensorflow_python_feature_column_feature_column_v2.py     218     28     44     10    84%   17-20, 144-148, 164-165, 166->172, 182, 377-378, 416-419, 439, 452, 460-461, 468->517, 471-481, 506->517, 513->517, 601-602, 607-608, 637
--------------------------------------------------------------------------------------------------------------
TOTAL                                                                218     28     44     10    84%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_feature_column_feature_column_v2.py::test_categorical_column_with_vocabulary_list_basic_creation[category-vocabulary_list1-dtype1-None-2-False]
FAILED tests\test_tensorflow_python_feature_column_feature_column_v2.py::test_embedding_column_dimension_validation[department-16-mean-True]
FAILED tests\test_tensorflow_python_feature_column_feature_column_v2.py::test_embedding_column_dimension_validation[product-32-sqrtn-False]
3 failed, 13 passed, 3 skipped in 1.65s

Error: exit 1