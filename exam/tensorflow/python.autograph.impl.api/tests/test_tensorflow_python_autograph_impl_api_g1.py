"""
Test cases for tensorflow.python.autograph.impl.api module - Group G1 (Core Decorators & Conversion Functions).
Generated by TestAgent for AutoGraph API testing.
"""

import os
import sys
import pytest
import tensorflow as tf
from tensorflow.python.autograph.impl.api import (
    convert,
    to_graph,
    do_not_convert,
    AutoGraphError,
    ConversionError,
    StagingError
)

# Set random seed for reproducibility
tf.random.set_seed(42)

# Helper functions and fixtures for G1 group
@pytest.fixture
def simple_conditional_function():
    """Simple function with conditional logic."""
    def func(x):
        if x > 0:
            return x * 2
        else:
            return -x
    return func

@pytest.fixture
def if_else_flow_function():
    """Function with if-else control flow."""
    def func(x, y):
        if x > y:
            result = x - y
        else:
            result = y - x
        return result * 2
    return func

@pytest.fixture
def while_loop_function():
    """Function with while loop."""
    def func(n):
        total = 0
        i = 0
        while i < n:
            total += i
            i += 1
        return total
    return func

@pytest.fixture
def for_loop_range_function():
    """Function with for loop over range."""
    def func(n):
        total = 0
        for i in range(n):
            total += i * i
        return total
    return func

@pytest.fixture
def nested_function():
    """Function with nested function definition."""
    def outer(x):
        def inner(y):
            return y * 2
        return inner(x) + 1
    return outer

@pytest.fixture
def simple_loop_function():
    """Function with simple loop."""
    def func(n):
        total = 0
        for i in range(n):
            total += i
        return total
    return func

# ==== BLOCK:HEADER START ====
# Test class and imports for G1 group
class TestAutoGraphAPIG1:
    """Test class for AutoGraph API functions - Group G1 (Core Decorators & Conversion Functions)."""
    
    def setup_method(self):
        """Setup test environment."""
        # Clear any existing environment variables
        if 'AUTOGRAPH_STRICT_CONVERSION' in os.environ:
            del os.environ['AUTOGRAPH_STRICT_CONVERSION']
# ==== BLOCK:HEADER END ====

# ==== BLOCK:CASE_01 START ====
    @pytest.mark.parametrize("func_type,recursive,optional_features,user_requested", [
        ("simple_conditional", False, None, True),
        ("while_loop", True, None, False),
        ("if_else_flow", False, None, True),
        ("for_loop_range", True, None, False),
    ])
    def test_convert_decorator_basic_conversion(self, func_type, recursive, optional_features, user_requested, 
                                                simple_conditional_function, if_else_flow_function, 
                                                while_loop_function, for_loop_range_function,
                                                nested_function, simple_loop_function):
        """TC-01: convert装饰器基本转换 - weak assertions"""
        # Select test function based on func_type
        if func_type == "simple_conditional":
            test_func = simple_conditional_function
        elif func_type == "if_else_flow":
            test_func = if_else_flow_function
        elif func_type == "while_loop":
            test_func = while_loop_function
        elif func_type == "for_loop_range":
            test_func = for_loop_range_function
        elif func_type == "nested_function":
            test_func = nested_function
        elif func_type == "simple_loop":
            test_func = simple_loop_function
        else:
            pytest.skip(f"Unknown func_type: {func_type}")
        
        # Apply convert decorator
        decorator = convert(
            recursive=recursive,
            optional_features=optional_features,
            user_requested=user_requested
        )
        converted_func = decorator(test_func)
        
        # Weak assertion 1: returns_decorator - verify decorator is callable
        assert callable(decorator), "convert() should return a callable decorator"
        
        # Weak assertion 2: converted_function_callable - verify converted function is callable
        assert callable(converted_func), "Decorated function should be callable"
        
        # Weak assertion 3: basic_execution - test basic execution with sample inputs
        if func_type == "simple_conditional":
            # Test with positive number
            result = converted_func(5.0)
            expected = 10.0  # 5 * 2
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with negative number
            result = converted_func(-3.0)
            expected = 3.0  # -(-3)
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with zero
            result = converted_func(0.0)
            expected = 0.0  # -0
            assert result == expected, f"Expected {expected}, got {result}"
        
        elif func_type == "while_loop":
            # Test while loop function
            result = converted_func(5)
            expected = 0 + 1 + 2 + 3 + 4  # 10
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with zero
            result = converted_func(0)
            expected = 0  # empty loop
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with one
            result = converted_func(1)
            expected = 0  # i=0, i<1, total=0
            assert result == expected, f"Expected {expected}, got {result}"
        
        elif func_type == "if_else_flow":
            # Test if-else flow function
            # Test case 1: x > y
            result = converted_func(10.0, 3.0)
            expected = (10.0 - 3.0) * 2  # (x - y) * 2 = 14.0
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test case 2: x <= y
            result = converted_func(3.0, 10.0)
            expected = (10.0 - 3.0) * 2  # (y - x) * 2 = 14.0
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test case 3: x == y
            result = converted_func(5.0, 5.0)
            expected = (5.0 - 5.0) * 2  # 0 * 2 = 0.0
            assert result == expected, f"Expected {expected}, got {result}"
        
        elif func_type == "for_loop_range":
            # Test for loop function
            result = converted_func(4)
            expected = 0*0 + 1*1 + 2*2 + 3*3  # 0 + 1 + 4 + 9 = 14
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with zero
            result = converted_func(0)
            expected = 0  # empty range
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with one
            result = converted_func(1)
            expected = 0*0  # 0
            assert result == expected, f"Expected {expected}, got {result}"
        
        # Verify function attributes are present (basic check)
        assert hasattr(converted_func, '__name__'), "Converted function should have __name__ attribute"
        
        # Test that the function can be called multiple times
        for i in range(3):
            if func_type == "simple_conditional":
                result = converted_func(float(i))
            elif func_type == "while_loop":
                result = converted_func(i)
            elif func_type == "if_else_flow":
                result = converted_func(float(i), float(i + 1))
            elif func_type == "for_loop_range":
                result = converted_func(i)
            else:
                continue
            # Just verify it doesn't crash on repeated calls
            assert result is not None
# ==== BLOCK:CASE_01 END ====

# ==== BLOCK:CASE_02 START ====
    @pytest.mark.parametrize("func_type,recursive,experimental_optional_features", [
        ("if_else_flow", True, None),
        ("for_loop_range", False, None),
        ("simple_conditional", False, None),
        ("while_loop", True, None),
    ])
    def test_to_graph_control_flow_conversion(self, func_type, recursive, experimental_optional_features,
                                              simple_conditional_function, if_else_flow_function, 
                                              while_loop_function, for_loop_range_function,
                                              nested_function, simple_loop_function):
        """TC-02: to_graph函数转换控制流 - weak assertions"""
        # Select test function based on func_type
        if func_type == "simple_conditional":
            test_func = simple_conditional_function
        elif func_type == "if_else_flow":
            test_func = if_else_flow_function
        elif func_type == "while_loop":
            test_func = while_loop_function
        elif func_type == "for_loop_range":
            test_func = for_loop_range_function
        elif func_type == "nested_function":
            test_func = nested_function
        elif func_type == "simple_loop":
            test_func = simple_loop_function
        else:
            pytest.skip(f"Unknown func_type: {func_type}")
        
        # Convert function using to_graph
        converted_func = to_graph(
            entity=test_func,
            recursive=recursive,
            experimental_optional_features=experimental_optional_features
        )
        
        # Weak assertion 1: returns_converted_function - verify to_graph returns a callable
        assert callable(converted_func), "to_graph() should return a callable function"
        
        # Weak assertion 2: control_flow_execution - test control flow execution
        if func_type == "if_else_flow":
            # Test case 1: x > y
            result = converted_func(10.0, 3.0)
            expected = (10.0 - 3.0) * 2  # (x - y) * 2 = 14.0
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test case 2: x <= y
            result = converted_func(3.0, 10.0)
            expected = (10.0 - 3.0) * 2  # (y - x) * 2 = 14.0
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test case 3: x == y
            result = converted_func(5.0, 5.0)
            expected = (5.0 - 5.0) * 2  # 0 * 2 = 0.0
            assert result == expected, f"Expected {expected}, got {result}"
        
        elif func_type == "for_loop_range":
            # Test for loop function
            result = converted_func(4)
            expected = 0*0 + 1*1 + 2*2 + 3*3  # 0 + 1 + 4 + 9 = 14
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with zero
            result = converted_func(0)
            expected = 0  # empty range
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with one
            result = converted_func(1)
            expected = 0*0  # 0
            assert result == expected, f"Expected {expected}, got {result}"
        
        elif func_type == "simple_conditional":
            # Test simple conditional function
            # Test with positive number
            result = converted_func(5.0)
            expected = 10.0  # 5 * 2
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with negative number
            result = converted_func(-3.0)
            expected = 3.0  # -(-3)
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with zero
            result = converted_func(0.0)
            expected = 0.0  # -0
            assert result == expected, f"Expected {expected}, got {result}"
        
        elif func_type == "while_loop":
            # Test while loop function
            result = converted_func(5)
            expected = 0 + 1 + 2 + 3 + 4  # 10
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with zero
            result = converted_func(0)
            expected = 0  # empty loop
            assert result == expected, f"Expected {expected}, got {result}"
            
            # Test with one
            result = converted_func(1)
            expected = 0  # i=0, i<1, total=0
            assert result == expected, f"Expected {expected}, got {result}"
        
        # Weak assertion 3: type_preserved - verify return type is appropriate
        # For TensorFlow operations, result should be a tf.Tensor or compatible type
        if func_type in ["if_else_flow", "simple_conditional"]:
            if func_type == "if_else_flow":
                result = converted_func(1.0, 2.0)
            else:  # simple_conditional
                result = converted_func(1.0)
            # Check that result can be used in arithmetic operations
            assert result + 0 == result, "Result should support arithmetic operations"
        
        # Test with TensorFlow tensors
        if func_type in ["if_else_flow", "simple_conditional"]:
            if func_type == "if_else_flow":
                # Test with tf.constant inputs
                x_tensor = tf.constant(7.0)
                y_tensor = tf.constant(2.0)
                result_tensor = converted_func(x_tensor, y_tensor)
                # Verify it returns a tensor or numeric value
                assert result_tensor is not None, "Should handle tf.constant inputs"
                
                # Test with mixed inputs
                result_mixed = converted_func(5.0, tf.constant(3.0))
                assert result_mixed is not None, "Should handle mixed Python/TensorFlow inputs"
            else:  # simple_conditional
                # Test with tf.constant input
                x_tensor = tf.constant(4.0)
                result_tensor = converted_func(x_tensor)
                assert result_tensor is not None, "Should handle tf.constant input"
                
                # Test with negative tensor
                x_tensor_neg = tf.constant(-2.0)
                result_tensor_neg = converted_func(x_tensor_neg)
                assert result_tensor_neg is not None, "Should handle negative tf.constant input"
        
        # Verify function can be called multiple times
        for i in range(3):
            if func_type == "if_else_flow":
                result = converted_func(float(i), float(i + 1))
            elif func_type == "for_loop_range":
                result = converted_func(i)
            elif func_type == "simple_conditional":
                result = converted_func(float(i))
            elif func_type == "while_loop":
                result = converted_func(i)
            else:
                continue
            assert result is not None, f"Call {i+1} should not return None"
# ==== BLOCK:CASE_02 END ====

# ==== BLOCK:CASE_04 START ====
    @pytest.mark.parametrize("func_type,recursive,comparison_recursive", [
        ("nested_function", False, True),
        ("simple_conditional", False, True),
        ("if_else_flow", True, False),
    ])
    def test_recursive_vs_nonrecursive_conversion_differences(self, func_type, recursive, comparison_recursive,
                                                              simple_conditional_function, if_else_flow_function, 
                                                              while_loop_function, for_loop_range_function,
                                                              nested_function, simple_loop_function):
        """TC-04: 递归与非递归转换差异 - weak assertions"""
        # Select test function based on func_type
        if func_type == "simple_conditional":
            test_func = simple_conditional_function
        elif func_type == "if_else_flow":
            test_func = if_else_flow_function
        elif func_type == "while_loop":
            test_func = while_loop_function
        elif func_type == "for_loop_range":
            test_func = for_loop_range_function
        elif func_type == "nested_function":
            test_func = nested_function
        elif func_type == "simple_loop":
            test_func = simple_loop_function
        else:
            pytest.skip(f"Unknown func_type: {func_type}")
        
        # Apply convert decorator with non-recursive conversion
        nonrecursive_decorator = convert(recursive=recursive)
        nonrecursive_func = nonrecursive_decorator(test_func)
        
        # Apply convert decorator with recursive conversion (for comparison)
        recursive_decorator = convert(recursive=comparison_recursive)
        recursive_func = recursive_decorator(test_func)
        
        # Weak assertion 1: function_callable - verify both converted functions are callable
        assert callable(nonrecursive_func), "Non-recursive converted function should be callable"
        assert callable(recursive_func), "Recursive converted function should be callable"
        
        # Weak assertion 2: basic_execution - test basic execution with sample inputs
        if func_type == "nested_function":
            # Test with positive number
            result_nonrecursive = nonrecursive_func(5)
            result_recursive = recursive_func(5)
            expected = 5 * 2 + 1  # inner(y) returns y*2, outer returns inner(x)+1 = 5*2+1 = 11
            
            # Both should produce correct results
            assert result_nonrecursive == expected, \
                f"Non-recursive: Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive: Expected {expected}, got {result_recursive}"
            
            # Test with zero
            result_nonrecursive = nonrecursive_func(0)
            result_recursive = recursive_func(0)
            expected = 0 * 2 + 1  # 0 + 1 = 1
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (zero): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (zero): Expected {expected}, got {result_recursive}"
            
            # Test with negative number
            result_nonrecursive = nonrecursive_func(-3)
            result_recursive = recursive_func(-3)
            expected = -3 * 2 + 1  # -6 + 1 = -5
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (negative): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (negative): Expected {expected}, got {result_recursive}"
        
        elif func_type == "simple_conditional":
            # Test with positive number
            result_nonrecursive = nonrecursive_func(5.0)
            result_recursive = recursive_func(5.0)
            expected = 10.0  # 5 * 2
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (positive): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (positive): Expected {expected}, got {result_recursive}"
            
            # Test with negative number
            result_nonrecursive = nonrecursive_func(-3.0)
            result_recursive = recursive_func(-3.0)
            expected = 3.0  # -(-3)
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (negative): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (negative): Expected {expected}, got {result_recursive}"
            
            # Test with zero
            result_nonrecursive = nonrecursive_func(0.0)
            result_recursive = recursive_func(0.0)
            expected = 0.0  # -0
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (zero): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (zero): Expected {expected}, got {result_recursive}"
        
        elif func_type == "if_else_flow":
            # Test case 1: x > y
            result_nonrecursive = nonrecursive_func(10.0, 3.0)
            result_recursive = recursive_func(10.0, 3.0)
            expected = (10.0 - 3.0) * 2  # (x - y) * 2 = 14.0
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (x>y): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (x>y): Expected {expected}, got {result_recursive}"
            
            # Test case 2: x <= y
            result_nonrecursive = nonrecursive_func(3.0, 10.0)
            result_recursive = recursive_func(3.0, 10.0)
            expected = (10.0 - 3.0) * 2  # (y - x) * 2 = 14.0
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (x<=y): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (x<=y): Expected {expected}, got {result_recursive}"
            
            # Test case 3: x == y
            result_nonrecursive = nonrecursive_func(5.0, 5.0)
            result_recursive = recursive_func(5.0, 5.0)
            expected = (5.0 - 5.0) * 2  # 0 * 2 = 0.0
            
            assert result_nonrecursive == expected, \
                f"Non-recursive (x==y): Expected {expected}, got {result_nonrecursive}"
            assert result_recursive == expected, \
                f"Recursive (x==y): Expected {expected}, got {result_recursive}"
        
        # Weak assertion 3: output_consistency - verify outputs are consistent between conversions
        if func_type in ["nested_function", "simple_conditional", "if_else_flow"]:
            # Test multiple inputs to ensure consistency
            if func_type == "nested_function":
                test_inputs = [1, 2, 3, 4, 5, 10, 20]
                for x in test_inputs:
                    nonrecursive_result = nonrecursive_func(x)
                    recursive_result = recursive_func(x)
                    
                    # Both should produce the same result for the same input
                    assert nonrecursive_result == recursive_result, \
                        f"For input {x}: non-recursive result {nonrecursive_result} != " \
                        f"recursive result {recursive_result}"
                    
                    # Verify the result matches expected computation
                    expected = x * 2 + 1
                    assert nonrecursive_result == expected, \
                        f"Non-recursive for input {x}: expected {expected}, got {nonrecursive_result}"
                    assert recursive_result == expected, \
                        f"Recursive for input {x}: expected {expected}, got {recursive_result}"
            
            elif func_type == "simple_conditional":
                test_inputs = [-5.0, -2.0, 0.0, 1.0, 3.0, 7.0, 10.0]
                for x in test_inputs:
                    nonrecursive_result = nonrecursive_func(x)
                    recursive_result = recursive_func(x)
                    
                    # Both should produce the same result for the same input
                    assert nonrecursive_result == recursive_result, \
                        f"For input {x}: non-recursive result {nonrecursive_result} != " \
                        f"recursive result {recursive_result}"
                    
                    # Verify the result matches expected computation
                    expected = x * 2 if x > 0 else -x
                    assert nonrecursive_result == expected, \
                        f"Non-recursive for input {x}: expected {expected}, got {nonrecursive_result}"
                    assert recursive_result == expected, \
                        f"Recursive for input {x}: expected {expected}, got {recursive_result}"
            
            elif func_type == "if_else_flow":
                test_inputs = [(1.0, 2.0), (3.0, 1.0), (5.0, 5.0), (2.0, 4.0), (10.0, 3.0)]
                for x, y in test_inputs:
                    nonrecursive_result = nonrecursive_func(x, y)
                    recursive_result = recursive_func(x, y)
                    
                    # Both should produce the same result for the same input
                    assert nonrecursive_result == recursive_result, \
                        f"For inputs ({x}, {y}): non-recursive result {nonrecursive_result} != " \
                        f"recursive result {recursive_result}"
                    
                    # Verify the result matches expected computation
                    expected = (x - y) * 2 if x > y else (y - x) * 2
                    assert nonrecursive_result == expected, \
                        f"Non-recursive for inputs ({x}, {y}): expected {expected}, got {nonrecursive_result}"
                    assert recursive_result == expected, \
                        f"Recursive for inputs ({x}, {y}): expected {expected}, got {recursive_result}"
        
        # Verify both functions have basic attributes
        assert hasattr(nonrecursive_func, '__name__'), \
            "Non-recursive converted function should have __name__ attribute"
        assert hasattr(recursive_func, '__name__'), \
            "Recursive converted function should have __name__ attribute"
        
        # Test that both functions can be called multiple times
        for i in range(3):
            if func_type == "nested_function":
                result_nonrecursive = nonrecursive_func(i)
                result_recursive = recursive_func(i)
                
                # Verify neither returns None
                assert result_nonrecursive is not None, \
                    f"Non-recursive call {i+1} should not return None"
                assert result_recursive is not None, \
                    f"Recursive call {i+1} should not return None"
                
                # Verify consistency between calls
                assert result_nonrecursive == result_recursive, \
                    f"Call {i+1}: non-recursive {result_nonrecursive} != recursive {result_recursive}"
            
            elif func_type == "simple_conditional":
                result_nonrecursive = nonrecursive_func(float(i))
                result_recursive = recursive_func(float(i))
                
                # Verify neither returns None
                assert result_nonrecursive is not None, \
                    f"Non-recursive call {i+1} should not return None"
                assert result_recursive is not None, \
                    f"Recursive call {i+1} should not return None"
                
                # Verify consistency between calls
                assert result_nonrecursive == result_recursive, \
                    f"Call {i+1}: non-recursive {result_nonrecursive} != recursive {result_recursive}"
            
            elif func_type == "if_else_flow":
                result_nonrecursive = nonrecursive_func(float(i), float(i + 1))
                result_recursive = recursive_func(float(i), float(i + 1))
                
                # Verify neither returns None
                assert result_nonrecursive is not None, \
                    f"Non-recursive call {i+1} should not return None"
                assert result_recursive is not None, \
                    f"Recursive call {i+1} should not return None"
                
                # Verify consistency between calls
                assert result_nonrecursive == result_recursive, \
                    f"Call {i+1}: non-recursive {result_nonrecursive} != recursive {result_recursive}"
        
        # Test with TensorFlow tensors (if applicable)
        if func_type in ["simple_conditional", "if_else_flow"]:
            if func_type == "simple_conditional":
                # Test with tf.constant
                x_tensor = tf.constant(7.0)
                
                # Both conversions should handle tensor inputs
                result_nonrecursive_tensor = nonrecursive_func(x_tensor)
                result_recursive_tensor = recursive_func(x_tensor)
                
                # Verify both produce results
                assert result_nonrecursive_tensor is not None, \
                    "Non-recursive should handle tf.constant input"
                assert result_recursive_tensor is not None, \
                    "Recursive should handle tf.constant input"
                
                # If both return tensors, they should have the same value
                if hasattr(result_nonrecursive_tensor, 'numpy') and hasattr(result_recursive_tensor, 'numpy'):
                    np_nonrecursive = result_nonrecursive_tensor.numpy()
                    np_recursive = result_recursive_tensor.numpy()
                    assert np_nonrecursive == np_recursive, \
                        f"Tensor results differ: non-recursive {np_nonrecursive} != recursive {np_recursive}"
            
            elif func_type == "if_else_flow":
                # Test with tf.constant inputs
                x_tensor = tf.constant(5.0)
                y_tensor = tf.constant(2.0)
                
                # Both conversions should handle tensor inputs
                result_nonrecursive_tensor = nonrecursive_func(x_tensor, y_tensor)
                result_recursive_tensor = recursive_func(x_tensor, y_tensor)
                
                # Verify both produce results
                assert result_nonrecursive_tensor is not None, \
                    "Non-recursive should handle tf.constant inputs"
                assert result_recursive_tensor is not None, \
                    "Recursive should handle tf.constant inputs"
                
                # If both return tensors, they should have the same value
                if hasattr(result_nonrecursive_tensor, 'numpy') and hasattr(result_recursive_tensor, 'numpy'):
                    np_nonrecursive = result_nonrecursive_tensor.numpy()
                    np_recursive = result_recursive_tensor.numpy()
                    assert np_nonrecursive == np_recursive, \
                        f"Tensor results differ: non-recursive {np_nonrecursive} != recursive {np_recursive}"
        
        # Note: Strong assertions (call_graph_depth, conversion_scope, attribute_differences)
        # are deferred to final round when strong assertions are enabled
# ==== BLOCK:CASE_04 END ====

# ==== BLOCK:CASE_05 START ====
# TC-05: 实验性功能参数测试 (DEFERRED - placeholder)
# ==== BLOCK:CASE_05 END ====

# ==== BLOCK:FOOTER START ====
# Cleanup and additional helper functions for G1 group
    def teardown_method(self):
        """Cleanup test environment."""
        # Restore environment variables
        if 'AUTOGRAPH_STRICT_CONVERSION' in os.environ:
            del os.environ['AUTOGRAPH_STRICT_CONVERSION']
            
    def test_convert_with_environment_variable(self):
        """Test convert decorator with AUTOGRAPH_STRICT_CONVERSION environment variable."""
        # Set environment variable
        os.environ['AUTOGRAPH_STRICT_CONVERSION'] = '1'
        
        # Create a simple function
        def simple_func(x):
            return x * 3
        
        # Apply convert decorator
        decorator = convert(recursive=False, user_requested=True)
        converted_func = decorator(simple_func)
        
        # Test execution
        result = converted_func(4)
        assert result == 12, f"Expected 12, got {result}"
        
        # Clean up
        del os.environ['AUTOGRAPH_STRICT_CONVERSION']
        
if __name__ == '__main__':
    pytest.main([__file__, '-v'])
# ==== BLOCK:FOOTER END ====