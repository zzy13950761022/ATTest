=== Run Tests ===
FFF.FFFFFFFFssssss                                                       [100%]
================================== FAILURES ===================================
_______________ test_file_exists_basic[/tmp/test_file.txt-True] _______________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610090266880'>, 'FileExists': <MagicMock id='2609482099440'>, 'GetChildren': <MagicMock id='2610090250640'>, 'ReadFileToString': <MagicMock id='2610090238496'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610090307696'>, 'join': <MagicMock name='join' id='2610090279168'>}
path = '/tmp/test_file.txt', expected_result = True

    @pytest.mark.parametrize("path,expected_result", [
        ("/tmp/test_file.txt", True),
        ("/tmp/nonexistent.txt", False),
        ("", False),
    ])
    def test_file_exists_basic(mock_pywrap_file_io, mock_os_path, path, expected_result):
        """
        TC-01: 文件存在性检查基础功能
        Tests basic file existence checking functionality.
        """
        # Setup mock
        mock_pywrap_file_io['FileExists'].return_value = expected_result
    
        # Call the function
        result = file_io.file_exists(path)
    
        # Verify mock was called correctly
        if path:  # Only call mock for non-empty paths
>           mock_pywrap_file_io['FileExists'].assert_called_once_with(path)

tests/test_tensorflow_python_lib_io_file_io.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:919: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2609482099440'>, args = ('/tmp/test_file.txt',)
kwargs = {}, expected = call('/tmp/test_file.txt')
actual = call(b'/tmp/test_file.txt')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x0000025F8FDA1940>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\nActual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: mock('/tmp/test_file.txt')
E           Actual: mock(b'/tmp/test_file.txt')

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:907: AssertionError
_____________ test_file_exists_basic[/tmp/nonexistent.txt-False] ______________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610091734160'>, 'FileExists': <MagicMock id='2610090250544'>, 'GetChildren': <MagicMock id='2610091771168'>, 'ReadFileToString': <MagicMock id='2610091724560'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610108851200'>, 'join': <MagicMock name='join' id='2610091725968'>}
path = '/tmp/nonexistent.txt', expected_result = False

    @pytest.mark.parametrize("path,expected_result", [
        ("/tmp/test_file.txt", True),
        ("/tmp/nonexistent.txt", False),
        ("", False),
    ])
    def test_file_exists_basic(mock_pywrap_file_io, mock_os_path, path, expected_result):
        """
        TC-01: 文件存在性检查基础功能
        Tests basic file existence checking functionality.
        """
        # Setup mock
        mock_pywrap_file_io['FileExists'].return_value = expected_result
    
        # Call the function
        result = file_io.file_exists(path)
    
        # Verify mock was called correctly
        if path:  # Only call mock for non-empty paths
>           mock_pywrap_file_io['FileExists'].assert_called_once_with(path)

tests/test_tensorflow_python_lib_io_file_io.py:77: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:919: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2610090250544'>, args = ('/tmp/nonexistent.txt',)
kwargs = {}, expected = call('/tmp/nonexistent.txt')
actual = call(b'/tmp/nonexistent.txt')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x0000025FB5969700>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\nActual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: mock('/tmp/nonexistent.txt')
E           Actual: mock(b'/tmp/nonexistent.txt')

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:907: AssertionError
_______________________ test_file_exists_basic[-False] ________________________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610091840896'>, 'FileExists': <MagicMock id='2610091733968'>, 'GetChildren': <MagicMock id='2610091890480'>, 'ReadFileToString': <MagicMock id='2610108832352'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610091824992'>, 'join': <MagicMock name='join' id='2610091923776'>}
path = '', expected_result = False

    @pytest.mark.parametrize("path,expected_result", [
        ("/tmp/test_file.txt", True),
        ("/tmp/nonexistent.txt", False),
        ("", False),
    ])
    def test_file_exists_basic(mock_pywrap_file_io, mock_os_path, path, expected_result):
        """
        TC-01: 文件存在性检查基础功能
        Tests basic file existence checking functionality.
        """
        # Setup mock
        mock_pywrap_file_io['FileExists'].return_value = expected_result
    
        # Call the function
        result = file_io.file_exists(path)
    
        # Verify mock was called correctly
        if path:  # Only call mock for non-empty paths
            mock_pywrap_file_io['FileExists'].assert_called_once_with(path)
        else:
            # For empty path, should not call the underlying function
>           mock_pywrap_file_io['FileExists'].assert_not_called()

tests/test_tensorflow_python_lib_io_file_io.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2610091733968'>

    def assert_not_called(self):
        """assert that the mock was never called.
        """
        if self.call_count != 0:
            msg = ("Expected '%s' to not have been called. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to not have been called. Called 1 times.
E           Calls: [call(b'')].

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:868: AssertionError
_____ test_file_read_write_string[/tmp/test_text.txt-Hello TensorFlow-w] ______

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610091975872'>, 'FileExists': <MagicMock id='2610091909568'>, 'GetChildren': <MagicMock id='2610091828656'>, 'ReadFileToString': <MagicMock id='2610077785248'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610091998752'>, 'join': <MagicMock name='join' id='2610091966272'>}
path = '/tmp/test_text.txt', content = 'Hello TensorFlow', mode = 'w'

    @pytest.mark.parametrize("path,content,mode", [
        ("/tmp/test_text.txt", "Hello TensorFlow", "w"),
        ("/tmp/empty.txt", "", "w"),
        ("/tmp/unicode.txt", "\u4e2d\u6587\u6d4b\u8bd5 \U0001f680", "w"),
    ])
    def test_file_read_write_string(mock_pywrap_file_io, mock_os_path, path, content, mode):
        """
        TC-03: 文本文件读写一致性
        Tests text file read/write consistency.
        """
        # Setup mocks
        mock_pywrap_file_io['WriteStringToFile'].return_value = None
        mock_pywrap_file_io['ReadFileToString'].return_value = content
    
        # Test write operation
        file_io.write_string_to_file(path, content)
    
        # Verify write was called correctly
>       mock_pywrap_file_io['WriteStringToFile'].assert_called_once_with(path, content)

tests/test_tensorflow_python_lib_io_file_io.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2610109129488'>
args = ('/tmp/test_text.txt', 'Hello TensorFlow'), kwargs = {}
msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:918: AssertionError
_______________ test_file_read_write_string[/tmp/empty.txt--w] ________________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610091717680'>, 'FileExists': <MagicMock id='2610091965552'>, 'GetChildren': <MagicMock id='2609482099200'>, 'ReadFileToString': <MagicMock id='2610090227792'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610109118976'>, 'join': <MagicMock name='join' id='2610108846240'>}
path = '/tmp/empty.txt', content = '', mode = 'w'

    @pytest.mark.parametrize("path,content,mode", [
        ("/tmp/test_text.txt", "Hello TensorFlow", "w"),
        ("/tmp/empty.txt", "", "w"),
        ("/tmp/unicode.txt", "\u4e2d\u6587\u6d4b\u8bd5 \U0001f680", "w"),
    ])
    def test_file_read_write_string(mock_pywrap_file_io, mock_os_path, path, content, mode):
        """
        TC-03: 文本文件读写一致性
        Tests text file read/write consistency.
        """
        # Setup mocks
        mock_pywrap_file_io['WriteStringToFile'].return_value = None
        mock_pywrap_file_io['ReadFileToString'].return_value = content
    
        # Test write operation
        file_io.write_string_to_file(path, content)
    
        # Verify write was called correctly
>       mock_pywrap_file_io['WriteStringToFile'].assert_called_once_with(path, content)

tests/test_tensorflow_python_lib_io_file_io.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2609458886304'>, args = ('/tmp/empty.txt', '')
kwargs = {}, msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:918: AssertionError
_ test_file_read_write_string[/tmp/unicode.txt-\u4e2d\u6587\u6d4b\u8bd5 \U0001f680-w] _

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610108850528'>, 'FileExists': <MagicMock id='2610091716768'>, 'GetChildren': <MagicMock id='2610108838384'>, 'ReadFileToString': <MagicMock id='2610108863776'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2609458905632'>, 'join': <MagicMock name='join' id='2609458945184'>}
path = '/tmp/unicode.txt', content = '\u4e2d\u6587\u6d4b\u8bd5 \U0001f680', mode = 'w'

    @pytest.mark.parametrize("path,content,mode", [
        ("/tmp/test_text.txt", "Hello TensorFlow", "w"),
        ("/tmp/empty.txt", "", "w"),
        ("/tmp/unicode.txt", "\u4e2d\u6587\u6d4b\u8bd5 \U0001f680", "w"),
    ])
    def test_file_read_write_string(mock_pywrap_file_io, mock_os_path, path, content, mode):
        """
        TC-03: 文本文件读写一致性
        Tests text file read/write consistency.
        """
        # Setup mocks
        mock_pywrap_file_io['WriteStringToFile'].return_value = None
        mock_pywrap_file_io['ReadFileToString'].return_value = content
    
        # Test write operation
        file_io.write_string_to_file(path, content)
    
        # Verify write was called correctly
>       mock_pywrap_file_io['WriteStringToFile'].assert_called_once_with(path, content)

tests/test_tensorflow_python_lib_io_file_io.py:160: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2610090193680'>, args = ('/tmp/unicode.txt', '\u4e2d\u6587\u6d4b\u8bd5 \U0001f680')
kwargs = {}, msg = "Expected 'mock' to be called once. Called 0 times."

    def assert_called_once_with(self, /, *args, **kwargs):
        """assert that the mock was called exactly once and that that call was
        with the specified arguments."""
        if not self.call_count == 1:
            msg = ("Expected '%s' to be called once. Called %s times.%s"
                   % (self._mock_name or 'mock',
                      self.call_count,
                      self._calls_repr()))
>           raise AssertionError(msg)
E           AssertionError: Expected 'mock' to be called once. Called 0 times.

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:918: AssertionError
________ test_fileio_basic_read_write[/tmp/test_io.bin-binary_data-wb] ________

thing = <module 'tensorflow' from 'D:\\Coding\\Anaconda\\envs\\testagent-experiment\\lib\\site-packages\\tensorflow\\__init__.py'>
comp = 'python', import_path = 'tensorflow.python'

    def _dot_lookup(thing, comp, import_path):
        try:
>           return getattr(thing, comp)
E           AttributeError: module 'tensorflow' has no attribute 'python'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1226: AttributeError

During handling of the above exception, another exception occurred:

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610091734352'>, 'FileExists': <MagicMock id='2610108850384'>, 'GetChildren': <MagicMock id='2610091726304'>, 'ReadFileToString': <MagicMock id='2610091769920'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610090271888'>, 'join': <MagicMock name='join' id='2610091759168'>}
path = '/tmp/test_io.bin', content = b'binary_data', mode = 'wb'

    @pytest.mark.parametrize("path,content,mode", [
        ("/tmp/test_io.bin", b"binary_data", "wb"),
    ])
    def test_fileio_basic_read_write(mock_pywrap_file_io, mock_os_path, path, content, mode):
        """
        TC-04: FileIO类基础读写
        Tests basic FileIO class read/write operations.
        """
        # Create mocks for BufferedInputStream and WritableFile
        mock_buffered_stream = mock.MagicMock()
        mock_buffered_stream.read.return_value = content
        mock_writable_file = mock.MagicMock()
        mock_writable_file.append.return_value = None
    
        # Mock the _pywrap_file_io functions that FileIO uses
>       with mock.patch('tensorflow.python.lib.io._pywrap_file_io.BufferedInputStream',
                        return_value=mock_buffered_stream), \
             mock.patch('tensorflow.python.lib.io._pywrap_file_io.WritableFile',
                        return_value=mock_writable_file), \
             mock.patch('tensorflow.python.lib.io.file_io.stat') as mock_stat:

tests/test_tensorflow_python_lib_io_file_io.py:194: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1388: in __enter__
    self.target = self.getter()
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1563: in <lambda>
    getter = lambda: _importer(target)
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1239: in _importer
    thing = _dot_lookup(thing, comp, import_path)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

thing = <module 'tensorflow' from 'D:\\Coding\\Anaconda\\envs\\testagent-experiment\\lib\\site-packages\\tensorflow\\__init__.py'>
comp = 'python', import_path = 'tensorflow.python'

    def _dot_lookup(thing, comp, import_path):
        try:
            return getattr(thing, comp)
        except AttributeError:
            __import__(import_path)
>           return getattr(thing, comp)
E           AttributeError: module 'tensorflow' has no attribute 'python'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1229: AttributeError
__________ test_list_directory_basic[/tmp/test_dir-expected_files0] ___________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610109391488'>, 'FileExists': <MagicMock id='2610091758736'>, 'GetChildren': <MagicMock id='2610108847920'>, 'ReadFileToString': <MagicMock id='2609458928320'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610109095792'>, 'join': <MagicMock name='join' id='2610090362672'>}
path = '/tmp/test_dir', expected_files = ['file1.txt', 'file2.txt', 'subdir']

    @pytest.mark.parametrize("path,expected_files", [
        ("/tmp/test_dir", ["file1.txt", "file2.txt", "subdir"]),
        ("/tmp/empty_dir", []),
    ])
    def test_list_directory_basic(mock_pywrap_file_io, mock_os_path, path, expected_files):
        """
        TC-05: 目录列表功能
        Tests basic directory listing functionality.
        """
        # Setup mock
        mock_pywrap_file_io['GetChildren'].return_value = expected_files
    
        # Call the function
        result = file_io.list_directory(path)
    
        # Verify mock was called correctly
>       mock_pywrap_file_io['GetChildren'].assert_called_once_with(path)

tests/test_tensorflow_python_lib_io_file_io.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:919: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2610108847920'>, args = ('/tmp/test_dir',), kwargs = {}
expected = call('/tmp/test_dir'), actual = call(b'/tmp/test_dir')
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x0000025FB59929D0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\nActual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: mock('/tmp/test_dir')
E           Actual: mock(b'/tmp/test_dir')

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:907: AssertionError
__________ test_list_directory_basic[/tmp/empty_dir-expected_files1] __________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610091827360'>, 'FileExists': <MagicMock id='2610108847536'>, 'GetChildren': <MagicMock id='2610077786416'>, 'ReadFileToString': <MagicMock id='2610090229712'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610091880944'>, 'join': <MagicMock name='join' id='2610091995632'>}
path = '/tmp/empty_dir', expected_files = []

    @pytest.mark.parametrize("path,expected_files", [
        ("/tmp/test_dir", ["file1.txt", "file2.txt", "subdir"]),
        ("/tmp/empty_dir", []),
    ])
    def test_list_directory_basic(mock_pywrap_file_io, mock_os_path, path, expected_files):
        """
        TC-05: 目录列表功能
        Tests basic directory listing functionality.
        """
        # Setup mock
        mock_pywrap_file_io['GetChildren'].return_value = expected_files
    
        # Call the function
>       result = file_io.list_directory(path)

tests/test_tensorflow_python_lib_io_file_io.py:255: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\lib\io\file_io.py:746: in list_directory
    return list_directory_v2(dirname)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

path = '/tmp/empty_dir'

    @tf_export("io.gfile.listdir")
    def list_directory_v2(path):
      """Returns a list of entries contained within a directory.
    
      The list is in arbitrary order. It does not contain the special entries "."
      and "..".
    
      Args:
        path: string, path to a directory
    
      Returns:
        [filename1, filename2, ... filenameN] as strings
    
      Raises:
        errors.NotFoundError if directory doesn't exist
      """
      if not is_directory(path):
>       raise errors.NotFoundError(
            node_def=None,
            op=None,
            message="Could not find directory {}".format(path))
E       tensorflow.python.framework.errors_impl.NotFoundError: Could not find directory /tmp/empty_dir

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\lib\io\file_io.py:766: NotFoundError
_________ test_copy_basic[/tmp/source.txt-/tmp/destination.txt-False] _________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610109506656'>, 'FileExists': <MagicMock id='2610091828848'>, 'GetChildren': <MagicMock id='2610108985296'>, 'ReadFileToString': <MagicMock id='2610091908160'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610091989024'>, 'join': <MagicMock name='join' id='2610091947776'>}
src = '/tmp/source.txt', dst = '/tmp/destination.txt', overwrite = False

    @pytest.mark.parametrize("src,dst,overwrite", [
        ("/tmp/source.txt", "/tmp/destination.txt", False),
        ("/tmp/source.txt", "/tmp/destination.txt", True),
    ])
    def test_copy_basic(mock_pywrap_file_io, mock_os_path, src, dst, overwrite):
        """
        TC-06: 文件复制基础功能
        Tests basic file copy functionality.
        """
        # Setup mocks
        mock_pywrap_file_io['CopyFile'].return_value = None
        mock_pywrap_file_io['FileExists'].return_value = True
    
        # Call the function
        file_io.copy(src, dst, overwrite)
    
        # Verify mock was called correctly
>       mock_pywrap_file_io['CopyFile'].assert_called_once_with(src, dst, overwrite)

tests/test_tensorflow_python_lib_io_file_io.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:919: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2610109506656'>
args = ('/tmp/source.txt', '/tmp/destination.txt', False), kwargs = {}
expected = call('/tmp/source.txt', '/tmp/destination.txt', False)
actual = call(b'/tmp/source.txt', b'/tmp/destination.txt', False)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x0000025FB5992D30>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\nActual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: mock('/tmp/source.txt', '/tmp/destination.txt', False)
E           Actual: mock(b'/tmp/source.txt', b'/tmp/destination.txt', False)

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:907: AssertionError
_________ test_copy_basic[/tmp/source.txt-/tmp/destination.txt-True] __________

mock_pywrap_file_io = {'CopyFile': <MagicMock id='2610108951280'>, 'FileExists': <MagicMock id='2610109507664'>, 'GetChildren': <MagicMock id='2610109042800'>, 'ReadFileToString': <MagicMock id='2610091798288'>, ...}
mock_os_path = {'dirname': <MagicMock name='dirname' id='2610108944048'>, 'join': <MagicMock name='join' id='2610108907232'>}
src = '/tmp/source.txt', dst = '/tmp/destination.txt', overwrite = True

    @pytest.mark.parametrize("src,dst,overwrite", [
        ("/tmp/source.txt", "/tmp/destination.txt", False),
        ("/tmp/source.txt", "/tmp/destination.txt", True),
    ])
    def test_copy_basic(mock_pywrap_file_io, mock_os_path, src, dst, overwrite):
        """
        TC-06: 文件复制基础功能
        Tests basic file copy functionality.
        """
        # Setup mocks
        mock_pywrap_file_io['CopyFile'].return_value = None
        mock_pywrap_file_io['FileExists'].return_value = True
    
        # Call the function
        file_io.copy(src, dst, overwrite)
    
        # Verify mock was called correctly
>       mock_pywrap_file_io['CopyFile'].assert_called_once_with(src, dst, overwrite)

tests/test_tensorflow_python_lib_io_file_io.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:919: in assert_called_once_with
    return self.assert_called_with(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock id='2610108951280'>
args = ('/tmp/source.txt', '/tmp/destination.txt', True), kwargs = {}
expected = call('/tmp/source.txt', '/tmp/destination.txt', True)
actual = call(b'/tmp/source.txt', b'/tmp/destination.txt', True)
_error_message = <function NonCallableMock.assert_called_with.<locals>._error_message at 0x0000025FB69C4CA0>
cause = None

    def assert_called_with(self, /, *args, **kwargs):
        """assert that the last call was made with the specified arguments.
    
        Raises an AssertionError if the args and keyword args passed in are
        different to the last call to the mock."""
        if self.call_args is None:
            expected = self._format_mock_call_signature(args, kwargs)
            actual = 'not called.'
            error_message = ('expected call not found.\nExpected: %s\nActual: %s'
                    % (expected, actual))
            raise AssertionError(error_message)
    
        def _error_message():
            msg = self._format_mock_failure_message(args, kwargs)
            return msg
        expected = self._call_matcher(_Call((args, kwargs), two=True))
        actual = self._call_matcher(self.call_args)
        if actual != expected:
            cause = expected if isinstance(expected, Exception) else None
>           raise AssertionError(_error_message()) from cause
E           AssertionError: expected call not found.
E           Expected: mock('/tmp/source.txt', '/tmp/destination.txt', True)
E           Actual: mock(b'/tmp/source.txt', b'/tmp/destination.txt', True)

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:907: AssertionError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                             Stmts   Miss Branch BrPart  Cover   Missing
--------------------------------------------------------------------------------------------
tests\test_tensorflow_python_lib_io_file_io.py     117     36     18      1    64%   18-19, 84-96, 163-175, 201-238, 262-278, 311, 359
--------------------------------------------------------------------------------------------
TOTAL                                              117     36     18      1    64%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_file_exists_basic[/tmp/test_file.txt-True]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_file_exists_basic[/tmp/nonexistent.txt-False]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_file_exists_basic[-False]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_file_read_write_string[/tmp/test_text.txt-Hello TensorFlow-w]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_file_read_write_string[/tmp/empty.txt--w]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_file_read_write_string[/tmp/unicode.txt-\u4e2d\u6587\u6d4b\u8bd5 \U0001f680-w]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_fileio_basic_read_write[/tmp/test_io.bin-binary_data-wb]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_list_directory_basic[/tmp/test_dir-expected_files0]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_list_directory_basic[/tmp/empty_dir-expected_files1]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_copy_basic[/tmp/source.txt-/tmp/destination.txt-False]
FAILED tests\test_tensorflow_python_lib_io_file_io.py::test_copy_basic[/tmp/source.txt-/tmp/destination.txt-True]
11 failed, 1 passed, 6 skipped in 2.06s

Error: exit 1