=== Run Tests ===
FFEEEEEs                                                                 [100%]
=================================== ERRORS ====================================
_ ERROR at setup of TestBatchOps.test_parameter_validation[2-4-5000-allowed_batch_sizes0-5-False-False-input_shape0-float64] _

    @pytest.fixture
    def mock_validate_allowed_batch_sizes():
        """Mock for tensorflow.python.ops.batch_ops._validate_allowed_batch_sizes"""
        # Import the module first, then patch the function
        import tensorflow.python.ops.batch_ops as batch_ops_module
>       with patch.object(batch_ops_module, '_validate_allowed_batch_sizes') as mock:

tests\test_tensorflow_python_ops_batch_ops.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1404: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001F3F949F100>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tensorflow.python.ops.batch_ops' from 'D:\\Coding\\Anaconda\\envs\\testagent-experiment\\lib\\site-packages\\tensorflow\\python\\ops\\batch_ops.py'> does not have the attribute '_validate_allowed_batch_sizes'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1377: AttributeError
_ ERROR at setup of TestBatchOps.test_parameter_validation[1-1-100-allowed_batch_sizes1-1-True-True-input_shape1-float32] _

    @pytest.fixture
    def mock_validate_allowed_batch_sizes():
        """Mock for tensorflow.python.ops.batch_ops._validate_allowed_batch_sizes"""
        # Import the module first, then patch the function
        import tensorflow.python.ops.batch_ops as batch_ops_module
>       with patch.object(batch_ops_module, '_validate_allowed_batch_sizes') as mock:

tests\test_tensorflow_python_ops_batch_ops.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1404: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001F3F94C31F0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tensorflow.python.ops.batch_ops' from 'D:\\Coding\\Anaconda\\envs\\testagent-experiment\\lib\\site-packages\\tensorflow\\python\\ops\\batch_ops.py'> does not have the attribute '_validate_allowed_batch_sizes'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1377: AttributeError
_ ERROR at setup of TestBatchOps.test_error_handling[1-2-1000-allowed_batch_sizes0-10-True-True-input_shape0-float32-True] _

    @pytest.fixture
    def mock_validate_allowed_batch_sizes():
        """Mock for tensorflow.python.ops.batch_ops._validate_allowed_batch_sizes"""
        # Import the module first, then patch the function
        import tensorflow.python.ops.batch_ops as batch_ops_module
>       with patch.object(batch_ops_module, '_validate_allowed_batch_sizes') as mock:

tests\test_tensorflow_python_ops_batch_ops.py:72: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1404: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001F3F8269520>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tensorflow.python.ops.batch_ops' from 'D:\\Coding\\Anaconda\\envs\\testagent-experiment\\lib\\site-packages\\tensorflow\\python\\ops\\batch_ops.py'> does not have the attribute '_validate_allowed_batch_sizes'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1377: AttributeError
_ ERROR at setup of TestBatchOps.test_concurrent_batch_processing[2-4-10000-None-20-True-True-input_shape0-float32-3] _

    @pytest.fixture
    def mock_BatchFunction():
        """Mock for tensorflow.python.ops.batch_ops._BatchFunction"""
        # Import the module first, then patch the class
        import tensorflow.python.ops.batch_ops as batch_ops_module
>       with patch.object(batch_ops_module, '_BatchFunction') as mock:

tests\test_tensorflow_python_ops_batch_ops.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1404: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001F3D284B0A0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tensorflow.python.ops.batch_ops' from 'D:\\Coding\\Anaconda\\envs\\testagent-experiment\\lib\\site-packages\\tensorflow\\python\\ops\\batch_ops.py'> does not have the attribute '_BatchFunction'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1377: AttributeError
_ ERROR at setup of TestBatchOps.test_concurrent_batch_processing[1-10-5000-None-5-True-True-input_shape1-float32-5] _

    @pytest.fixture
    def mock_BatchFunction():
        """Mock for tensorflow.python.ops.batch_ops._BatchFunction"""
        # Import the module first, then patch the class
        import tensorflow.python.ops.batch_ops as batch_ops_module
>       with patch.object(batch_ops_module, '_BatchFunction') as mock:

tests\test_tensorflow_python_ops_batch_ops.py:92: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1404: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001F3D2857760>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'tensorflow.python.ops.batch_ops' from 'D:\\Coding\\Anaconda\\envs\\testagent-experiment\\lib\\site-packages\\tensorflow\\python\\ops\\batch_ops.py'> does not have the attribute '_BatchFunction'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1377: AttributeError
================================== FAILURES ===================================
_ TestBatchOps.test_basic_decorator_functionality[1-2-1000-None-10-True-True-input_shape0-float32] _

self = <test_tensorflow_python_ops_batch_ops.TestBatchOps object at 0x000001F3F8235820>
num_batch_threads = 1, max_batch_size = 2, batch_timeout_micros = 1000
allowed_batch_sizes = None, max_enqueued_batches = 10, autograph = True
enable_large_batch_splitting = True, input_shape = [2, 3], dtype = 'float32'
mock_batch_function = <MagicMock name='batch_function' id='2147351835648'>
mock_defun = <MagicMock name='defun' id='2147351921136'>
mock_tensor_spec = <MagicMock name='TensorSpec' id='2147351957904'>
mock_pack_sequence_as = <MagicMock name='pack_sequence_as' id='2147351978336'>
sample_input_tensor = <tf.Tensor: shape=(2, 3), dtype=float32, numpy=
array([[ 0.49671414, -0.1382643 ,  0.64768857],
       [ 1.5230298 , -0.23415338, -0.23413695]], dtype=float32)>
sample_function = <function sample_function.<locals>.func at 0x000001F3F82534C0>

    @pytest.mark.parametrize("num_batch_threads,max_batch_size,batch_timeout_micros,allowed_batch_sizes,max_enqueued_batches,autograph,enable_large_batch_splitting,input_shape,dtype", [
        (1, 2, 1000, None, 10, True, True, [2, 3], "float32"),
        (4, 8, 10000, [2, 4, 8], 20, False, False, [4, 5], "float64"),
    ])
    def test_basic_decorator_functionality(
        self,
        num_batch_threads,
        max_batch_size,
        batch_timeout_micros,
        allowed_batch_sizes,
        max_enqueued_batches,
        autograph,
        enable_large_batch_splitting,
        input_shape,
        dtype,
        mock_batch_function,
        mock_defun,
        mock_tensor_spec,
        mock_pack_sequence_as,
        sample_input_tensor,
        sample_function
    ):
        """
        TC-01: 基本装饰器功能
        测试基本装饰器创建和调用功能
        """
        # Arrange
        # Create input tensor with specified shape and dtype
        if dtype == "float32":
            tf_dtype = tf.float32
            np_dtype = np.float32
        else:
            tf_dtype = tf.float64
            np_dtype = np.float64
    
        input_data = np.random.randn(*input_shape).astype(np_dtype)
        input_tensor = tf.constant(input_data, dtype=tf_dtype)
    
        # Act
        # Create the batch decorator
        batch_decorator = batch_ops.batch_function(
            num_batch_threads=num_batch_threads,
            max_batch_size=max_batch_size,
            batch_timeout_micros=batch_timeout_micros,
            allowed_batch_sizes=allowed_batch_sizes,
            max_enqueued_batches=max_enqueued_batches,
            autograph=autograph,
            enable_large_batch_splitting=enable_large_batch_splitting
        )
    
        # Apply decorator to sample function
        decorated_func = batch_decorator(sample_function)
    
        # Call decorated function
>       result = decorated_func(input_tensor)

tests\test_tensorflow_python_ops_batch_ops.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\ops\batch_ops.py:90: in decorated
    @function.defun(autograph=autograph)
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1092: in __call__
    return self._mock_call(*args, **kwargs)
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1096: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='defun' id='2147351921136'>, args = ()
kwargs = {'autograph': True}
effect = <function mock_defun.<locals>.identity_wrapper at 0x000001F3F8253280>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
                result = next(effect)
                if _is_exception(result):
                    raise result
            else:
>               result = effect(*args, **kwargs)
E               TypeError: identity_wrapper() got an unexpected keyword argument 'autograph'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1157: TypeError
---------------------------- Captured stderr setup ----------------------------
2026-01-21 13:00:44.707200: I tensorflow/core/platform/cpu_feature_guard.cc:151] This TensorFlow binary is optimized with oneAPI Deep Neural Network Library (oneDNN) to use the following CPU instructions in performance-critical operations:  AVX AVX2
To enable them in other operations, rebuild TensorFlow with the appropriate compiler flags.
_ TestBatchOps.test_basic_decorator_functionality[4-8-10000-allowed_batch_sizes1-20-False-False-input_shape1-float64] _

self = <test_tensorflow_python_ops_batch_ops.TestBatchOps object at 0x000001F3F8235880>
num_batch_threads = 4, max_batch_size = 8, batch_timeout_micros = 10000
allowed_batch_sizes = [2, 4, 8], max_enqueued_batches = 20, autograph = False
enable_large_batch_splitting = False, input_shape = [4, 5], dtype = 'float64'
mock_batch_function = <MagicMock name='batch_function' id='2147351835456'>
mock_defun = <MagicMock name='defun' id='2147351994032'>
mock_tensor_spec = <MagicMock name='TensorSpec' id='2147371030944'>
mock_pack_sequence_as = <MagicMock name='pack_sequence_as' id='2147371912544'>
sample_input_tensor = <tf.Tensor: shape=(2, 3), dtype=float32, numpy=
array([[ 0.24196227, -1.9132802 , -1.7249179 ],
       [-0.5622875 , -1.0128311 ,  0.31424734]], dtype=float32)>
sample_function = <function sample_function.<locals>.func at 0x000001F3F9519C10>

    @pytest.mark.parametrize("num_batch_threads,max_batch_size,batch_timeout_micros,allowed_batch_sizes,max_enqueued_batches,autograph,enable_large_batch_splitting,input_shape,dtype", [
        (1, 2, 1000, None, 10, True, True, [2, 3], "float32"),
        (4, 8, 10000, [2, 4, 8], 20, False, False, [4, 5], "float64"),
    ])
    def test_basic_decorator_functionality(
        self,
        num_batch_threads,
        max_batch_size,
        batch_timeout_micros,
        allowed_batch_sizes,
        max_enqueued_batches,
        autograph,
        enable_large_batch_splitting,
        input_shape,
        dtype,
        mock_batch_function,
        mock_defun,
        mock_tensor_spec,
        mock_pack_sequence_as,
        sample_input_tensor,
        sample_function
    ):
        """
        TC-01: 基本装饰器功能
        测试基本装饰器创建和调用功能
        """
        # Arrange
        # Create input tensor with specified shape and dtype
        if dtype == "float32":
            tf_dtype = tf.float32
            np_dtype = np.float32
        else:
            tf_dtype = tf.float64
            np_dtype = np.float64
    
        input_data = np.random.randn(*input_shape).astype(np_dtype)
        input_tensor = tf.constant(input_data, dtype=tf_dtype)
    
        # Act
        # Create the batch decorator
        batch_decorator = batch_ops.batch_function(
            num_batch_threads=num_batch_threads,
            max_batch_size=max_batch_size,
            batch_timeout_micros=batch_timeout_micros,
            allowed_batch_sizes=allowed_batch_sizes,
            max_enqueued_batches=max_enqueued_batches,
            autograph=autograph,
            enable_large_batch_splitting=enable_large_batch_splitting
        )
    
        # Apply decorator to sample function
        decorated_func = batch_decorator(sample_function)
    
        # Call decorated function
>       result = decorated_func(input_tensor)

tests\test_tensorflow_python_ops_batch_ops.py:159: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\ops\batch_ops.py:90: in decorated
    @function.defun(autograph=autograph)
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1092: in __call__
    return self._mock_call(*args, **kwargs)
D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1096: in _mock_call
    return self._execute_mock_call(*args, **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <MagicMock name='defun' id='2147351994032'>, args = ()
kwargs = {'autograph': False}
effect = <function mock_defun.<locals>.identity_wrapper at 0x000001F3F8230D30>

    def _execute_mock_call(self, /, *args, **kwargs):
        # separate from _increment_mock_call so that awaited functions are
        # executed separately from their call, also AsyncMock overrides this method
    
        effect = self.side_effect
        if effect is not None:
            if _is_exception(effect):
                raise effect
            elif not _callable(effect):
                result = next(effect)
                if _is_exception(result):
                    raise result
            else:
>               result = effect(*args, **kwargs)
E               TypeError: identity_wrapper() got an unexpected keyword argument 'autograph'

D:\Coding\Anaconda\envs\testagent-experiment\lib\unittest\mock.py:1157: TypeError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                            Stmts   Miss Branch BrPart  Cover   Missing
-------------------------------------------------------------------------------------------
tests\test_tensorflow_python_ops_batch_ops.py     170     98     26      1    38%   16-18, 45, 73, 84, 94-97, 163-182, 215-270, 303-375, 409-485, 492, 497
-------------------------------------------------------------------------------------------
TOTAL                                             170     98     26      1    38%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_ops_batch_ops.py::TestBatchOps::test_basic_decorator_functionality[1-2-1000-None-10-True-True-input_shape0-float32]
FAILED tests\test_tensorflow_python_ops_batch_ops.py::TestBatchOps::test_basic_decorator_functionality[4-8-10000-allowed_batch_sizes1-20-False-False-input_shape1-float64]
ERROR tests\test_tensorflow_python_ops_batch_ops.py::TestBatchOps::test_parameter_validation[2-4-5000-allowed_batch_sizes0-5-False-False-input_shape0-float64]
ERROR tests\test_tensorflow_python_ops_batch_ops.py::TestBatchOps::test_parameter_validation[1-1-100-allowed_batch_sizes1-1-True-True-input_shape1-float32]
ERROR tests\test_tensorflow_python_ops_batch_ops.py::TestBatchOps::test_error_handling[1-2-1000-allowed_batch_sizes0-10-True-True-input_shape0-float32-True]
ERROR tests\test_tensorflow_python_ops_batch_ops.py::TestBatchOps::test_concurrent_batch_processing[2-4-10000-None-20-True-True-input_shape0-float32-3]
ERROR tests\test_tensorflow_python_ops_batch_ops.py::TestBatchOps::test_concurrent_batch_processing[1-10-5000-None-5-True-True-input_shape1-float32-5]
2 failed, 1 skipped, 5 errors in 2.28s

Error: exit 1