=== Run Tests ===
FFFFFF                                                                   [100%]
================================== FAILURES ===================================
___________________ test_cond_basic_functionality[True-1.0] ___________________

pred_bool = True, expected_value = 1.0
mock_tensorflow_context = (<MagicMock name='executing_eagerly_outside_functions' id='2260658746224'>, <tensorflow.python.eager.context.Context object at 0x0000020E53CAEAF0>)
mock_control_flow_ops = (<MagicMock name='cond_v2' id='2260676428368'>, <MagicMock name='while_loop' id='2260676444656'>, <MagicMock id='2260676460848'>)

    @pytest.mark.parametrize("pred_bool,expected_value", [
        (True, 1.0),
        (False, 0.0),
    ])
    def test_cond_basic_functionality(pred_bool, expected_value, mock_tensorflow_context, mock_control_flow_ops):
        """
        测试cond基本功能：布尔标量控制分支执行
        验证条件分支选择正确，返回值符合预期
        """
        mock_eager, mock_context = mock_tensorflow_context
        mock_cond_v2, mock_while_v2, mock_gen_ops = mock_control_flow_ops
    
        # 设置eager模式
        mock_eager.return_value = True
    
        # 定义测试函数
        true_fn = lambda: tf.constant(1.0)
        false_fn = lambda: tf.constant(0.0)
    
        # 将Python布尔值转换为TensorFlow张量
        pred = tf.constant(pred_bool)
    
        # 执行cond操作
        result = control_flow_ops.cond(pred, true_fn, false_fn)
    
        # weak断言：返回值非空
        assert result is not None, "cond返回值不应为None"
    
        # weak断言：张量类型正确
        assert isinstance(result, tf.Tensor), f"返回值应为tf.Tensor类型，实际为{type(result)}"
    
        # weak断言：数值符合预期
        assert_tensor_equal(result, expected_value)
    
        # 验证cond_v2被调用（在eager模式下）
>       assert mock_cond_v2.called, "cond_v2应被调用"
E       AssertionError: cond_v2应被调用
E       assert False
E        +  where False = <MagicMock name='cond_v2' id='2260676428368'>.called

tests\test_tensorflow_python_ops_control_flow_ops.py:171: AssertionError
__________________ test_cond_basic_functionality[False-0.0] ___________________

pred_bool = False, expected_value = 0.0
mock_tensorflow_context = (<MagicMock name='executing_eagerly_outside_functions' id='2260678299408'>, <tensorflow.python.eager.context.Context object at 0x0000020E5AD10130>)
mock_control_flow_ops = (<MagicMock name='cond_v2' id='2260678277392'>, <MagicMock name='while_loop' id='2260678181456'>, <MagicMock id='2260678255088'>)

    @pytest.mark.parametrize("pred_bool,expected_value", [
        (True, 1.0),
        (False, 0.0),
    ])
    def test_cond_basic_functionality(pred_bool, expected_value, mock_tensorflow_context, mock_control_flow_ops):
        """
        测试cond基本功能：布尔标量控制分支执行
        验证条件分支选择正确，返回值符合预期
        """
        mock_eager, mock_context = mock_tensorflow_context
        mock_cond_v2, mock_while_v2, mock_gen_ops = mock_control_flow_ops
    
        # 设置eager模式
        mock_eager.return_value = True
    
        # 定义测试函数
        true_fn = lambda: tf.constant(1.0)
        false_fn = lambda: tf.constant(0.0)
    
        # 将Python布尔值转换为TensorFlow张量
        pred = tf.constant(pred_bool)
    
        # 执行cond操作
        result = control_flow_ops.cond(pred, true_fn, false_fn)
    
        # weak断言：返回值非空
        assert result is not None, "cond返回值不应为None"
    
        # weak断言：张量类型正确
        assert isinstance(result, tf.Tensor), f"返回值应为tf.Tensor类型，实际为{type(result)}"
    
        # weak断言：数值符合预期
        assert_tensor_equal(result, expected_value)
    
        # 验证cond_v2被调用（在eager模式下）
>       assert mock_cond_v2.called, "cond_v2应被调用"
E       AssertionError: cond_v2应被调用
E       assert False
E        +  where False = <MagicMock name='cond_v2' id='2260678277392'>.called

tests\test_tensorflow_python_ops_control_flow_ops.py:171: AssertionError
______ test_case_basic_functionality[pred_fn_pairs0-<lambda>-False-1.0] _______

pred_fn_pairs = [(<tf.Tensor: shape=(), dtype=bool, numpy=True>, <function <lambda> at 0x0000020E59BFBE50>), (<tf.Tensor: shape=(), dtype=bool, numpy=False>, <function <lambda> at 0x0000020E59BFBEE0>)]
default_fn = <function <lambda> at 0x0000020E59BFBF70>, exclusive = False
expected_value = 1.0
mock_tensorflow_context = (<MagicMock name='executing_eagerly_outside_functions' id='2260678511632'>, <tensorflow.python.eager.context.Context object at 0x0000020E5AEB81C0>)
mock_control_flow_ops = (<MagicMock name='cond_v2' id='2260678493376'>, <MagicMock name='while_loop' id='2260678505616'>, <MagicMock id='2260678459984'>)

    @pytest.mark.parametrize("pred_fn_pairs,default_fn,exclusive,expected_value", [
        (
            [(tf.constant(True), lambda: tf.constant(1.0)), (tf.constant(False), lambda: tf.constant(2.0))],
            lambda: tf.constant(0.0),
            False,
            1.0
        ),
    ])
    def test_case_basic_functionality(pred_fn_pairs, default_fn, exclusive, expected_value,
                                     mock_tensorflow_context, mock_control_flow_ops):
        """
        测试case多分支选择：基本匹配功能
        验证多个条件分支正确匹配第一个真条件
        """
        mock_eager, mock_context = mock_tensorflow_context
        mock_cond_v2, mock_while_v2, mock_gen_ops = mock_control_flow_ops
    
        # 设置eager模式
        mock_eager.return_value = True
    
        # 执行case操作
        result = control_flow_ops.case(pred_fn_pairs, default=default_fn, exclusive=exclusive)
    
        # weak断言：返回值非空
        assert result is not None, "case返回值不应为None"
    
        # weak断言：张量类型正确
        assert isinstance(result, tf.Tensor), f"返回值应为tf.Tensor类型，实际为{type(result)}"
    
        # weak断言：匹配第一个真条件
        # 在这个测试中，第一个条件为True，所以应该返回1.0
        assert_tensor_equal(result, expected_value)
    
        # 验证gen_control_flow_ops可能被调用（在eager模式下）
        # case函数内部可能会调用gen_control_flow_ops模块中的函数
        # 由于我们mock了整个模块，可以检查是否有函数被调用
        # 这里我们只验证测试执行完成，不强制要求调用
    
        # 验证执行环境
>       assert mock_eager.called, "应检查eager模式状态"
E       AssertionError: 应检查eager模式状态
E       assert False
E        +  where False = <MagicMock name='executing_eagerly_outside_functions' id='2260678511632'>.called

tests\test_tensorflow_python_ops_control_flow_ops.py:218: AssertionError
___ test_while_loop_basic_functionality[<lambda>-<lambda>-loop_vars0-10-5] ____

cond_fn = <function <lambda> at 0x0000020E59C0B0D0>
body_fn = <function <lambda> at 0x0000020E59C0B160>
loop_vars = [<tf.Tensor: shape=(), dtype=int32, numpy=0>]
parallel_iterations = 10, expected_value = 5
mock_tensorflow_context = (<MagicMock name='executing_eagerly_outside_functions' id='2260678369488'>, <tensorflow.python.eager.context.Context object at 0x0000020E5AEE61F0>)
mock_control_flow_ops = (<MagicMock name='cond_v2' id='2260678324176'>, <MagicMock name='while_loop' id='2260678278544'>, <MagicMock id='2260678080064'>)

    @pytest.mark.parametrize("cond_fn,body_fn,loop_vars,parallel_iterations,expected_value", [
        (
            lambda i: i < 5,
            lambda i: i + 1,
            [tf.constant(0)],
            10,
            5
        ),
    ])
    def test_while_loop_basic_functionality(cond_fn, body_fn, loop_vars, parallel_iterations, expected_value,
                                           mock_tensorflow_context, mock_control_flow_ops):
        """
        测试while_loop基本循环：固定次数循环执行
        验证循环正确终止，最终值符合预期
        """
        mock_eager, mock_context = mock_tensorflow_context
        mock_cond_v2, mock_while_v2, mock_gen_ops = mock_control_flow_ops
    
        # 设置eager模式
        mock_eager.return_value = True
    
        # 配置while_v2模拟行为
        # 模拟5次循环：0 -> 1 -> 2 -> 3 -> 4 -> 5
        call_count = 0
        def mock_while_side_effect(cond, body, loop_vars, **kwargs):
            nonlocal call_count
            call_count += 1
            if call_count <= 5:
                # 继续循环
                return body(loop_vars[0])
            else:
                # 循环结束
                return loop_vars[0]
    
        mock_while_v2.side_effect = mock_while_side_effect
    
        # 执行while_loop操作
        result = control_flow_ops.while_loop(
            cond_fn,
            body_fn,
            loop_vars,
            parallel_iterations=parallel_iterations
        )
    
        # weak断言：循环正确终止
        # 循环应该执行5次（从0到5）
>       assert call_count == 5, f"循环应执行5次，实际执行{call_count}次"
E       AssertionError: 循环应执行5次，实际执行0次
E       assert 0 == 5

tests\test_tensorflow_python_ops_control_flow_ops.py:268: AssertionError
_________________ test_gradient_verification[cond-eager-True] _________________

func_type = 'cond', mode = 'eager', use_gradient = True
mock_tensorflow_context = (<MagicMock name='executing_eagerly_outside_functions' id='2260678648448'>, <tensorflow.python.eager.context.Context object at 0x0000020E5AECFB50>)
mock_control_flow_ops = (<MagicMock name='cond_v2' id='2260678769632'>, <MagicMock name='while_loop' id='2260678729008'>, <MagicMock id='2260676460704'>)

    @pytest.mark.parametrize("func_type,mode,use_gradient", [
        ("cond", "eager", True),
    ])
    def test_gradient_verification(func_type, mode, use_gradient, mock_tensorflow_context, mock_control_flow_ops):
        """
        测试梯度计算验证：控制流中的自动微分
        验证cond操作在梯度计算时的正确性
        """
        mock_eager, mock_context = mock_tensorflow_context
        mock_cond_v2, mock_while_v2, mock_gen_ops = mock_control_flow_ops
    
        # 设置执行模式
        if mode == "eager":
            mock_eager.return_value = True
        else:
            mock_eager.return_value = False
    
        # 注意：在真实测试中，我们不应该mock梯度计算，因为我们要测试真实的梯度行为
        # 但为了测试的可靠性，我们使用真实的TensorFlow梯度计算
    
        # 创建可训练变量
        x = tf.Variable(2.0)
    
        # 定义测试函数
        def true_fn():
            return x * 3.0
    
        def false_fn():
            return x * 1.0
    
        # 执行cond操作
        pred = tf.constant(True)
        result = control_flow_ops.cond(pred, true_fn, false_fn)
    
        # weak断言：梯度计算可执行
        if use_gradient:
            # 计算梯度 - 使用真实的TensorFlow梯度计算
            with tf.GradientTape() as tape:
                tape.watch(x)
                y = control_flow_ops.cond(pred, true_fn, false_fn)
            grad = tape.gradient(y, x)
    
            # weak断言：梯度非None
            assert grad is not None, "梯度计算结果不应为None"
    
            # weak断言：梯度形状正确
            assert grad.shape == (), f"梯度形状应为标量，实际为{grad.shape}"
    
            # 验证梯度数值（在eager模式下，pred=True时，y=x*3.0，梯度应为3.0）
            # 注意：由于我们mock了cond_v2，实际梯度计算可能受影响
            # 但我们仍然可以验证梯度计算过程正常
            assert_tensor_equal(grad, 3.0, rtol=1e-6, atol=1e-6)
        else:
            # 如果不使用梯度，只验证基本功能
            assert result is not None, "cond返回值不应为None"
            assert_tensor_equal(result, 6.0)  # x=2.0 * 3.0 = 6.0
    
        # 验证cond_v2被调用（在eager模式下）
        if mode == "eager":
>           assert mock_cond_v2.called, "在eager模式下，cond_v2应被调用"
E           AssertionError: 在eager模式下，cond_v2应被调用
E           assert False
E            +  where False = <MagicMock name='cond_v2' id='2260678769632'>.called

tests\test_tensorflow_python_ops_control_flow_ops.py:352: AssertionError
________________ test_eager_graph_mode_consistency[cond-True] _________________

func_type = 'cond', compare_modes = True
mock_tensorflow_context = (<MagicMock name='executing_eagerly_outside_functions' id='2260679284768'>, <tensorflow.python.eager.context.Context object at 0x0000020E5AF3DC70>)
mock_control_flow_ops = (<MagicMock name='cond_v2' id='2260679271280'>, <MagicMock name='while_loop' id='2260679140160'>, <MagicMock id='2260679250656'>)
mock_graph_context = <MagicMock name='get_default_graph' id='2260679164016'>

    @pytest.mark.parametrize("func_type,compare_modes", [
        ("cond", True),
    ])
    def test_eager_graph_mode_consistency(func_type, compare_modes, mock_tensorflow_context, mock_control_flow_ops, mock_graph_context):
        """
        测试eager与graph模式一致性
        验证cond操作在两种执行模式下结果相同
        """
        mock_eager, mock_context = mock_tensorflow_context
        mock_cond_v2, mock_while_v2, mock_gen_ops = mock_control_flow_ops
        mock_graph = mock_graph_context
    
        if func_type == "cond":
            # 测试cond函数在eager和graph模式下的一致性
    
            # 首先测试eager模式
            mock_eager.return_value = True  # 设置为eager模式
    
            # 定义测试函数
            def true_fn():
                return tf.constant(5.0)
    
            def false_fn():
                return tf.constant(10.0)
    
            # 在eager模式下执行cond
            pred = tf.constant(True)
            eager_result = control_flow_ops.cond(pred, true_fn, false_fn)
    
            # weak断言：eager模式结果非空
            assert eager_result is not None, "eager模式下的cond返回值不应为None"
    
            # 验证cond_v2在eager模式下被调用
>           assert mock_cond_v2.called, "在eager模式下，cond_v2应被调用"
E           AssertionError: 在eager模式下，cond_v2应被调用
E           assert False
E            +  where False = <MagicMock name='cond_v2' id='2260679271280'>.called

tests\test_tensorflow_python_ops_control_flow_ops.py:392: AssertionError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                                   Stmts   Miss Branch BrPart  Cover   Missing
--------------------------------------------------------------------------------------------------
tests\test_tensorflow_python_ops_control_flow_ops.py     183     57     40      8    60%   17-18, 57-66, 73-76, 100, 114->116, 117, 122-125, 129-132, 174-175, 248-254, 272-289, 308, 321, 347-348, 355, 382, 395-435, 440
--------------------------------------------------------------------------------------------------
TOTAL                                                    183     57     40      8    60%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_ops_control_flow_ops.py::test_cond_basic_functionality[True-1.0]
FAILED tests\test_tensorflow_python_ops_control_flow_ops.py::test_cond_basic_functionality[False-0.0]
FAILED tests\test_tensorflow_python_ops_control_flow_ops.py::test_case_basic_functionality[pred_fn_pairs0-<lambda>-False-1.0]
FAILED tests\test_tensorflow_python_ops_control_flow_ops.py::test_while_loop_basic_functionality[<lambda>-<lambda>-loop_vars0-10-5]
FAILED tests\test_tensorflow_python_ops_control_flow_ops.py::test_gradient_verification[cond-eager-True]
FAILED tests\test_tensorflow_python_ops_control_flow_ops.py::test_eager_graph_mode_consistency[cond-True]
6 failed in 1.63s

Error: exit 1