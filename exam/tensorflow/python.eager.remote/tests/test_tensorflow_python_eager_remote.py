"""
Test cases for tensorflow.python.eager.remote module.
Generated by ATTest.
"""

# ==== BLOCK:HEADER START ====
# Test fixtures and helper functions
import pytest
import unittest.mock as mock
from tensorflow.python.eager import remote
from tensorflow.python.eager import context
from tensorflow.python import pywrap_tfe
from tensorflow.python.training import server_lib
from tensorflow.core.protobuf.tensorflow_server_pb2 import ServerDef
from tensorflow.core.protobuf import config_pb2
from tensorflow.core.protobuf import cluster_pb2


@pytest.fixture
def mock_context_functions():
    """Mock context functions to avoid actual network calls."""
    # Create a real ConfigProto for context
    config_proto = config_pb2.ConfigProto()
    
    # Create a mock context with real config
    mock_ctx = mock.MagicMock()
    mock_ctx.configure_mock(config=config_proto)
    mock_ctx.coordination_service = None
    
    # Mock set_server_def and update_server_def methods
    with mock.patch.object(context, 'set_server_def') as mock_set_server_def:
        with mock.patch.object(context, 'update_server_def') as mock_update_server_def:
            with mock.patch.object(context, 'get_server_def', return_value=None):
                with mock.patch.object(context, 'executing_eagerly', return_value=True):
                    with mock.patch.object(context, 'context', return_value=mock_ctx):
                        # Also mock pywrap_tfe.TF_PickUnusedPortOrDie for local job addition
                        with mock.patch.object(pywrap_tfe, 'TF_PickUnusedPortOrDie', return_value=12345):
                            yield {
                                'set_server_def': mock_set_server_def,
                                'update_server_def': mock_update_server_def,
                                'context': mock_ctx
                            }


@pytest.fixture
def mock_context():
    """Mock context to ensure eager mode is enabled and provide proper config."""
    # Create a real ConfigProto
    config_proto = config_pb2.ConfigProto()
    
    # Create a mock context with real config
    mock_ctx = mock.MagicMock()
    mock_ctx.configure_mock(config=config_proto)
    mock_ctx.coordination_service = None
    
    with mock.patch.object(context, 'executing_eagerly', return_value=True):
        with mock.patch.object(context, 'context', return_value=mock_ctx):
            with mock.patch.object(context, 'get_server_def', return_value=None):
                # Mock set_server_def and update_server_def
                with mock.patch.object(context, 'set_server_def') as mock_set_server_def:
                    with mock.patch.object(context, 'update_server_def') as mock_update_server_def:
                        # Also mock pywrap_tfe.TF_PickUnusedPortOrDie
                        with mock.patch.object(pywrap_tfe, 'TF_PickUnusedPortOrDie', return_value=12345):
                            yield {
                                'context': mock_ctx,
                                'set_server_def': mock_set_server_def,
                                'update_server_def': mock_update_server_def
                            }


def create_mock_cluster_spec(hosts_dict):
    """Create a mock ClusterSpec for testing."""
    # Create a real ClusterDef
    cluster_def = cluster_pb2.ClusterDef()
    
    for job_name, hosts in hosts_dict.items():
        job_def = cluster_def.job.add()
        job_def.name = job_name
        if isinstance(hosts, list):
            for i, host in enumerate(hosts):
                job_def.tasks[i] = host
        elif isinstance(hosts, dict):
            for task_index, host in hosts.items():
                job_def.tasks[task_index] = host
    
    # Create a mock ClusterSpec that returns the real ClusterDef
    cluster_spec = mock.MagicMock(spec=server_lib.ClusterSpec)
    cluster_spec.as_cluster_def.return_value = cluster_def
    cluster_spec.jobs.return_value = list(hosts_dict.keys())
    cluster_spec.num_tasks.return_value = lambda job: len(hosts_dict.get(job, []))
    
    return cluster_spec
# ==== BLOCK:HEADER END ====


# ==== BLOCK:CASE_01 START ====
def test_connect_to_remote_host_basic(mock_context):
    """Test basic functionality of connect_to_remote_host (TC-01)."""
    # Arrange
    remote_host = "localhost:12345"
    job_name = "worker"
    
    # Act - Use the mock_context fixture which provides proper mocks
    remote.connect_to_remote_host(remote_host, job_name)
    
    # Assert (weak assertions)
    # 1. No exception raised
    # 2. Mock was called
    # 3. Context was updated
    mock_set_server_def = mock_context['set_server_def']
    assert mock_set_server_def.called, "set_server_def should be called"
    
    # Verify the call was made with appropriate arguments
    call_args = mock_set_server_def.call_args
    assert call_args is not None, "Should have call arguments"
    
    # Check that context was accessed for eager mode
    assert context.executing_eagerly.called, "Should check eager execution mode"
    
    # Verify the call was made with ServerDef
    server_def_arg = call_args[0][0]  # First argument to set_server_def
    assert isinstance(server_def_arg, ServerDef), "Should pass ServerDef to set_server_def"
    assert server_def_arg.job_name == "localhost", "Default job_name should be 'localhost' for cluster connection"
    assert server_def_arg.task_index == 0, "Default task_index should be 0"
# ==== BLOCK:CASE_01 END ====


# ==== BLOCK:CASE_02 START ====
def test_connect_to_remote_host_default_job_name(mock_context):
    """Test default parameter values for connect_to_remote_host (TC-02)."""
    # Arrange
    remote_host = "127.0.0.1:8080"
    
    # Act - call with only remote_host, using default job_name
    remote.connect_to_remote_host(remote_host)
    
    # Assert (weak assertions)
    # 1. No exception raised
    # 2. Default job_name should be used
    # 3. Mock was called once
    mock_set_server_def = mock_context['set_server_def']
    
    assert mock_set_server_def.called, "set_server_def should be called"
    assert mock_set_server_def.call_count == 1, "Should be called exactly once"
    
    # Verify default job_name behavior
    # The function should use default job_name="worker" for remote_host
    # but cluster connection uses default job_name="localhost"
    call_args = mock_set_server_def.call_args
    assert call_args is not None, "Should have call arguments"
    
    # Check that context was accessed for eager mode
    assert context.executing_eagerly.called, "Should check eager execution mode"
    
    # Verify the ServerDef has correct job_name
    server_def_arg = call_args[0][0]
    assert isinstance(server_def_arg, ServerDef), "Should pass ServerDef to set_server_def"
    assert server_def_arg.job_name == "localhost", "Cluster connection should use default job_name 'localhost'"
# ==== BLOCK:CASE_02 END ====


# ==== BLOCK:CASE_03 START ====
def test_connect_to_cluster_eager_mode_required(mock_context_functions):
    """Test that connect_to_cluster requires eager mode (TC-03)."""
    # Arrange
    # Create a proper mock ClusterSpec with real ClusterDef
    cluster_spec = create_mock_cluster_spec({"worker": ["localhost:2222"]})
    
    # Get mocks from fixture
    mock_set_server_def = mock_context_functions['set_server_def']
    mock_update_server_def = mock_context_functions['update_server_def']
    mock_ctx = mock_context_functions['context']
    
    # Test 1: Non-eager mode should raise ValueError
    with mock.patch.object(context, 'executing_eagerly', return_value=False):
        with mock.patch.object(context, 'context', return_value=mock_ctx):
            with mock.patch.object(context, 'get_server_def', return_value=None):
                # Act & Assert
                with pytest.raises(ValueError) as exc_info:
                    remote.connect_to_cluster(cluster_spec, job_name="localhost", task_index=0)
                
                # Verify the error message
                error_msg = str(exc_info.value)
                assert "eager mode" in error_msg.lower(), "Error should mention eager mode requirement"
                
                # Verify that context functions were NOT called
                assert not mock_set_server_def.called, "Should not call server functions in non-eager mode"
                assert not mock_update_server_def.called, "Should not call update functions in non-eager mode"
    
    # Reset mocks for second test
    mock_set_server_def.reset_mock()
    mock_update_server_def.reset_mock()
    
    # Test 2: Should work in eager mode
    with mock.patch.object(context, 'executing_eagerly', return_value=True):
        with mock.patch.object(context, 'context', return_value=mock_ctx):
            with mock.patch.object(context, 'get_server_def', return_value=None):
                # This should not raise an exception
                remote.connect_to_cluster(cluster_spec, job_name="localhost", task_index=0)
                assert mock_set_server_def.called, "Should call set_server_def in eager mode"
                
                # Verify ServerDef was created with correct parameters
                call_args = mock_set_server_def.call_args
                assert call_args is not None, "Should have call arguments"
                server_def_arg = call_args[0][0]
                assert isinstance(server_def_arg, ServerDef), "Should pass ServerDef to set_server_def"
                assert server_def_arg.job_name == "localhost", "Job name should be 'localhost'"
                assert server_def_arg.task_index == 0, "Task index should be 0"
# ==== BLOCK:CASE_03 END ====


# ==== BLOCK:CASE_04 START ====
def test_connect_to_remote_host_multiple_calls_overwrite(mock_context):
    """Test that multiple calls to connect_to_remote_host overwrite previous config (TC-04)."""
    # Arrange
    first_host = "host1:1111"
    second_host = "host2:2222"
    job_name = "worker"
    
    # Get mocks from fixture
    mock_set_server_def = mock_context['set_server_def']
    mock_update_server_def = mock_context['update_server_def']
    
    # Mock get_server_def to simulate existing server configuration
    # First call: no existing server def
    # Second call: simulate existing server def to trigger update
    server_def_calls = []
    
    def mock_get_server_def():
        if len(server_def_calls) == 0:
            # First call - no server def
            return None
        else:
            # Second call - return a mock server def to trigger update
            mock_server_def = mock.MagicMock(spec=ServerDef)
            mock_server_def.job_name = "localhost"
            mock_server_def.task_index = 0
            mock_server_def.cluster = cluster_pb2.ClusterDef()
            return mock_server_def
    
    with mock.patch.object(context, 'get_server_def', side_effect=mock_get_server_def):
        # Act - First call
        remote.connect_to_remote_host(first_host, job_name)
        server_def_calls.append(1)
        
        # Get initial call count
        initial_set_calls = mock_set_server_def.call_count
        initial_update_calls = mock_update_server_def.call_count
        
        # Act - Second call (should overwrite)
        remote.connect_to_remote_host(second_host, job_name)
        server_def_calls.append(2)
        
        # Assert (weak assertions)
        # 1. No exception raised
        # 2. Mock was called at least twice
        # 3. Update may be called for the second invocation if server def changed
        
        # First call should use set_server_def
        assert mock_set_server_def.call_count >= 1, "set_server_def should be called at least once"
        
        # Total calls to server functions should be at least 2
        total_calls = mock_set_server_def.call_count + mock_update_server_def.call_count
        assert total_calls >= 2, f"Expected at least 2 server calls, got {total_calls}"
        
        # Verify context was checked for eager mode
        assert context.executing_eagerly.called, "Should check eager execution mode"
        
        # Verify both calls created ServerDef objects
        if mock_set_server_def.call_args_list:
            for call_args in mock_set_server_def.call_args_list:
                server_def_arg = call_args[0][0]
                assert isinstance(server_def_arg, ServerDef), "Should pass ServerDef to set_server_def"
# ==== BLOCK:CASE_04 END ====


# ==== BLOCK:CASE_05 START ====
# Placeholder for CASE_05: DEFERRED_SET placeholder
# ==== BLOCK:CASE_05 END ====


# ==== BLOCK:CASE_06 START ====
# Placeholder for CASE_06: DEFERRED_SET placeholder
# ==== BLOCK:CASE_06 END ====


# ==== BLOCK:CASE_07 START ====
# Placeholder for CASE_07: DEFERRED_SET placeholder
# ==== BLOCK:CASE_07 END ====


# ==== BLOCK:FOOTER START ====
# Additional test utilities and cleanup
def test_placeholder():
    """Placeholder test to ensure file is valid."""
    pass


# Test for invalid inputs (not in SMOKE_SET but good to have)
def test_connect_to_remote_host_invalid_input():
    """Test that connect_to_remote_host raises ValueError for invalid input."""
    # Test with None remote_host
    with pytest.raises(ValueError) as exc_info:
        remote.connect_to_remote_host(None)
    
    error_msg = str(exc_info.value).lower()
    assert "remote_host" in error_msg or "must provide" in error_msg, \
        f"Error message should mention remote_host or 'must provide', got: {error_msg}"
    
    # Test with empty string - should raise ValueError
    with pytest.raises(ValueError) as exc_info:
        remote.connect_to_remote_host("")
    
    error_msg = str(exc_info.value).lower()
    assert "remote_host" in error_msg or "must provide" in error_msg, \
        f"Error message should mention remote_host or 'must provide' for empty string, got: {error_msg}"
    
    # Test with empty list - should raise ValueError
    with pytest.raises(ValueError) as exc_info:
        remote.connect_to_remote_host([])
    
    error_msg = str(exc_info.value).lower()
    assert "remote_host" in error_msg or "must provide" in error_msg, \
        f"Error message should mention remote_host or 'must provide' for empty list, got: {error_msg}"
    
    # Test with empty string in list - should also raise ValueError
    with pytest.raises(ValueError) as exc_info:
        remote.connect_to_remote_host([""])
    
    error_msg = str(exc_info.value).lower()
    assert "remote_host" in error_msg or "must provide" in error_msg, \
        f"Error message should mention remote_host or 'must provide' for list with empty string, got: {error_msg}"


# Test for cluster_spec validation
def test_connect_to_cluster_invalid_cluster_spec():
    """Test that connect_to_cluster raises ValueError for invalid cluster_spec."""
    # Test with string (not a cluster spec)
    invalid_spec = "not a cluster spec"
    
    # Mock context.context() to return a proper mock with config attribute
    mock_ctx = mock.MagicMock()
    mock_config = mock.MagicMock()
    mock_ctx.configure_mock(config=mock_config)
    
    with mock.patch.object(context, 'executing_eagerly', return_value=True):
        with mock.patch.object(context, 'context', return_value=mock_ctx):
            with pytest.raises(ValueError) as exc_info:
                remote.connect_to_cluster(invalid_spec)
            
            error_msg = str(exc_info.value).lower()
            # Check for specific error messages that might be raised
            assert "clusterspec" in error_msg or "clusterresolver" in error_msg or "type" in error_msg, \
                f"Error message should mention ClusterSpec/ClusterResolver or type, got: {error_msg}"
    
    # Test with None cluster_spec
    with mock.patch.object(context, 'executing_eagerly', return_value=True):
        with mock.patch.object(context, 'context', return_value=mock_ctx):
            with pytest.raises(ValueError) as exc_info:
                remote.connect_to_cluster(None)
            
            error_msg = str(exc_info.value).lower()
            assert "clusterspec" in error_msg or "clusterresolver" in error_msg or "type" in error_msg, \
                f"Error message should mention ClusterSpec/ClusterResolver or type for None, got: {error_msg}"
    
    # Test with empty dict (invalid cluster spec)
    with mock.patch.object(context, 'executing_eagerly', return_value=True):
        with mock.patch.object(context, 'context', return_value=mock_ctx):
            with pytest.raises(ValueError) as exc_info:
                remote.connect_to_cluster({})
            
            error_msg = str(exc_info.value).lower()
            assert "clusterspec" in error_msg or "clusterresolver" in error_msg or "type" in error_msg, \
                f"Error message should mention ClusterSpec/ClusterResolver or type for empty dict, got: {error_msg}"


# Test for invalid task_index
def test_connect_to_cluster_invalid_task_index():
    """Test that connect_to_cluster raises ValueError for invalid task_index."""
    # Create a valid cluster spec
    cluster_spec = create_mock_cluster_spec({"worker": ["localhost:2222"]})
    
    # Mock context.context() to return a proper mock with config attribute
    mock_ctx = mock.MagicMock()
    mock_config = mock.MagicMock()
    mock_ctx.configure_mock(config=mock_config)
    
    with mock.patch.object(context, 'executing_eagerly', return_value=True):
        with mock.patch.object(context, 'context', return_value=mock_ctx):
            # Test with negative task_index
            with pytest.raises(ValueError) as exc_info:
                remote.connect_to_cluster(cluster_spec, task_index=-1)
            
            error_msg = str(exc_info.value).lower()
            assert "task_index" in error_msg or "negative" in error_msg or "invalid" in error_msg, \
                f"Error message should mention task_index for negative value, got: {error_msg}"
# ==== BLOCK:FOOTER END ====