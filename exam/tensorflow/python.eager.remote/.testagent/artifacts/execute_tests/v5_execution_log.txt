=== Run Tests ===
.....F.F                                                                 [100%]
================================== FAILURES ===================================
__________________ test_connect_to_remote_host_invalid_input __________________

    def test_connect_to_remote_host_invalid_input():
        """Test that connect_to_remote_host raises ValueError for invalid input."""
        # Test with None remote_host
        with pytest.raises(ValueError) as exc_info:
            remote.connect_to_remote_host(None)
    
        error_msg = str(exc_info.value).lower()
        assert "remote_host" in error_msg or "must provide" in error_msg, \
            f"Error message should mention remote_host or 'must provide', got: {error_msg}"
    
        # Test with empty string - should raise ValueError
        with pytest.raises(ValueError) as exc_info:
            remote.connect_to_remote_host("")
    
        error_msg = str(exc_info.value).lower()
        assert "remote_host" in error_msg or "must provide" in error_msg, \
            f"Error message should mention remote_host or 'must provide' for empty string, got: {error_msg}"
    
        # Test with empty list - should raise ValueError
        with pytest.raises(ValueError) as exc_info:
            remote.connect_to_remote_host([])
    
        error_msg = str(exc_info.value).lower()
        assert "remote_host" in error_msg or "must provide" in error_msg, \
            f"Error message should mention remote_host or 'must provide' for empty list, got: {error_msg}"
    
        # Test with empty string in list - should also raise ValueError
        with pytest.raises(ValueError) as exc_info:
>           remote.connect_to_remote_host([""])
E           Failed: DID NOT RAISE <class 'ValueError'>

tests\test_tensorflow_python_eager_remote.py:328: Failed
_________________ test_connect_to_cluster_invalid_task_index __________________

    def test_connect_to_cluster_invalid_task_index():
        """Test that connect_to_cluster raises ValueError for invalid task_index."""
        # Create a valid cluster spec
        cluster_spec = create_mock_cluster_spec({"worker": ["localhost:2222"]})
    
        # Mock context.context() to return a proper mock with config attribute
        mock_ctx = mock.MagicMock()
        mock_config = mock.MagicMock()
        mock_ctx.configure_mock(config=mock_config)
    
        with mock.patch.object(context, 'executing_eagerly', return_value=True):
            with mock.patch.object(context, 'context', return_value=mock_ctx):
                # Test with negative task_index
                with pytest.raises(ValueError) as exc_info:
>                   remote.connect_to_cluster(cluster_spec, task_index=-1)

tests\test_tensorflow_python_eager_remote.py:392: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cluster_spec_or_resolver = <MagicMock spec='ClusterSpec' id='1684703604016'>
job_name = 'localhost', task_index = -1, protocol = 'grpc'
make_master_device_default = True, cluster_device_filters = None

    @tf_export("config.experimental_connect_to_cluster")
    def connect_to_cluster(cluster_spec_or_resolver,
                           job_name="localhost",
                           task_index=0,
                           protocol=None,
                           make_master_device_default=True,
                           cluster_device_filters=None):
      """Connects to the given cluster.
    
      Will make devices on the cluster available to use. Note that calling this more
      than once will work, but will invalidate any tensor handles on the old remote
      devices.
    
      If the given local job name is not present in the cluster specification, it
      will be automatically added, using an unused port on the localhost.
    
      Device filters can be specified to isolate groups of remote tasks to avoid
      undesired accesses between workers. Workers accessing resources or launching
      ops / functions on filtered remote devices will result in errors (unknown
      devices). For any remote task, if no device filter is present, all cluster
      devices will be visible; if any device filter is specified, it can only
      see devices matching at least one filter. Devices on the task itself are
      always visible. Device filters can be particially specified.
    
      For example, for a cluster set up for parameter server training, the following
      device filters might be specified:
    
      ```python
      cdf = tf.config.experimental.ClusterDeviceFilters()
      # For any worker, only the devices on PS nodes and itself are visible
      for i in range(num_workers):
        cdf.set_device_filters('worker', i, ['/job:ps'])
      # Similarly for any ps, only the devices on workers and itself are visible
      for i in range(num_ps):
        cdf.set_device_filters('ps', i, ['/job:worker'])
    
      tf.config.experimental_connect_to_cluster(cluster_def,
                                                cluster_device_filters=cdf)
      ```
    
      Args:
        cluster_spec_or_resolver: A `ClusterSpec` or `ClusterResolver` describing
          the cluster.
        job_name: The name of the local job.
        task_index: The local task index.
        protocol: The communication protocol, such as `"grpc"`. If unspecified, will
          use the default from `python/platform/remote_utils.py`.
        make_master_device_default: If True and a cluster resolver is passed, will
          automatically enter the master task device scope, which indicates the
          master becomes the default device to run ops. It won't do anything if
          a cluster spec is passed. Will throw an error if the caller is currently
          already in some device scope.
        cluster_device_filters: an instance of
          `tf.train.experimental/ClusterDeviceFilters` that specify device filters
          to the remote tasks in cluster.
      """
      if not context.executing_eagerly():
        raise ValueError(
            "`tf.config.experimental_connect_to_cluster` can only be called in "
            "eager mode."
        )
      protocol = protocol or remote_utils.get_default_communication_protocol()
      if isinstance(cluster_spec_or_resolver, server_lib.ClusterSpec):
        cluster_spec = cluster_spec_or_resolver
      elif isinstance(cluster_spec_or_resolver, cluster_resolver.ClusterResolver):
        if cluster_spec_or_resolver.master() in _LOCAL_MASTERS:
          # Do nothing if the master is local.
          return
        cluster_spec = cluster_spec_or_resolver.cluster_spec()
      else:
        raise ValueError(
            "`cluster_spec_or_resolver` must be a `ClusterSpec` or a "
            "`ClusterResolver`.")
    
      cluster_def = copy.deepcopy(cluster_spec.as_cluster_def())
      if cluster_device_filters:
        if isinstance(cluster_device_filters, server_lib.ClusterDeviceFilters):
          cluster_device_filters = copy.deepcopy(
              cluster_device_filters._as_cluster_device_filters())  # pylint: disable=protected-access
        else:
          raise ValueError("`cluster_device_filters` must be an instance of "
                           "`tf.train.experimental.ClusterDeviceFilters`.")
    
      # Check whether the server def has changed. We need to do the check before the
      # local job is added to the cluster.
      is_server_def_changed = False
      current_server_def = context.get_server_def()
      if current_server_def and job_name not in cluster_spec.jobs:
        for i, job in enumerate(current_server_def.cluster.job):
          if job.name == job_name:
            del current_server_def.cluster.job[i]
      if (current_server_def is None or current_server_def.cluster != cluster_def or
          current_server_def.job_name != job_name or
          current_server_def.task_index != task_index):
        is_server_def_changed = True
    
      # Automatically add local job, if not part of the cluster spec.
      if job_name not in cluster_spec.jobs:
        local_port = pywrap_tfe.TF_PickUnusedPortOrDie()
        job_def = cluster_def.job.add()
        job_def.name = job_name
        # TODO(fishx): Update this to make sure remote worker has valid ip address
        # to connect with local.
        job_def.tasks[0] = "localhost:{}".format(local_port)
    
      if context.context().coordination_service is None:
        # Maybe enable coordination service for the communication protocol
        coordination_service = remote_utils.coordination_service_type(protocol)
        if coordination_service:
          context.context().configure_coordination_service(coordination_service)
    
>     server_def = ServerDef(
          cluster=cluster_def,
          job_name=job_name,
          task_index=task_index,
          protocol=protocol,
          default_session_config=context.context().config,
          cluster_device_filters=cluster_device_filters)
E     TypeError: Parameter to MergeFrom() must be instance of same class: expected tensorflow.ConfigProto got MagicMock.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:187: TypeError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                           Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------------------
tests\test_tensorflow_python_eager_remote.py     186      6     16      2    94%   82-84, 270->exit, 330-331, 394
------------------------------------------------------------------------------------------
TOTAL                                            186      6     16      2    94%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_eager_remote.py::test_connect_to_remote_host_invalid_input
FAILED tests\test_tensorflow_python_eager_remote.py::test_connect_to_cluster_invalid_task_index
2 failed, 6 passed in 1.59s

Error: exit 1