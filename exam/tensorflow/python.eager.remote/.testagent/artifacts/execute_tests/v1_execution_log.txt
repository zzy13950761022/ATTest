=== Run Tests ===
FFFF...                                                                  [100%]
================================== FAILURES ===================================
______________________ test_connect_to_remote_host_basic ______________________

mock_pywrap_tfe = {'set_server_def': <MagicMock name='TFE_ContextSetServerDef' id='2415811619328'>, 'update_server_def': <MagicMock name='TFE_ContextUpdateServerDef' id='2415811618080'>}
mock_context = None

    def test_connect_to_remote_host_basic(mock_pywrap_tfe, mock_context):
        """Test basic functionality of connect_to_remote_host (TC-01)."""
        # Arrange
        remote_host = "localhost:12345"
        job_name = "worker"
    
        # Act
>       remote.connect_to_remote_host(remote_host, job_name)

tests\test_tensorflow_python_eager_remote.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:73: in connect_to_remote_host
    connect_to_cluster(cluster_spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cluster_spec_or_resolver = ClusterSpec({'worker': ['localhost:12345']})
job_name = 'localhost', task_index = 0, protocol = 'grpc'
make_master_device_default = True, cluster_device_filters = None

    @tf_export("config.experimental_connect_to_cluster")
    def connect_to_cluster(cluster_spec_or_resolver,
                           job_name="localhost",
                           task_index=0,
                           protocol=None,
                           make_master_device_default=True,
                           cluster_device_filters=None):
      """Connects to the given cluster.
    
      Will make devices on the cluster available to use. Note that calling this more
      than once will work, but will invalidate any tensor handles on the old remote
      devices.
    
      If the given local job name is not present in the cluster specification, it
      will be automatically added, using an unused port on the localhost.
    
      Device filters can be specified to isolate groups of remote tasks to avoid
      undesired accesses between workers. Workers accessing resources or launching
      ops / functions on filtered remote devices will result in errors (unknown
      devices). For any remote task, if no device filter is present, all cluster
      devices will be visible; if any device filter is specified, it can only
      see devices matching at least one filter. Devices on the task itself are
      always visible. Device filters can be particially specified.
    
      For example, for a cluster set up for parameter server training, the following
      device filters might be specified:
    
      ```python
      cdf = tf.config.experimental.ClusterDeviceFilters()
      # For any worker, only the devices on PS nodes and itself are visible
      for i in range(num_workers):
        cdf.set_device_filters('worker', i, ['/job:ps'])
      # Similarly for any ps, only the devices on workers and itself are visible
      for i in range(num_ps):
        cdf.set_device_filters('ps', i, ['/job:worker'])
    
      tf.config.experimental_connect_to_cluster(cluster_def,
                                                cluster_device_filters=cdf)
      ```
    
      Args:
        cluster_spec_or_resolver: A `ClusterSpec` or `ClusterResolver` describing
          the cluster.
        job_name: The name of the local job.
        task_index: The local task index.
        protocol: The communication protocol, such as `"grpc"`. If unspecified, will
          use the default from `python/platform/remote_utils.py`.
        make_master_device_default: If True and a cluster resolver is passed, will
          automatically enter the master task device scope, which indicates the
          master becomes the default device to run ops. It won't do anything if
          a cluster spec is passed. Will throw an error if the caller is currently
          already in some device scope.
        cluster_device_filters: an instance of
          `tf.train.experimental/ClusterDeviceFilters` that specify device filters
          to the remote tasks in cluster.
      """
      if not context.executing_eagerly():
        raise ValueError(
            "`tf.config.experimental_connect_to_cluster` can only be called in "
            "eager mode."
        )
      protocol = protocol or remote_utils.get_default_communication_protocol()
      if isinstance(cluster_spec_or_resolver, server_lib.ClusterSpec):
        cluster_spec = cluster_spec_or_resolver
      elif isinstance(cluster_spec_or_resolver, cluster_resolver.ClusterResolver):
        if cluster_spec_or_resolver.master() in _LOCAL_MASTERS:
          # Do nothing if the master is local.
          return
        cluster_spec = cluster_spec_or_resolver.cluster_spec()
      else:
        raise ValueError(
            "`cluster_spec_or_resolver` must be a `ClusterSpec` or a "
            "`ClusterResolver`.")
    
      cluster_def = copy.deepcopy(cluster_spec.as_cluster_def())
      if cluster_device_filters:
        if isinstance(cluster_device_filters, server_lib.ClusterDeviceFilters):
          cluster_device_filters = copy.deepcopy(
              cluster_device_filters._as_cluster_device_filters())  # pylint: disable=protected-access
        else:
          raise ValueError("`cluster_device_filters` must be an instance of "
                           "`tf.train.experimental.ClusterDeviceFilters`.")
    
      # Check whether the server def has changed. We need to do the check before the
      # local job is added to the cluster.
      is_server_def_changed = False
      current_server_def = context.get_server_def()
      if current_server_def and job_name not in cluster_spec.jobs:
        for i, job in enumerate(current_server_def.cluster.job):
          if job.name == job_name:
            del current_server_def.cluster.job[i]
      if (current_server_def is None or current_server_def.cluster != cluster_def or
          current_server_def.job_name != job_name or
          current_server_def.task_index != task_index):
        is_server_def_changed = True
    
      # Automatically add local job, if not part of the cluster spec.
      if job_name not in cluster_spec.jobs:
        local_port = pywrap_tfe.TF_PickUnusedPortOrDie()
        job_def = cluster_def.job.add()
        job_def.name = job_name
        # TODO(fishx): Update this to make sure remote worker has valid ip address
        # to connect with local.
        job_def.tasks[0] = "localhost:{}".format(local_port)
    
      if context.context().coordination_service is None:
        # Maybe enable coordination service for the communication protocol
        coordination_service = remote_utils.coordination_service_type(protocol)
        if coordination_service:
          context.context().configure_coordination_service(coordination_service)
    
>     server_def = ServerDef(
          cluster=cluster_def,
          job_name=job_name,
          task_index=task_index,
          protocol=protocol,
          default_session_config=context.context().config,
          cluster_device_filters=cluster_device_filters)
E     TypeError: Parameter to MergeFrom() must be instance of same class: expected tensorflow.ConfigProto got MagicMock.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:187: TypeError
________________ test_connect_to_remote_host_default_job_name _________________

mock_pywrap_tfe = {'set_server_def': <MagicMock name='TFE_ContextSetServerDef' id='2415811817968'>, 'update_server_def': <MagicMock name='TFE_ContextUpdateServerDef' id='2415830198112'>}
mock_context = None

    def test_connect_to_remote_host_default_job_name(mock_pywrap_tfe, mock_context):
        """Test default parameter values for connect_to_remote_host (TC-02)."""
        # Arrange
        remote_host = "127.0.0.1:8080"
    
        # Act - call with only remote_host, using default job_name
>       remote.connect_to_remote_host(remote_host)

tests\test_tensorflow_python_eager_remote.py:85: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:73: in connect_to_remote_host
    connect_to_cluster(cluster_spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cluster_spec_or_resolver = ClusterSpec({'worker': ['127.0.0.1:8080']})
job_name = 'localhost', task_index = 0, protocol = 'grpc'
make_master_device_default = True, cluster_device_filters = None

    @tf_export("config.experimental_connect_to_cluster")
    def connect_to_cluster(cluster_spec_or_resolver,
                           job_name="localhost",
                           task_index=0,
                           protocol=None,
                           make_master_device_default=True,
                           cluster_device_filters=None):
      """Connects to the given cluster.
    
      Will make devices on the cluster available to use. Note that calling this more
      than once will work, but will invalidate any tensor handles on the old remote
      devices.
    
      If the given local job name is not present in the cluster specification, it
      will be automatically added, using an unused port on the localhost.
    
      Device filters can be specified to isolate groups of remote tasks to avoid
      undesired accesses between workers. Workers accessing resources or launching
      ops / functions on filtered remote devices will result in errors (unknown
      devices). For any remote task, if no device filter is present, all cluster
      devices will be visible; if any device filter is specified, it can only
      see devices matching at least one filter. Devices on the task itself are
      always visible. Device filters can be particially specified.
    
      For example, for a cluster set up for parameter server training, the following
      device filters might be specified:
    
      ```python
      cdf = tf.config.experimental.ClusterDeviceFilters()
      # For any worker, only the devices on PS nodes and itself are visible
      for i in range(num_workers):
        cdf.set_device_filters('worker', i, ['/job:ps'])
      # Similarly for any ps, only the devices on workers and itself are visible
      for i in range(num_ps):
        cdf.set_device_filters('ps', i, ['/job:worker'])
    
      tf.config.experimental_connect_to_cluster(cluster_def,
                                                cluster_device_filters=cdf)
      ```
    
      Args:
        cluster_spec_or_resolver: A `ClusterSpec` or `ClusterResolver` describing
          the cluster.
        job_name: The name of the local job.
        task_index: The local task index.
        protocol: The communication protocol, such as `"grpc"`. If unspecified, will
          use the default from `python/platform/remote_utils.py`.
        make_master_device_default: If True and a cluster resolver is passed, will
          automatically enter the master task device scope, which indicates the
          master becomes the default device to run ops. It won't do anything if
          a cluster spec is passed. Will throw an error if the caller is currently
          already in some device scope.
        cluster_device_filters: an instance of
          `tf.train.experimental/ClusterDeviceFilters` that specify device filters
          to the remote tasks in cluster.
      """
      if not context.executing_eagerly():
        raise ValueError(
            "`tf.config.experimental_connect_to_cluster` can only be called in "
            "eager mode."
        )
      protocol = protocol or remote_utils.get_default_communication_protocol()
      if isinstance(cluster_spec_or_resolver, server_lib.ClusterSpec):
        cluster_spec = cluster_spec_or_resolver
      elif isinstance(cluster_spec_or_resolver, cluster_resolver.ClusterResolver):
        if cluster_spec_or_resolver.master() in _LOCAL_MASTERS:
          # Do nothing if the master is local.
          return
        cluster_spec = cluster_spec_or_resolver.cluster_spec()
      else:
        raise ValueError(
            "`cluster_spec_or_resolver` must be a `ClusterSpec` or a "
            "`ClusterResolver`.")
    
      cluster_def = copy.deepcopy(cluster_spec.as_cluster_def())
      if cluster_device_filters:
        if isinstance(cluster_device_filters, server_lib.ClusterDeviceFilters):
          cluster_device_filters = copy.deepcopy(
              cluster_device_filters._as_cluster_device_filters())  # pylint: disable=protected-access
        else:
          raise ValueError("`cluster_device_filters` must be an instance of "
                           "`tf.train.experimental.ClusterDeviceFilters`.")
    
      # Check whether the server def has changed. We need to do the check before the
      # local job is added to the cluster.
      is_server_def_changed = False
      current_server_def = context.get_server_def()
      if current_server_def and job_name not in cluster_spec.jobs:
        for i, job in enumerate(current_server_def.cluster.job):
          if job.name == job_name:
            del current_server_def.cluster.job[i]
      if (current_server_def is None or current_server_def.cluster != cluster_def or
          current_server_def.job_name != job_name or
          current_server_def.task_index != task_index):
        is_server_def_changed = True
    
      # Automatically add local job, if not part of the cluster spec.
      if job_name not in cluster_spec.jobs:
        local_port = pywrap_tfe.TF_PickUnusedPortOrDie()
        job_def = cluster_def.job.add()
        job_def.name = job_name
        # TODO(fishx): Update this to make sure remote worker has valid ip address
        # to connect with local.
        job_def.tasks[0] = "localhost:{}".format(local_port)
    
      if context.context().coordination_service is None:
        # Maybe enable coordination service for the communication protocol
        coordination_service = remote_utils.coordination_service_type(protocol)
        if coordination_service:
          context.context().configure_coordination_service(coordination_service)
    
>     server_def = ServerDef(
          cluster=cluster_def,
          job_name=job_name,
          task_index=task_index,
          protocol=protocol,
          default_session_config=context.context().config,
          cluster_device_filters=cluster_device_filters)
E     TypeError: Parameter to MergeFrom() must be instance of same class: expected tensorflow.ConfigProto got MagicMock.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:187: TypeError
_________________ test_connect_to_cluster_eager_mode_required _________________

mock_pywrap_tfe = {'set_server_def': <MagicMock name='TFE_ContextSetServerDef' id='2415811618368'>, 'update_server_def': <MagicMock name='TFE_ContextUpdateServerDef' id='2415811791312'>}

    def test_connect_to_cluster_eager_mode_required(mock_pywrap_tfe):
        """Test that connect_to_cluster requires eager mode (TC-03)."""
        # Arrange
        cluster_spec = {"worker": ["localhost:2222"]}
        mock_cluster_spec = mock.MagicMock(spec=server_lib.ClusterSpec)
        mock_cluster_spec.as_cluster_def.return_value = mock.MagicMock()
    
        # Mock context.executing_eagerly to return False (non-eager mode)
        with mock.patch.object(context, 'executing_eagerly', return_value=False):
            # Act & Assert
            with pytest.raises(ValueError) as exc_info:
                remote.connect_to_cluster(mock_cluster_spec, job_name="localhost", task_index=0)
    
            # Verify the error message
            error_msg = str(exc_info.value)
            assert "eager mode" in error_msg.lower(), "Error should mention eager mode requirement"
    
            # Verify that pywrap_tfe functions were NOT called
            mock_set_server_def = mock_pywrap_tfe['set_server_def']
            assert not mock_set_server_def.called, "Should not call server functions in non-eager mode"
    
        # Additional test: should work in eager mode
        with mock.patch.object(context, 'executing_eagerly', return_value=True):
            # This should not raise an exception
>           remote.connect_to_cluster(mock_cluster_spec, job_name="localhost", task_index=0)

tests\test_tensorflow_python_eager_remote.py:131: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cluster_spec_or_resolver = <MagicMock spec='ClusterSpec' id='2415811618704'>
job_name = 'localhost', task_index = 0, protocol = 'grpc'
make_master_device_default = True, cluster_device_filters = None

    @tf_export("config.experimental_connect_to_cluster")
    def connect_to_cluster(cluster_spec_or_resolver,
                           job_name="localhost",
                           task_index=0,
                           protocol=None,
                           make_master_device_default=True,
                           cluster_device_filters=None):
      """Connects to the given cluster.
    
      Will make devices on the cluster available to use. Note that calling this more
      than once will work, but will invalidate any tensor handles on the old remote
      devices.
    
      If the given local job name is not present in the cluster specification, it
      will be automatically added, using an unused port on the localhost.
    
      Device filters can be specified to isolate groups of remote tasks to avoid
      undesired accesses between workers. Workers accessing resources or launching
      ops / functions on filtered remote devices will result in errors (unknown
      devices). For any remote task, if no device filter is present, all cluster
      devices will be visible; if any device filter is specified, it can only
      see devices matching at least one filter. Devices on the task itself are
      always visible. Device filters can be particially specified.
    
      For example, for a cluster set up for parameter server training, the following
      device filters might be specified:
    
      ```python
      cdf = tf.config.experimental.ClusterDeviceFilters()
      # For any worker, only the devices on PS nodes and itself are visible
      for i in range(num_workers):
        cdf.set_device_filters('worker', i, ['/job:ps'])
      # Similarly for any ps, only the devices on workers and itself are visible
      for i in range(num_ps):
        cdf.set_device_filters('ps', i, ['/job:worker'])
    
      tf.config.experimental_connect_to_cluster(cluster_def,
                                                cluster_device_filters=cdf)
      ```
    
      Args:
        cluster_spec_or_resolver: A `ClusterSpec` or `ClusterResolver` describing
          the cluster.
        job_name: The name of the local job.
        task_index: The local task index.
        protocol: The communication protocol, such as `"grpc"`. If unspecified, will
          use the default from `python/platform/remote_utils.py`.
        make_master_device_default: If True and a cluster resolver is passed, will
          automatically enter the master task device scope, which indicates the
          master becomes the default device to run ops. It won't do anything if
          a cluster spec is passed. Will throw an error if the caller is currently
          already in some device scope.
        cluster_device_filters: an instance of
          `tf.train.experimental/ClusterDeviceFilters` that specify device filters
          to the remote tasks in cluster.
      """
      if not context.executing_eagerly():
        raise ValueError(
            "`tf.config.experimental_connect_to_cluster` can only be called in "
            "eager mode."
        )
      protocol = protocol or remote_utils.get_default_communication_protocol()
      if isinstance(cluster_spec_or_resolver, server_lib.ClusterSpec):
        cluster_spec = cluster_spec_or_resolver
      elif isinstance(cluster_spec_or_resolver, cluster_resolver.ClusterResolver):
        if cluster_spec_or_resolver.master() in _LOCAL_MASTERS:
          # Do nothing if the master is local.
          return
        cluster_spec = cluster_spec_or_resolver.cluster_spec()
      else:
        raise ValueError(
            "`cluster_spec_or_resolver` must be a `ClusterSpec` or a "
            "`ClusterResolver`.")
    
      cluster_def = copy.deepcopy(cluster_spec.as_cluster_def())
      if cluster_device_filters:
        if isinstance(cluster_device_filters, server_lib.ClusterDeviceFilters):
          cluster_device_filters = copy.deepcopy(
              cluster_device_filters._as_cluster_device_filters())  # pylint: disable=protected-access
        else:
          raise ValueError("`cluster_device_filters` must be an instance of "
                           "`tf.train.experimental.ClusterDeviceFilters`.")
    
      # Check whether the server def has changed. We need to do the check before the
      # local job is added to the cluster.
      is_server_def_changed = False
      current_server_def = context.get_server_def()
      if current_server_def and job_name not in cluster_spec.jobs:
        for i, job in enumerate(current_server_def.cluster.job):
          if job.name == job_name:
            del current_server_def.cluster.job[i]
      if (current_server_def is None or current_server_def.cluster != cluster_def or
          current_server_def.job_name != job_name or
          current_server_def.task_index != task_index):
        is_server_def_changed = True
    
      # Automatically add local job, if not part of the cluster spec.
      if job_name not in cluster_spec.jobs:
        local_port = pywrap_tfe.TF_PickUnusedPortOrDie()
        job_def = cluster_def.job.add()
        job_def.name = job_name
        # TODO(fishx): Update this to make sure remote worker has valid ip address
        # to connect with local.
        job_def.tasks[0] = "localhost:{}".format(local_port)
    
      if context.context().coordination_service is None:
        # Maybe enable coordination service for the communication protocol
        coordination_service = remote_utils.coordination_service_type(protocol)
        if coordination_service:
          context.context().configure_coordination_service(coordination_service)
    
>     server_def = ServerDef(
          cluster=cluster_def,
          job_name=job_name,
          task_index=task_index,
          protocol=protocol,
          default_session_config=context.context().config,
          cluster_device_filters=cluster_device_filters)
E     TypeError: Parameter to MergeFrom() must be instance of same class: expected tensorflow.ClusterDef got MagicMock.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:187: TypeError
____________ test_connect_to_remote_host_multiple_calls_overwrite _____________

mock_pywrap_tfe = {'set_server_def': <MagicMock name='TFE_ContextSetServerDef' id='2415830521648'>, 'update_server_def': <MagicMock name='TFE_ContextUpdateServerDef' id='2415830389280'>}
mock_context = None

    def test_connect_to_remote_host_multiple_calls_overwrite(mock_pywrap_tfe, mock_context):
        """Test that multiple calls to connect_to_remote_host overwrite previous config (TC-04)."""
        # Arrange
        first_host = "host1:1111"
        second_host = "host2:2222"
        job_name = "worker"
    
        # Act - First call
>       remote.connect_to_remote_host(first_host, job_name)

tests\test_tensorflow_python_eager_remote.py:145: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:73: in connect_to_remote_host
    connect_to_cluster(cluster_spec)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

cluster_spec_or_resolver = ClusterSpec({'worker': ['host1:1111']})
job_name = 'localhost', task_index = 0, protocol = 'grpc'
make_master_device_default = True, cluster_device_filters = None

    @tf_export("config.experimental_connect_to_cluster")
    def connect_to_cluster(cluster_spec_or_resolver,
                           job_name="localhost",
                           task_index=0,
                           protocol=None,
                           make_master_device_default=True,
                           cluster_device_filters=None):
      """Connects to the given cluster.
    
      Will make devices on the cluster available to use. Note that calling this more
      than once will work, but will invalidate any tensor handles on the old remote
      devices.
    
      If the given local job name is not present in the cluster specification, it
      will be automatically added, using an unused port on the localhost.
    
      Device filters can be specified to isolate groups of remote tasks to avoid
      undesired accesses between workers. Workers accessing resources or launching
      ops / functions on filtered remote devices will result in errors (unknown
      devices). For any remote task, if no device filter is present, all cluster
      devices will be visible; if any device filter is specified, it can only
      see devices matching at least one filter. Devices on the task itself are
      always visible. Device filters can be particially specified.
    
      For example, for a cluster set up for parameter server training, the following
      device filters might be specified:
    
      ```python
      cdf = tf.config.experimental.ClusterDeviceFilters()
      # For any worker, only the devices on PS nodes and itself are visible
      for i in range(num_workers):
        cdf.set_device_filters('worker', i, ['/job:ps'])
      # Similarly for any ps, only the devices on workers and itself are visible
      for i in range(num_ps):
        cdf.set_device_filters('ps', i, ['/job:worker'])
    
      tf.config.experimental_connect_to_cluster(cluster_def,
                                                cluster_device_filters=cdf)
      ```
    
      Args:
        cluster_spec_or_resolver: A `ClusterSpec` or `ClusterResolver` describing
          the cluster.
        job_name: The name of the local job.
        task_index: The local task index.
        protocol: The communication protocol, such as `"grpc"`. If unspecified, will
          use the default from `python/platform/remote_utils.py`.
        make_master_device_default: If True and a cluster resolver is passed, will
          automatically enter the master task device scope, which indicates the
          master becomes the default device to run ops. It won't do anything if
          a cluster spec is passed. Will throw an error if the caller is currently
          already in some device scope.
        cluster_device_filters: an instance of
          `tf.train.experimental/ClusterDeviceFilters` that specify device filters
          to the remote tasks in cluster.
      """
      if not context.executing_eagerly():
        raise ValueError(
            "`tf.config.experimental_connect_to_cluster` can only be called in "
            "eager mode."
        )
      protocol = protocol or remote_utils.get_default_communication_protocol()
      if isinstance(cluster_spec_or_resolver, server_lib.ClusterSpec):
        cluster_spec = cluster_spec_or_resolver
      elif isinstance(cluster_spec_or_resolver, cluster_resolver.ClusterResolver):
        if cluster_spec_or_resolver.master() in _LOCAL_MASTERS:
          # Do nothing if the master is local.
          return
        cluster_spec = cluster_spec_or_resolver.cluster_spec()
      else:
        raise ValueError(
            "`cluster_spec_or_resolver` must be a `ClusterSpec` or a "
            "`ClusterResolver`.")
    
      cluster_def = copy.deepcopy(cluster_spec.as_cluster_def())
      if cluster_device_filters:
        if isinstance(cluster_device_filters, server_lib.ClusterDeviceFilters):
          cluster_device_filters = copy.deepcopy(
              cluster_device_filters._as_cluster_device_filters())  # pylint: disable=protected-access
        else:
          raise ValueError("`cluster_device_filters` must be an instance of "
                           "`tf.train.experimental.ClusterDeviceFilters`.")
    
      # Check whether the server def has changed. We need to do the check before the
      # local job is added to the cluster.
      is_server_def_changed = False
      current_server_def = context.get_server_def()
      if current_server_def and job_name not in cluster_spec.jobs:
        for i, job in enumerate(current_server_def.cluster.job):
          if job.name == job_name:
            del current_server_def.cluster.job[i]
      if (current_server_def is None or current_server_def.cluster != cluster_def or
          current_server_def.job_name != job_name or
          current_server_def.task_index != task_index):
        is_server_def_changed = True
    
      # Automatically add local job, if not part of the cluster spec.
      if job_name not in cluster_spec.jobs:
        local_port = pywrap_tfe.TF_PickUnusedPortOrDie()
        job_def = cluster_def.job.add()
        job_def.name = job_name
        # TODO(fishx): Update this to make sure remote worker has valid ip address
        # to connect with local.
        job_def.tasks[0] = "localhost:{}".format(local_port)
    
      if context.context().coordination_service is None:
        # Maybe enable coordination service for the communication protocol
        coordination_service = remote_utils.coordination_service_type(protocol)
        if coordination_service:
          context.context().configure_coordination_service(coordination_service)
    
>     server_def = ServerDef(
          cluster=cluster_def,
          job_name=job_name,
          task_index=task_index,
          protocol=protocol,
          default_session_config=context.context().config,
          cluster_device_filters=cluster_device_filters)
E     TypeError: Parameter to MergeFrom() must be instance of same class: expected tensorflow.ConfigProto got MagicMock.

D:\Coding\Anaconda\envs\testagent-experiment\lib\site-packages\tensorflow\python\eager\remote.py:187: TypeError

---------- coverage: platform win32, python 3.9.25-final-0 -----------
Name                                           Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------------------
tests\test_tensorflow_python_eager_remote.py      89     29      0      0    67%   36-40, 46-48, 66-74, 91-102, 148-173
------------------------------------------------------------------------------------------
TOTAL                                             89     29      0      0    67%
Coverage XML written to file coverage.xml

=========================== short test summary info ===========================
FAILED tests\test_tensorflow_python_eager_remote.py::test_connect_to_remote_host_basic
FAILED tests\test_tensorflow_python_eager_remote.py::test_connect_to_remote_host_default_job_name
FAILED tests\test_tensorflow_python_eager_remote.py::test_connect_to_cluster_eager_mode_required
FAILED tests\test_tensorflow_python_eager_remote.py::test_connect_to_remote_host_multiple_calls_overwrite
4 failed, 3 passed in 1.62s

Error: exit 1