"""
Test cases for tensorflow.python.ops.bincount_ops module.
Generated by TestAgent for target: tensorflow.python.ops.bincount_ops
"""

import numpy as np
import pytest
import tensorflow as tf
from unittest.mock import patch, MagicMock

# Import the target function
from tensorflow.python.ops.bincount_ops import bincount

# Set random seed for reproducibility
np.random.seed(42)
tf.random.set_seed(42)

# START:HEADER
# HEADER block - imports and fixtures

@pytest.fixture
def random_int_array():
    """Generate random integer array for testing."""
    return np.random.randint(0, 10, size=10, dtype=np.int32)

@pytest.fixture
def fixed_pattern_array():
    """Generate array with fixed pattern for testing."""
    return np.array([1, 2, 1, 3, 2, 4, 1, 2], dtype=np.int32)

@pytest.fixture
def random_2d_array():
    """Generate random 2D integer array for testing."""
    return np.random.randint(0, 5, size=(3, 5), dtype=np.int32)

@pytest.fixture
def float_weights():
    """Generate float weights for testing."""
    return np.random.randn(8).astype(np.float32)

@pytest.fixture
def int_weights():
    """Generate integer weights for testing."""
    return np.random.randint(1, 5, size=8, dtype=np.int32)
# END:HEADER

# START:CASE_01
# CASE_01: 基础整数数组频次统计

@pytest.mark.parametrize("arr_type,dtype,shape,values,weights,axis,binary_output", [
    ("dense", "int32", [10], "random_int", None, None, False),
    ("dense", "int32", [20], "edge_values", None, None, False),  # 大整数类型验证 - 使用int32而不是int64
])
def test_basic_integer_bincount(arr_type, dtype, shape, values, weights, axis, binary_output):
    """Test basic integer array frequency counting."""
    # Arrange
    # Generate test data based on parameters
    np.random.seed(42)
    if values == "random_int":
        arr_data = np.random.randint(0, 10, size=tuple(shape), dtype=np.int32)
    elif values == "edge_values":
        # Edge values test case: include 0 and max value
        arr_data = np.zeros(shape, dtype=np.int32)
        # Fill with some edge values
        for i in range(min(shape[0], 5)):
            arr_data[i] = i  # 0, 1, 2, 3, 4
        # Add some larger values
        if shape[0] > 5:
            arr_data[5] = 100
        if shape[0] > 6:
            arr_data[6] = 1000
    else:
        # Default to random if not specified
        arr_data = np.random.randint(0, 10, size=tuple(shape), dtype=np.int32)
    
    # Convert to appropriate dtype
    if dtype == "int32":
        arr = tf.constant(arr_data, dtype=tf.int32)
    elif dtype == "int64":
        # bincount requires int32 input, so we need to convert
        arr = tf.constant(arr_data.astype(np.int32), dtype=tf.int32)
    else:
        arr = tf.constant(arr_data, dtype=tf.int32)
    
    # Act
    result = bincount(arr)
    
    # Assert (weak assertions)
    # 1. Check shape
    max_val = np.max(arr_data)
    expected_length = max_val + 1 if max_val >= 0 else 0
    assert result.shape == (expected_length,)
    
    # 2. Check dtype
    assert result.dtype == tf.int32
    
    # 3. Check basic properties
    # Sum of counts should equal array length
    assert tf.reduce_sum(result).numpy() == arr_data.size
    
    # All counts should be non-negative
    assert tf.reduce_all(result >= 0).numpy()
    
    # Manual calculation for verification
    unique_vals, counts = np.unique(arr_data, return_counts=True)
    for val, count in zip(unique_vals, counts):
        if val >= 0:
            assert result[val].numpy() == count
# END:CASE_01

# START:CASE_02
# CASE_02: 加权计数浮点权重累加

@pytest.mark.parametrize("arr_type,dtype,shape,values,weights,axis,binary_output", [
    ("dense", "int32", [8], "fixed_pattern", "float32", None, False),
    ("dense", "int32", [8], "fixed_pattern", "int64", None, False),  # 整数权重累加
])
def test_weighted_bincount_float_weights(arr_type, dtype, shape, values, weights, axis, binary_output):
    """Test weighted bincount with float weights."""
    # Arrange
    # Generate test data based on parameters
    np.random.seed(42)
    if values == "fixed_pattern":
        arr_data = np.array([1, 2, 1, 3, 2, 4, 1, 2], dtype=np.int32)
    else:
        # Default pattern
        arr_data = np.array([1, 2, 1, 3, 2, 4, 1, 2], dtype=np.int32)
    
    if weights == "float32":
        weights_data = np.random.randn(8).astype(np.float32)
    elif weights == "int64":
        weights_data = np.random.randint(1, 5, size=8, dtype=np.int64)
    else:
        # Default weights
        weights_data = np.random.randn(8).astype(np.float32)
    
    arr = tf.constant(arr_data)
    weights_tensor = tf.constant(weights_data)
    
    # Act
    result = bincount(arr, weights=weights_tensor)
    
    # Assert (weak assertions)
    # 1. Check shape
    max_val = np.max(arr_data)
    expected_length = max_val + 1 if max_val >= 0 else 0
    assert result.shape == (expected_length,)
    
    # 2. Check dtype - should match weights dtype
    if weights == "float32":
        assert result.dtype == tf.float32
    elif weights == "int64":
        assert result.dtype == tf.int64
    else:
        assert result.dtype == tf.float32
    
    # 3. Check weighted sum properties
    # Sum of weighted counts should equal sum of weights
    total_weight = np.sum(weights_data)
    result_sum = tf.reduce_sum(result).numpy()
    assert np.isclose(result_sum, total_weight, rtol=1e-6)
    
    # Manual weighted sum calculation
    unique_vals = np.unique(arr_data)
    for val in unique_vals:
        if val >= 0:
            # Get indices where array equals current value
            indices = np.where(arr_data == val)[0]
            # Sum weights at those indices
            expected_sum = np.sum(weights_data[indices])
            actual_sum = result[val].numpy()
            assert np.isclose(actual_sum, expected_sum, rtol=1e-6)
# END:CASE_02

# START:CASE_03
# CASE_03: 2D输入轴切片计数

@pytest.mark.parametrize("arr_type,dtype,shape,values,weights,axis,binary_output", [
    ("dense", "int32", [3, 5], "random_int", None, -1, False),
    ("dense", "int32", [4, 6], "random_int", None, 0, False),  # 轴0切片验证
])
def test_2d_axis_bincount(arr_type, dtype, shape, values, weights, axis, binary_output):
    """Test 2D array bincount along axis."""
    # Arrange
    # Generate test data based on parameters
    np.random.seed(42)
    if values == "random_int":
        arr_data = np.random.randint(0, 5, size=tuple(shape), dtype=np.int32)
    else:
        # Default random data
        arr_data = np.random.randint(0, 5, size=tuple(shape), dtype=np.int32)
    
    arr = tf.constant(arr_data)
    
    # Act
    result = bincount(arr, axis=axis)
    
    # Assert (weak assertions)
    # 1. Check shape based on axis
    max_val = np.max(arr_data)
    expected_length = max_val + 1 if max_val >= 0 else 0
    
    if axis == -1:
        # axis=-1: shape should be (batch_size, max_val+1)
        batch_size = arr_data.shape[0]
        assert result.shape == (batch_size, expected_length)
    elif axis == 0:
        # axis=0: all axes are flattened (same as axis=None)
        # According to bincount documentation, axis=0 flattens all axes
        assert result.shape == (expected_length,)
    
    # 2. Check dtype
    assert result.dtype == tf.int32
    
    # 3. Check axis alignment
    if axis == -1:
        # For axis=-1: check each row
        batch_size = arr_data.shape[0]
        for i in range(batch_size):
            row_sum = tf.reduce_sum(result[i]).numpy()
            assert row_sum == arr_data.shape[1]  # row length
        
        # Check each row's bincount
        for i in range(batch_size):
            row_data = arr_data[i]
            unique_vals, counts = np.unique(row_data, return_counts=True)
            for val, count in zip(unique_vals, counts):
                if val >= 0:
                    assert result[i, val].numpy() == count
    elif axis == 0:
        # For axis=0: check each column
        cols = arr_data.shape[1]
        for j in range(cols):
            col_sum = tf.reduce_sum(result[:, j]).numpy()
            assert col_sum == arr_data.shape[0]  # column length
        
        # Check each column's bincount
        for j in range(cols):
            col_data = arr_data[:, j]
            unique_vals, counts = np.unique(col_data, return_counts=True)
            for val, count in zip(unique_vals, counts):
                if val >= 0:
                    assert result[val, j].numpy() == count
# END:CASE_03

# START:CASE_04
# CASE_04: 二进制输出存在性标记

@pytest.mark.parametrize("arr_type,dtype,shape,values,weights,axis,binary_output", [
    ("dense", "int32", [12], "repeated_pattern", None, None, True),
])
def test_binary_output_bincount(arr_type, dtype, shape, values, weights, axis, binary_output):
    """Test bincount with binary output (existence marking)."""
    # Arrange
    # Generate test data with repeated pattern
    if values == "repeated_pattern":
        # Create array with repeated values: [0, 1, 2, 0, 1, 2, 3, 4, 3, 4, 5, 5]
        arr_data = np.array([0, 1, 2, 0, 1, 2, 3, 4, 3, 4, 5, 5], dtype=np.int32)
    else:
        # Default pattern
        arr_data = np.array([0, 1, 2, 0, 1, 2, 3, 4, 3, 4, 5, 5], dtype=np.int32)
    
    arr = tf.constant(arr_data)
    
    # Act
    result = bincount(arr, binary_output=True)
    
    # Assert (weak assertions)
    # 1. Check shape
    max_val = np.max(arr_data)
    expected_length = max_val + 1 if max_val >= 0 else 0
    assert result.shape == (expected_length,)
    
    # 2. Check dtype - binary output should be int32
    assert result.dtype == tf.int32
    
    # 3. Check binary output properties
    # All values should be either 0 or 1
    assert tf.reduce_all((result == 0) | (result == 1)).numpy()
    
    # Values that appear in input should be marked as 1
    unique_vals = np.unique(arr_data)
    for val in unique_vals:
        if val >= 0:
            assert result[val].numpy() == 1
    
    # Values not in input should be 0 (if within range)
    for val in range(expected_length):
        if val not in unique_vals:
            assert result[val].numpy() == 0
    
    # Sum should equal number of unique non-negative values
    unique_non_negative = len([v for v in unique_vals if v >= 0])
    assert tf.reduce_sum(result).numpy() == unique_non_negative
# END:CASE_04

# START:CASE_05
# CASE_05: RaggedTensor输入验证 (DEFERRED - placeholder)

# DEFERRED: This test case will be implemented in later iterations
# Parameters: arr_type=ragged, dtype=int32, shape=ragged_3x_variable, values=random_int, weights=None, axis=None, binary_output=False
# Assertions: shape, dtype, ragged_structure (weak); ragged_validation, nested_check (strong)
# Oracle: manual_ragged_calculation
# Mock targets: tensorflow.python.ops.gen_math_ops.ragged_bincount, tensorflow.python.ops.array_ops.rank, 
#               tensorflow.python.ops.array_ops.shape, tensorflow.python.framework.ops.convert_to_tensor
# END:CASE_05

# START:FOOTER
# FOOTER block - cleanup and additional utilities

def test_edge_case_empty_array():
    """Test bincount with empty array."""
    arr = tf.constant([], dtype=tf.int32)
    result = bincount(arr)
    assert result.shape == (0,)
    assert result.dtype == tf.int32

def test_edge_case_all_negative():
    """Test bincount with all negative values - should raise error."""
    arr = tf.constant([-1, -2, -3], dtype=tf.int32)
    # TensorFlow bincount requires non-negative inputs
    # Negative values should raise an error
    with pytest.raises(tf.errors.InvalidArgumentError):
        result = bincount(arr)
        # Force execution to trigger the error
        _ = result.numpy()

def test_edge_case_mixed_negative_positive():
    """Test bincount with mixed negative and positive values - should raise error."""
    arr = tf.constant([-1, 2, -3, 4], dtype=tf.int32)
    # Any negative value should raise an error
    with pytest.raises(tf.errors.InvalidArgumentError):
        result = bincount(arr)
        _ = result.numpy()

def test_with_minlength():
    """Test bincount with minlength parameter."""
    arr = tf.constant([1, 2, 3], dtype=tf.int32)
    result = bincount(arr, minlength=10)
    assert result.shape == (10,)
    assert result.dtype == tf.int32
    # Check that values beyond max are zero
    assert result[9].numpy() == 0

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
# END:FOOTER