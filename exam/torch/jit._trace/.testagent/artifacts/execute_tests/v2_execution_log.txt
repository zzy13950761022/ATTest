=== Run Tests ===
.F                                                                       [100%]
=================================== FAILURES ===================================
____________________ test_complex_module_structure_tracing _____________________

    def test_complex_module_structure_tracing():
        """Test complex module structure tracing (CASE_06)."""
        # Set random seed for reproducibility
        set_random_seed(42)
    
        # Create a complex sequential module with multiple layers
        class ComplexSequentialModule(nn.Module):
            def __init__(self):
                super().__init__()
                # Create a sequential module with multiple layers
                self.features = nn.Sequential(
                    nn.Conv2d(in_channels=3, out_channels=16, kernel_size=3, padding=1),
                    nn.BatchNorm2d(16),
                    nn.ReLU(inplace=True),
                    nn.Conv2d(in_channels=16, out_channels=32, kernel_size=3, padding=1),
                    nn.BatchNorm2d(32),
                    nn.ReLU(inplace=True),
                    nn.AdaptiveAvgPool2d((1, 1)),
                    nn.Flatten(),
                    nn.Linear(32, 10)
                )
    
                # Add some additional parallel layers
                self.parallel_branch = nn.Sequential(
                    nn.Conv2d(in_channels=3, out_channels=8, kernel_size=1),
                    nn.ReLU(inplace=True),
                    nn.AdaptiveAvgPool2d((1, 1)),
                    nn.Flatten(),
                    nn.Linear(8, 5)
                )
    
                # Final combination layer
                self.combine = nn.Linear(15, 7)  # 10 + 5 = 15
    
            def forward(self, x: torch.Tensor) -> torch.Tensor:
                # Main branch
                main_out = self.features(x)
    
                # Parallel branch
                parallel_out = self.parallel_branch(x)
    
                # Combine outputs
                combined = torch.cat([main_out, parallel_out], dim=1)
                output = self.combine(combined)
    
                return output
    
        # Create test module
        module = ComplexSequentialModule()
        module.eval()  # Set to eval mode for consistent behavior
    
        # Create test input with shape [2, 3, 32, 32]
        shape = (2, 3, 32, 32)
        x = create_test_tensor(shape, dtype=torch.float32, device='cpu')
    
        # Test the original module
        original_output = module(x)
    
        # Trace the module with strict=True and check_trace=True
        traced_module = torch.jit.trace(
            func=module,
            example_inputs=x,
            strict=True,
            check_trace=True
        )
    
        # Test the traced module
        traced_output = traced_module(x)
    
        # Weak assertions
        # 1. Output shape check
        assert traced_output.shape == original_output.shape, \
            f"Traced output shape {traced_output.shape} != original shape {original_output.shape}"
    
        # 2. Output dtype check
        assert traced_output.dtype == original_output.dtype, \
            f"Traced output dtype {traced_output.dtype} != original dtype {original_output.dtype}"
    
        # 3. Basic equality check (within tolerance)
        tolerance = 1e-5
        assert torch.allclose(traced_output, original_output, rtol=tolerance, atol=tolerance), \
            f"Traced output differs from original output beyond tolerance {tolerance}"
    
        # Additional checks for complex module structure
        # Check that traced module is a ScriptModule
        assert isinstance(traced_module, torch.jit.ScriptModule), \
            f"Traced module should be ScriptModule, got {type(traced_module)}"
    
        # Check submodule preservation
        # Note: When tracing, submodules are flattened into the main module
        # We can check that the traced module has the same parameters
        original_params = dict(module.named_parameters())
        traced_params = dict(traced_module.named_parameters())
    
        # Check that all parameter names are preserved
        original_param_names = set(original_params.keys())
        traced_param_names = set(traced_params.keys())
    
        # The traced module might have slightly different parameter names due to flattening
        # But the number of parameters should be the same
        assert len(original_params) == len(traced_params), \
            f"Number of parameters changed: {len(original_params)} vs {len(traced_params)}"
    
        # Check parameter values match (within tolerance)
        for orig_name, orig_param in original_params.items():
            # Find corresponding parameter in traced module
            # Parameter names might be prefixed in traced module
            found = False
            for traced_name, traced_param in traced_params.items():
                if orig_name in traced_name or traced_name.endswith(orig_name.split('.')[-1]):
>                   assert torch.allclose(orig_param, traced_param, rtol=tolerance, atol=tolerance), \
                        f"Parameter {orig_name} values don't match"
E                   RuntimeError: The size of tensor a (16) must match the size of tensor b (3) at non-singleton dimension 3

tests/test_torch_jit_trace_g2.py:225: RuntimeError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                               Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------
run_tests.py                          35     35     10      0     0%   4-62
tests/test_torch_jit_trace_g2.py      95     12      8      2    86%   223->219, 234-261
------------------------------------------------------------------------------
TOTAL                                130     47     18      2    60%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_jit_trace_g2.py::test_complex_module_structure_tracing
1 failed, 1 passed in 0.69s

Error: exit 1