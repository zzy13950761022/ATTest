=== Run Tests ===
...FFF..                                                                 [100%]
=================================== FAILURES ===================================
____ test_file_object_interface[simple_script_module-file_object-cpu-None] _____

module_type = 'simple_script_module', file_type = 'file_object', device = 'cpu'
extra_files = None
simple_module = RecursiveScriptModule(
  original_name=SimpleModule
  (linear): RecursiveScriptModule(original_name=Linear)
  (relu): RecursiveScriptModule(original_name=ReLU)
)

    @pytest.mark.parametrize("module_type,file_type,device,extra_files", [
        ("simple_script_module", "file_object", "cpu", None),
    ])
    def test_file_object_interface(module_type, file_type, device, extra_files, simple_module):
        """
        TC-04: 文件对象接口
        测试使用文件对象（而非路径）进行序列化和反序列化。
        """
        # Setup
        if module_type == "simple_script_module":
            module = simple_module
        else:
            raise ValueError(f"Unknown module type: {module_type}")
    
        # Test 1: Save to file-like object with write/flush methods
        mock_file = Mock(spec=['write', 'flush'])
        buffer_content = None
    
        def mock_write(data):
            nonlocal buffer_content
            buffer_content = data
    
        mock_file.write = mock_write
        mock_file.flush = Mock()
    
        # Save to mock file object
        torch.jit.save(module, mock_file, _extra_files=extra_files)
    
        # Weak assertion: file_methods_called
>       assert mock_file.write.called, "write method should be called"
E       AttributeError: 'function' object has no attribute 'called'

tests/test_torch_jit_serialization.py:361: AttributeError
___________________________ test_save_invalid_module ___________________________

    def test_save_invalid_module():
        """Test that saving a non-ScriptModule raises an error."""
        class RegularModule(nn.Module):
            def forward(self, x):
                return x * 2
    
        regular_module = RegularModule()
    
        with tempfile.NamedTemporaryFile(suffix='.pt') as tmp:
            with pytest.raises((TypeError, RuntimeError)):
>               torch.jit.save(regular_module, tmp.name)

tests/test_torch_jit_serialization.py:501: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/jit/_serialization.py:81: in save
    m.save(f, _extra_files=_extra_files)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = RegularModule(), name = 'save'

    def __getattr__(self, name: str) -> Union[Tensor, 'Module']:
        if '_parameters' in self.__dict__:
            _parameters = self.__dict__['_parameters']
            if name in _parameters:
                return _parameters[name]
        if '_buffers' in self.__dict__:
            _buffers = self.__dict__['_buffers']
            if name in _buffers:
                return _buffers[name]
        if '_modules' in self.__dict__:
            modules = self.__dict__['_modules']
            if name in modules:
                return modules[name]
>       raise AttributeError("'{}' object has no attribute '{}'".format(
            type(self).__name__, name))
E       AttributeError: 'RegularModule' object has no attribute 'save'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/modules/module.py:1265: AttributeError
__________________________ test_load_nonexistent_file __________________________

    def test_load_nonexistent_file():
        """Test that loading a non-existent file raises an error."""
        non_existent_path = "/tmp/nonexistent_file_12345.pt"
    
        # Ensure the file doesn't exist
        if os.path.exists(non_existent_path):
            os.remove(non_existent_path)
    
        with pytest.raises((FileNotFoundError, RuntimeError)):
>           torch.jit.load(non_existent_path)

tests/test_torch_jit_serialization.py:513: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

f = '/tmp/nonexistent_file_12345.pt', map_location = None, _extra_files = None

    def load(f, map_location=None, _extra_files=None):
        r"""
        Load a :class:`ScriptModule` or :class:`ScriptFunction` previously
        saved with :func:`torch.jit.save <torch.jit.save>`
    
        All previously saved modules, no matter their device, are first loaded onto CPU,
        and then are moved to the devices they were saved from. If this fails (e.g.
        because the run time system doesn't have certain devices), an exception is
        raised.
    
        Args:
            f: a file-like object (has to implement read, readline, tell, and seek),
                or a string containing a file name
            map_location (string or torch.device): A simplified version of
                ``map_location`` in `torch.jit.save` used to dynamically remap
                storages to an alternative set of devices.
            _extra_files (dictionary of filename to content): The extra
                filenames given in the map would be loaded and their content
                would be stored in the provided map.
    
        Returns:
            A :class:`ScriptModule` object.
    
        Example:
    
        .. testcode::
    
            import torch
            import io
    
            torch.jit.load('scriptmodule.pt')
    
            # Load ScriptModule from io.BytesIO object
            with open('scriptmodule.pt', 'rb') as f:
                buffer = io.BytesIO(f.read())
    
            # Load all tensors to the original device
            torch.jit.load(buffer)
    
            # Load all tensors onto CPU, using a device
            buffer.seek(0)
            torch.jit.load(buffer, map_location=torch.device('cpu'))
    
            # Load all tensors onto CPU, using a string
            buffer.seek(0)
            torch.jit.load(buffer, map_location='cpu')
    
            # Load with extra files.
            extra_files = {'foo.txt': ''}  # values will be replaced with data
            torch.jit.load('scriptmodule.pt', _extra_files=extra_files)
            print(extra_files['foo.txt'])
    
        .. testoutput::
            :hide:
    
            ...
    
        .. testcleanup::
    
            import os
            os.remove("scriptmodule.pt")
        """
    
        if isinstance(f, string_classes):
            if not os.path.exists(f):  # type: ignore[type-var]
>               raise ValueError("The provided filename {} does not exist".format(f))  # type: ignore[str-bytes-safe]
E               ValueError: The provided filename /tmp/nonexistent_file_12345.pt does not exist

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/jit/_serialization.py:152: ValueError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                    Stmts   Miss Branch BrPart  Cover   Missing
-----------------------------------------------------------------------------------
tests/test_torch_jit_serialization.py     287     96     44     10    65%   30, 43-65, 71-95, 115, 137, 147, 180->exit, 197, 267, 308, 327->exit, 344, 362-444, 495, 510, 566-567
-----------------------------------------------------------------------------------
TOTAL                                     287     96     44     10    65%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_jit_serialization.py::test_file_object_interface[simple_script_module-file_object-cpu-None]
FAILED tests/test_torch_jit_serialization.py::test_save_invalid_module - Attr...
FAILED tests/test_torch_jit_serialization.py::test_load_nonexistent_file - Va...
3 failed, 5 passed in 0.82s

Error: exit 1