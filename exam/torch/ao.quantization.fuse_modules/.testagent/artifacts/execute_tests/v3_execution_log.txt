=== Run Tests ===
....F...F.........                                                       [100%]
=================================== FAILURES ===================================
____________ test_multi_group_module_fusion[modules_to_fuse1-False] ____________

random_input = tensor([[[[ 1.9269e+00,  1.4873e+00,  9.0072e-01,  ...,  4.1759e-02,
           -2.5158e-01,  8.5986e-01],
          [...065e-01],
          [ 9.6563e-01,  4.6251e-01, -1.4208e+00,  ...,  1.7574e-01,
            2.5499e-01,  8.0700e-01]]]])
modules_to_fuse = [['conv1', 'bn1'], ['linear', 'relu'], ['conv2', 'relu']]
inplace = False

    @pytest.mark.parametrize("modules_to_fuse,inplace", [
        ([["conv1", "bn1", "relu1"], ["linear", "relu"]], False),  # Base case from param_matrix
        ([["conv1", "bn1"], ["linear", "relu"], ["conv2", "relu"]], False),  # Extension: three groups
    ])
    def test_multi_group_module_fusion(random_input, modules_to_fuse, inplace):
        """Test fusion of multiple groups of modules."""
        # Setup - need to update model for extension case
        if len(modules_to_fuse) == 3:
            # For three groups extension, we need a model with conv2
            class ExtendedMultiLayerModel(nn.Module):
                def __init__(self):
                    super().__init__()
                    self.conv1 = nn.Conv2d(3, 16, kernel_size=3, padding=1)
                    self.bn1 = nn.BatchNorm2d(16)
                    self.relu1 = nn.ReLU()
                    self.conv2 = nn.Conv2d(16, 32, kernel_size=3, padding=1)
                    self.relu2 = nn.ReLU()
                    self.linear = nn.Linear(32 * 32 * 32, 10)
                    self.relu = nn.ReLU()
    
                def forward(self, x):
                    x = self.conv1(x)
                    x = self.bn1(x)
                    x = self.relu1(x)
                    x = self.conv2(x)
                    x = self.relu2(x)
                    x = x.view(x.size(0), -1)
                    x = self.linear(x)
                    x = self.relu(x)
                    return x
    
            model = ExtendedMultiLayerModel()
        else:
            model = MultiLayerModel()
    
        model.eval()
    
        # Get original output
        with torch.no_grad():
            original_output = model(random_input)
    
        # Fuse multiple groups
>       fused_model = fuse_modules(
            model,
            modules_to_fuse,
            inplace=inplace,
            fuser_func=None,  # Use default
            fuse_custom_config_dict=None
        )

tests/test_torch_ao_quantization_fuse_modules_g1.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:152: in fuse_modules
    return _fuse_modules(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:94: in _fuse_modules
    _fuse_modules_helper(model, module_list, is_qat, fuser_func, fuse_custom_config_dict)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:78: in _fuse_modules_helper
    new_mod_list = fuser_func(mod_list, is_qat, additional_fuser_method_mapping)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:46: in fuse_known_modules
    fuser_method = get_fuser_method(types, additional_fuser_method_mapping)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

op_list = (<class 'torch.nn.modules.conv.Conv2d'>, <class 'torch.nn.modules.linear.Identity'>)
additional_fuser_method_mapping = {}

    def get_fuser_method(op_list, additional_fuser_method_mapping=None):
        ''' Get fuser method for the given list of module types,
        return None if fuser method does not exist
        '''
        if additional_fuser_method_mapping is None:
            additional_fuser_method_mapping = {}
        all_mappings = get_combined_dict(DEFAULT_OP_LIST_TO_FUSER_METHOD,
                                         additional_fuser_method_mapping)
        fuser_method = all_mappings.get(op_list, None)
>       assert fuser_method is not None, "did not find fuser method for: {} ".format(op_list)
E       AssertionError: did not find fuser method for: (<class 'torch.nn.modules.conv.Conv2d'>, <class 'torch.nn.modules.linear.Identity'>)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuser_method_mappings.py:184: AssertionError
__________________ test_unsupported_sequence_unchanged[False] __________________

random_input = tensor([[[[ 1.9269e+00,  1.4873e+00,  9.0072e-01,  ...,  4.1759e-02,
           -2.5158e-01,  8.5986e-01],
          [...065e-01],
          [ 9.6563e-01,  4.6251e-01, -1.4208e+00,  ...,  1.7574e-01,
            2.5499e-01,  8.0700e-01]]]])
inplace = False

    @pytest.mark.parametrize("inplace", [False])
    def test_unsupported_sequence_unchanged(random_input, inplace):
        """Test that unsupported fusion sequences leave modules unchanged."""
        # Setup
        model = UnsupportedSequence()
        model.eval()
    
        # Get original output
        with torch.no_grad():
            original_output = model(random_input)
    
        # Try to fuse unsupported sequence (conv-relu-conv)
        modules_to_fuse = ["conv", "relu", "conv2"]
>       fused_model = fuse_modules(
            model,
            modules_to_fuse,
            inplace=inplace,
            fuser_func=None,  # Use default
            fuse_custom_config_dict=None
        )

tests/test_torch_ao_quantization_fuse_modules_g1.py:454: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:152: in fuse_modules
    return _fuse_modules(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:90: in _fuse_modules
    _fuse_modules_helper(model, modules_to_fuse, is_qat, fuser_func, fuse_custom_config_dict)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:78: in _fuse_modules_helper
    new_mod_list = fuser_func(mod_list, is_qat, additional_fuser_method_mapping)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuse_modules.py:46: in fuse_known_modules
    fuser_method = get_fuser_method(types, additional_fuser_method_mapping)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

op_list = (<class 'torch.nn.modules.conv.Conv2d'>, <class 'torch.nn.modules.activation.ReLU'>, <class 'torch.nn.modules.conv.Conv2d'>)
additional_fuser_method_mapping = {}

    def get_fuser_method(op_list, additional_fuser_method_mapping=None):
        ''' Get fuser method for the given list of module types,
        return None if fuser method does not exist
        '''
        if additional_fuser_method_mapping is None:
            additional_fuser_method_mapping = {}
        all_mappings = get_combined_dict(DEFAULT_OP_LIST_TO_FUSER_METHOD,
                                         additional_fuser_method_mapping)
        fuser_method = all_mappings.get(op_list, None)
>       assert fuser_method is not None, "did not find fuser method for: {} ".format(op_list)
E       AssertionError: did not find fuser method for: (<class 'torch.nn.modules.conv.Conv2d'>, <class 'torch.nn.modules.activation.ReLU'>, <class 'torch.nn.modules.conv.Conv2d'>)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/ao/quantization/fuser_method_mappings.py:184: AssertionError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                                  Stmts   Miss Branch BrPart  Cover   Missing
-------------------------------------------------------------------------------------------------
tests/test_torch_ao_quantization_fuse_modules_g1.py     238     39     28      5    83%   22, 76-83, 86-94, 283->282, 297, 426, 463-500, 509-510
tests/test_torch_ao_quantization_fuse_modules_g2.py     119     15     10      3    84%   22, 60, 215-230, 272, 312, 329-330
-------------------------------------------------------------------------------------------------
TOTAL                                                   357     54     38      8    83%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_ao_quantization_fuse_modules_g1.py::test_multi_group_module_fusion[modules_to_fuse1-False]
FAILED tests/test_torch_ao_quantization_fuse_modules_g1.py::test_unsupported_sequence_unchanged[False]
2 failed, 16 passed in 0.91s

Error: exit 1