# torch.ao.quantization.fuse_modules 测试计划

## 1. 测试策略
- 单元测试框架：pytest
- 隔离策略：使用 pytest fixtures 创建独立测试模型，mock 自定义融合函数
- 随机性处理：固定随机种子确保可重复性
- 设备兼容性：优先 CPU，GPU 作为可选扩展

## 2. 生成规格摘要（来自 test_plan.json）
- **SMOKE_SET**: CASE_01（单组conv-bn-relu融合）、CASE_02（多组模块融合）、CASE_03（inplace参数行为）、CASE_06（无效模块名称异常）
- **DEFERRED_SET**: CASE_04（嵌套子模块融合）、CASE_05（不支持序列保持不变）、CASE_07（非Module类型输入）、CASE_08（空列表输入）、CASE_09（自定义fuser_func）
- **group 列表**: G1（核心融合功能）、G2（边界与异常处理）
- **active_group_order**: G1 → G2
- **断言分级策略**: 首轮使用 weak 断言（模型类型、结构、输出形状、有限输出），后续启用 strong 断言（近似相等、模块类型验证）
- **预算策略**: 
  - S 尺寸：max_lines ≤ 70, max_params ≤ 5
  - M 尺寸：max_lines ≤ 85, max_params ≤ 5
  - 所有用例均为参数化测试

## 3. 数据与边界
- **正常数据集**: 简单 Conv-BN-ReLU 模型、多层混合模型、嵌套结构模型
- **随机生成策略**: 固定种子生成随机权重，确保可重复性
- **边界值**: 
  - 空融合列表（无操作）
  - 单元素列表（无融合）
  - 重复模块名称（可能异常）
  - 深度嵌套模块（5层以上）
- **极端形状**: 
  - 大输入尺寸（1000+特征）
  - 多通道卷积（256+通道）
  - 复杂模块结构（分支、残差）
- **负例与异常场景**:
  - 无效模块名称
  - 非 Module 类型输入
  - 非 list 类型 modules_to_fuse
  - 不支持融合的模块序列
  - 训练模式下的模型

## 4. 覆盖映射
| TC_ID | 需求覆盖 | 约束覆盖 | 风险点 |
|-------|----------|----------|--------|
| TC-01 | 单组模块融合 | eval() 模式，正确序列 | 支持的 Conv 类型未明确 |
| TC-02 | 多组模块融合 | 列表的列表格式 | 融合顺序是否正确 |
| TC-03 | inplace 行为 | 原地修改 vs 新副本 | 钩子丢失验证 |
| TC-04 | 嵌套子模块 | 模块访问路径 | 深度嵌套性能 |
| TC-05 | 不支持序列 | 保持不变行为 | 异常处理策略 |
| TC-06 | 异常处理 | 模块存在性检查 | 错误信息准确性 |
| TC-07 | 类型检查 | 参数类型验证 | 异常类型匹配 |
| TC-08 | 边界处理 | 空输入处理 | 无操作正确性 |
| TC-09 | 自定义融合 | 函数调用接口 | mock 正确性 |

**尚未覆盖的风险点**:
- 自定义融合配置的具体格式限制
- 融合后模块命名具体规则
- 不同设备（GPU）兼容性
- 大模型融合性能基准
- 融合后模型序列化/反序列化兼容性