=== Run Tests ===
FFFFF                                                                    [100%]
=================================== FAILURES ===================================
_ test_basic_cpp_extension_compilation[test_extension-sources0-extra_cflags0-False-True] _

test_name = 'test_extension', sources = ['test.cpp'], extra_cflags = ['-O2']
verbose = False, is_python_module = True
mock_subprocess = <MagicMock name='run' id='5382140304'>
mock_import_module = <MagicMock name='import_module' id='5382137280'>
mock_tempfile = <MagicMock name='mkdtemp' id='5382479232'>
mock_os_path = <MagicMock name='exists' id='5382472560'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-2/test_basic_cpp_extension_compi0')

    @pytest.mark.parametrize("test_name,sources,extra_cflags,verbose,is_python_module", [
        ("test_extension", ["test.cpp"], ["-O2"], False, True),
    ])
    def test_basic_cpp_extension_compilation(
        test_name, sources, extra_cflags, verbose, is_python_module,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        cleanup_temp_dirs, tmp_path
    ):
        """
        测试基本C++扩展编译和加载功能
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # 调用load函数
        with patch('os.path.exists') as mock_exists:
            mock_exists.return_value = True
    
>           module = load(
                name=test_name,
                sources=source_paths,
                extra_cflags=extra_cflags,
                verbose=verbose,
                is_python_module=is_python_module
            )

tests/test_torch_utils_cpp_extension_g1.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x140dbf4f0>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/test_extension/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
_ test_mixed_cpp_cuda_extension[cuda_extension-sources0-extra_cuda_cflags0-True-True] _

test_name = 'cuda_extension', sources = ['cuda.cpp', 'kernel.cu']
extra_cuda_cflags = ['-O3'], with_cuda = True, verbose = True
mock_subprocess = <MagicMock name='run' id='4379545648'>
mock_import_module = <MagicMock name='import_module' id='5383126464'>
mock_tempfile = <MagicMock name='mkdtemp' id='5383924816'>
mock_os_path = <MagicMock name='exists' id='5383913920'>
mock_cuda_available = <MagicMock name='is_available' id='5384299248'>
cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-2/test_mixed_cpp_cuda_extension_0')

    @pytest.mark.parametrize("test_name,sources,extra_cuda_cflags,with_cuda,verbose", [
        ("cuda_extension", ["cuda.cpp", "kernel.cu"], ["-O3"], True, True),
    ])
    def test_mixed_cpp_cuda_extension(
        test_name, sources, extra_cuda_cflags, with_cuda, verbose,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_cuda_available, cleanup_temp_dirs, tmp_path
    ):
        """
        测试混合C++/CUDA扩展编译功能
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            if source_file.endswith('.cu'):
                file_path.write_text(CUDA_CPP_CONTENT)
            else:
                file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # 调用load函数
        with patch('os.path.exists') as mock_exists:
            mock_exists.return_value = True
    
>           module = load(
                name=test_name,
                sources=source_paths,
                extra_cuda_cflags=extra_cuda_cflags,
                with_cuda=with_cuda,
                verbose=verbose
            )

tests/test_torch_utils_cpp_extension_g1.py:203: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x140e97160>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/cuda_extension/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
----------------------------- Captured stderr call -----------------------------
Using /Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu as PyTorch extensions root...
_ test_parameter_combinations[param_test-sources0-extra_cflags0-extra_include_paths0-/tmp/test_build-False] _

test_name = 'param_test', sources = ['test.cpp']
extra_cflags = ['-Wall', '-Wextra']
extra_include_paths = ['/usr/local/include']
build_directory = '/tmp/test_build', keep_intermediates = False
mock_subprocess = <MagicMock name='run' id='5383914256'>
mock_import_module = <MagicMock name='import_module' id='5385217040'>
mock_tempfile = <MagicMock name='mkdtemp' id='5384008224'>
mock_os_path = <MagicMock name='exists' id='5384404656'>
mock_os_makedirs = <MagicMock name='makedirs' id='5384398800'>
mock_shutil_rmtree = <MagicMock name='rmtree' id='5385232656'>
mock_file_baton = <MagicMock name='FileBaton' id='5385225504'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='5384774720'>
cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-2/test_parameter_combinations_pa0')

    @pytest.mark.parametrize("test_name,sources,extra_cflags,extra_include_paths,build_directory,keep_intermediates", [
        ("param_test", ["test.cpp"], ["-Wall", "-Wextra"], ["/usr/local/include"], "/tmp/test_build", False),
    ])
    def test_parameter_combinations(
        test_name, sources, extra_cflags, extra_include_paths, build_directory, keep_intermediates,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_os_makedirs, mock_shutil_rmtree, mock_file_baton, mock_os_makedirs_for_cache,
        cleanup_temp_dirs, tmp_path
    ):
        """
        测试各种参数组合
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # Mock构建目录创建
        mock_build_dir = "/tmp/mock_build_dir"
    
        # 调用load函数
        with patch('os.path.exists') as mock_exists:
            mock_exists.return_value = True
    
            with patch('tempfile.mkdtemp') as mock_mkdtemp:
                if build_directory is None:
                    mock_mkdtemp.return_value = mock_build_dir
                else:
                    # 如果指定了构建目录，确保它存在
                    mock_exists.return_value = True
    
                # 确保FileBaton被正确mock，并且目录存在
                with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                    mock_baton = Mock()
                    mock_baton.try_acquire.return_value = True
                    mock_baton.release.return_value = None
                    mock_baton_class.return_value = mock_baton
    
                    # 确保构建目录存在
                    with patch('os.makedirs') as mock_makedirs:
                        mock_makedirs.return_value = None
    
                        # 确保缓存目录存在
                        with patch('os.path.isdir') as mock_isdir:
                            mock_isdir.return_value = True
    
>                           module = load(
                                name=test_name,
                                sources=source_paths,
                                extra_cflags=extra_cflags,
                                extra_include_paths=extra_include_paths,
                                build_directory=build_directory,
                                keep_intermediates=keep_intermediates
                            )

tests/test_torch_utils_cpp_extension_g2.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x140d804c0>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/tmp/test_build/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
______ test_invalid_source_files[invalid_ext-sources0-True-RuntimeError] _______

test_name = 'invalid_ext', sources = [], expect_error = True
error_type = <class 'RuntimeError'>
mock_subprocess = <MagicMock name='run' id='5384398704'>
mock_tempfile = <MagicMock name='mkdtemp' id='5382303760'>
mock_os_path = <MagicMock name='exists' id='5382294304'>
mock_file_baton = <MagicMock name='FileBaton' id='5382878064'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='5381892144'>
cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-2/test_invalid_source_files_inva0')

    @pytest.mark.parametrize("test_name,sources,expect_error,error_type", [
        ("invalid_ext", [], True, RuntimeError),
        ("invalid_ext", ["nonexistent.cpp"], True, RuntimeError),
    ])
    def test_invalid_source_files(
        test_name, sources, expect_error, error_type,
        mock_subprocess, mock_tempfile, mock_os_path, mock_file_baton,
        mock_os_makedirs_for_cache, cleanup_temp_dirs, tmp_path
    ):
        """
        测试无效源文件的错误处理
        """
        # 准备源文件路径列表
        source_paths = []
        for source_file in sources:
            if source_file:  # 非空字符串
                source_paths.append(str(tmp_path / source_file))
    
        # 根据测试场景设置mock
        with patch('os.path.exists') as mock_exists:
            if not sources or "nonexistent" in str(sources):
                # 文件不存在
                mock_exists.return_value = False
            else:
                mock_exists.return_value = True
    
            if expect_error:
                # 期望抛出异常
                with pytest.raises(error_type) as exc_info:
                    # 确保FileBaton被正确mock，并且缓存目录存在
                    with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                        mock_baton = Mock()
                        mock_baton.try_acquire.return_value = True
                        mock_baton.release.return_value = None
                        mock_baton_class.return_value = mock_baton
    
                        # 确保缓存目录存在
                        with patch('os.makedirs') as mock_makedirs:
                            mock_makedirs.return_value = None
    
                            # 对于nonexistent.cpp的情况，需要mock哈希计算
                            if sources and "nonexistent" in str(sources):
                                with patch('torch.utils._cpp_extension_versioner.hash_source_files') as mock_hash:
                                    mock_hash.return_value = 12345
    
                                    load(
                                        name=test_name,
                                        sources=source_paths if source_paths else []
                                    )
                            else:
                                # 对于空sources的情况，正常调用
>                               load(
                                    name=test_name,
                                    sources=source_paths if source_paths else []
                                )

tests/test_torch_utils_cpp_extension_g2.py:269: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x140cc0880>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/invalid_ext/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
______ test_invalid_source_files[invalid_ext-sources1-True-RuntimeError] _______

test_name = 'invalid_ext', sources = ['nonexistent.cpp'], expect_error = True
error_type = <class 'RuntimeError'>
mock_subprocess = <MagicMock name='run' id='5382878016'>
mock_tempfile = <MagicMock name='mkdtemp' id='5380518192'>
mock_os_path = <MagicMock name='exists' id='5382084000'>
mock_file_baton = <MagicMock name='FileBaton' id='5382094128'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='5380496144'>
cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-2/test_invalid_source_files_inva1')

    @pytest.mark.parametrize("test_name,sources,expect_error,error_type", [
        ("invalid_ext", [], True, RuntimeError),
        ("invalid_ext", ["nonexistent.cpp"], True, RuntimeError),
    ])
    def test_invalid_source_files(
        test_name, sources, expect_error, error_type,
        mock_subprocess, mock_tempfile, mock_os_path, mock_file_baton,
        mock_os_makedirs_for_cache, cleanup_temp_dirs, tmp_path
    ):
        """
        测试无效源文件的错误处理
        """
        # 准备源文件路径列表
        source_paths = []
        for source_file in sources:
            if source_file:  # 非空字符串
                source_paths.append(str(tmp_path / source_file))
    
        # 根据测试场景设置mock
        with patch('os.path.exists') as mock_exists:
            if not sources or "nonexistent" in str(sources):
                # 文件不存在
                mock_exists.return_value = False
            else:
                mock_exists.return_value = True
    
            if expect_error:
                # 期望抛出异常
                with pytest.raises(error_type) as exc_info:
                    # 确保FileBaton被正确mock，并且缓存目录存在
                    with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                        mock_baton = Mock()
                        mock_baton.try_acquire.return_value = True
                        mock_baton.release.return_value = None
                        mock_baton_class.return_value = mock_baton
    
                        # 确保缓存目录存在
                        with patch('os.makedirs') as mock_makedirs:
                            mock_makedirs.return_value = None
    
                            # 对于nonexistent.cpp的情况，需要mock哈希计算
                            if sources and "nonexistent" in str(sources):
                                with patch('torch.utils._cpp_extension_versioner.hash_source_files') as mock_hash:
                                    mock_hash.return_value = 12345
    
>                                   load(
                                        name=test_name,
                                        sources=source_paths if source_paths else []
                                    )

tests/test_torch_utils_cpp_extension_g2.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x140cc07f0>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/invalid_ext/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
=============================== warnings summary ===============================
../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:25
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
    from pkg_resources import packaging  # type: ignore[attr-defined]

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/pkg_resources/__init__.py:3146
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/pkg_resources/__init__.py:3146: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('google')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                         Stmts   Miss Branch BrPart  Cover   Missing
----------------------------------------------------------------------------------------
tests/conftest.py                               43     18      0      0    58%   60, 65, 70-76, 81-86, 91-93
tests/test_torch_utils_cpp_extension_g1.py     104     33     22      2    63%   62-63, 146-169, 212-247, 260
tests/test_torch_utils_cpp_extension_g2.py     161     48     42      6    67%   81-83, 88-90, 98-99, 150, 180-213, 233->232, 242, 275-309, 322
----------------------------------------------------------------------------------------
TOTAL                                          308     99     64      8    64%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_utils_cpp_extension_g1.py::test_basic_cpp_extension_compilation[test_extension-sources0-extra_cflags0-False-True]
FAILED tests/test_torch_utils_cpp_extension_g1.py::test_mixed_cpp_cuda_extension[cuda_extension-sources0-extra_cuda_cflags0-True-True]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_parameter_combinations[param_test-sources0-extra_cflags0-extra_include_paths0-/tmp/test_build-False]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_invalid_source_files[invalid_ext-sources0-True-RuntimeError]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_invalid_source_files[invalid_ext-sources1-True-RuntimeError]
5 failed, 2 warnings in 1.01s

Error: exit 1