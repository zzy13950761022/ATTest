=== Run Tests ===
FFFFF                                                                    [100%]
=================================== FAILURES ===================================
_ test_basic_cpp_extension_compilation[test_extension-sources0-extra_cflags0-False-True] _

test_name = 'test_extension', sources = ['test.cpp'], extra_cflags = ['-O2']
verbose = False, is_python_module = True
mock_subprocess = <MagicMock name='run' id='5084332480'>
mock_import_module = <MagicMock name='import_module' id='5084344384'>
mock_tempfile = <MagicMock name='mkdtemp' id='5084407040'>
mock_os_path = <MagicMock name='exists' id='5084401568'>
mock_file_baton = <MagicMock name='FileBaton' id='5084315168'>
mock_os_makedirs = <MagicMock name='makedirs' id='5084301104'>
mock_os_isdir = <MagicMock name='isdir' id='5084484016'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-4/test_basic_cpp_extension_compi0')

    @pytest.mark.parametrize("test_name,sources,extra_cflags,verbose,is_python_module", [
        ("test_extension", ["test.cpp"], ["-O2"], False, True),
    ])
    def test_basic_cpp_extension_compilation(
        test_name, sources, extra_cflags, verbose, is_python_module,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_file_baton, mock_os_makedirs, mock_os_isdir,
        cleanup_temp_dirs, tmp_path
    ):
        """
        测试基本C++扩展编译和加载功能
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # 确保缓存目录存在 - 使用mock确保目录创建成功
        # 注意：这里我们依赖mock_file_baton fixture已经正确设置了FileBaton的mock
        # 并且mock_file_baton中的MockFileBaton类会确保目录存在
    
        # 调用load函数
>       module = load(
            name=test_name,
            sources=source_paths,
            extra_cflags=extra_cflags,
            verbose=verbose,
            is_python_module=is_python_module
        )

tests/test_torch_utils_cpp_extension_g1.py:185: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x12f0f2b60>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/test_extension/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
_ test_mixed_cpp_cuda_extension[cuda_extension-sources0-extra_cuda_cflags0-True-True] _

test_name = 'cuda_extension', sources = ['cuda.cpp', 'kernel.cu']
extra_cuda_cflags = ['-O3'], with_cuda = True, verbose = True
mock_subprocess = <MagicMock name='run' id='5084301152'>
mock_import_module = <MagicMock name='import_module' id='4407611920'>
mock_tempfile = <MagicMock name='mkdtemp' id='5086455232'>
mock_os_path = <MagicMock name='exists' id='5086447072'>
mock_cuda_available = <MagicMock name='is_available' id='5086093104'>
mock_file_baton = <MagicMock name='FileBaton' id='5086100304'>
mock_os_makedirs = <MagicMock name='makedirs' id='5086173008'>
mock_os_isdir = <MagicMock name='isdir' id='5086532688'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-4/test_mixed_cpp_cuda_extension_0')

    @pytest.mark.parametrize("test_name,sources,extra_cuda_cflags,with_cuda,verbose", [
        ("cuda_extension", ["cuda.cpp", "kernel.cu"], ["-O3"], True, True),
    ])
    def test_mixed_cpp_cuda_extension(
        test_name, sources, extra_cuda_cflags, with_cuda, verbose,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_cuda_available, mock_file_baton, mock_os_makedirs, mock_os_isdir,
        cleanup_temp_dirs, tmp_path
    ):
        """
        测试混合C++/CUDA扩展编译功能
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            if source_file.endswith('.cu'):
                file_path.write_text(CUDA_CPP_CONTENT)
            else:
                file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # 调用load函数
>       module = load(
            name=test_name,
            sources=source_paths,
            extra_cuda_cflags=extra_cuda_cflags,
            with_cuda=with_cuda,
            verbose=verbose
        )

tests/test_torch_utils_cpp_extension_g1.py:249: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x12f2e6080>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/cuda_extension/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
----------------------------- Captured stderr call -----------------------------
Using /Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu as PyTorch extensions root...
_ test_parameter_combinations[param_test-sources0-extra_cflags0-extra_include_paths0-/tmp/test_build-False] _

test_name = 'param_test', sources = ['test.cpp']
extra_cflags = ['-Wall', '-Wextra']
extra_include_paths = ['/usr/local/include']
build_directory = '/tmp/test_build', keep_intermediates = False
mock_subprocess = <MagicMock name='run' id='5086101456'>
mock_import_module = <MagicMock name='import_module' id='5087389024'>
mock_tempfile = <MagicMock name='mkdtemp' id='5087385328'>
mock_os_path = <MagicMock name='exists' id='5087365200'>
mock_os_makedirs = <MagicMock name='makedirs' id='5086542000'>
mock_shutil_rmtree = <MagicMock name='rmtree' id='5086915424'>
mock_file_baton = <MagicMock name='FileBaton' id='5086913360'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='5084295472'>
mock_os_isdir = <MagicMock name='isdir' id='5084287312'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-4/test_parameter_combinations_pa0')

    @pytest.mark.parametrize("test_name,sources,extra_cflags,extra_include_paths,build_directory,keep_intermediates", [
        ("param_test", ["test.cpp"], ["-Wall", "-Wextra"], ["/usr/local/include"], "/tmp/test_build", False),
    ])
    def test_parameter_combinations(
        test_name, sources, extra_cflags, extra_include_paths, build_directory, keep_intermediates,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_os_makedirs, mock_shutil_rmtree, mock_file_baton, mock_os_makedirs_for_cache,
        mock_os_isdir, cleanup_temp_dirs, tmp_path
    ):
        """
        测试各种参数组合
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # 调用load函数
>       module = load(
            name=test_name,
            sources=source_paths,
            extra_cflags=extra_cflags,
            extra_include_paths=extra_include_paths,
            build_directory=build_directory,
            keep_intermediates=keep_intermediates
        )

tests/test_torch_utils_cpp_extension_g2.py:142: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x12f0f89a0>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/tmp/test_build/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
______ test_invalid_source_files[invalid_ext-sources0-True-RuntimeError] _______

test_name = 'invalid_ext', sources = [], expect_error = True
error_type = <class 'RuntimeError'>
mock_subprocess = <MagicMock name='run' id='5086541856'>
mock_tempfile = <MagicMock name='mkdtemp' id='5084545424'>
mock_os_path = <MagicMock name='exists' id='5085494960'>
mock_file_baton = <MagicMock name='FileBaton' id='5085485216'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='5084515104'>
mock_os_isdir = <MagicMock name='isdir' id='5084525856'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-4/test_invalid_source_files_inva0')

    @pytest.mark.parametrize("test_name,sources,expect_error,error_type", [
        ("invalid_ext", [], True, RuntimeError),
        ("invalid_ext", ["nonexistent.cpp"], True, RuntimeError),
    ])
    def test_invalid_source_files(
        test_name, sources, expect_error, error_type,
        mock_subprocess, mock_tempfile, mock_os_path, mock_file_baton,
        mock_os_makedirs_for_cache, mock_os_isdir, cleanup_temp_dirs, tmp_path
    ):
        """
        测试无效源文件的错误处理
        """
        # 准备源文件路径列表
        source_paths = []
        for source_file in sources:
            if source_file:  # 非空字符串
                source_paths.append(str(tmp_path / source_file))
    
        # 根据测试场景设置mock
        with patch('os.path.exists') as mock_exists:
            if not sources or "nonexistent" in str(sources):
                # 文件不存在
                mock_exists.return_value = False
            else:
                mock_exists.return_value = True
    
            if expect_error:
                # 期望抛出异常
                with pytest.raises(error_type) as exc_info:
                    # 对于nonexistent.cpp的情况，需要mock哈希计算
                    if sources and "nonexistent" in str(sources):
                        with patch('torch.utils._cpp_extension_versioner.hash_source_files') as mock_hash:
                            mock_hash.return_value = 12345
    
                            load(
                                name=test_name,
                                sources=source_paths if source_paths else []
                            )
                    else:
                        # 对于空sources的情况，正常调用
>                       load(
                            name=test_name,
                            sources=source_paths if source_paths else []
                        )

tests/test_torch_utils_cpp_extension_g2.py:230: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x12f1ed090>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/invalid_ext/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
______ test_invalid_source_files[invalid_ext-sources1-True-RuntimeError] _______

test_name = 'invalid_ext', sources = ['nonexistent.cpp'], expect_error = True
error_type = <class 'RuntimeError'>
mock_subprocess = <MagicMock name='run' id='5084528496'>
mock_tempfile = <MagicMock name='mkdtemp' id='5084992592'>
mock_os_path = <MagicMock name='exists' id='5084999168'>
mock_file_baton = <MagicMock name='FileBaton' id='5086506352'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='5086495792'>
mock_os_isdir = <MagicMock name='isdir' id='5085536336'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-4/test_invalid_source_files_inva1')

    @pytest.mark.parametrize("test_name,sources,expect_error,error_type", [
        ("invalid_ext", [], True, RuntimeError),
        ("invalid_ext", ["nonexistent.cpp"], True, RuntimeError),
    ])
    def test_invalid_source_files(
        test_name, sources, expect_error, error_type,
        mock_subprocess, mock_tempfile, mock_os_path, mock_file_baton,
        mock_os_makedirs_for_cache, mock_os_isdir, cleanup_temp_dirs, tmp_path
    ):
        """
        测试无效源文件的错误处理
        """
        # 准备源文件路径列表
        source_paths = []
        for source_file in sources:
            if source_file:  # 非空字符串
                source_paths.append(str(tmp_path / source_file))
    
        # 根据测试场景设置mock
        with patch('os.path.exists') as mock_exists:
            if not sources or "nonexistent" in str(sources):
                # 文件不存在
                mock_exists.return_value = False
            else:
                mock_exists.return_value = True
    
            if expect_error:
                # 期望抛出异常
                with pytest.raises(error_type) as exc_info:
                    # 对于nonexistent.cpp的情况，需要mock哈希计算
                    if sources and "nonexistent" in str(sources):
                        with patch('torch.utils._cpp_extension_versioner.hash_source_files') as mock_hash:
                            mock_hash.return_value = 12345
    
>                           load(
                                name=test_name,
                                sources=source_paths if source_paths else []
                            )

tests/test_torch_utils_cpp_extension_g2.py:224: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x12f1ed150>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/invalid_ext/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
=============================== warnings summary ===============================
../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:25
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
    from pkg_resources import packaging  # type: ignore[attr-defined]

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/pkg_resources/__init__.py:3146
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/pkg_resources/__init__.py:3146: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('google')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                         Stmts   Miss Branch BrPart  Cover   Missing
----------------------------------------------------------------------------------------
tests/conftest.py                               61     30      0      0    51%   60, 65, 70-76, 81-86, 91-93, 98-103, 108-110, 115-117
tests/test_torch_utils_cpp_extension_g1.py     131     44     24      2    61%   63-70, 74, 78-79, 83, 108-109, 194-217, 258-293, 308
tests/test_torch_utils_cpp_extension_g2.py     133     39     30      5    64%   81-83, 98-99, 152-185, 205->204, 214, 236-263, 276
----------------------------------------------------------------------------------------
TOTAL                                          325    113     54      7    61%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_utils_cpp_extension_g1.py::test_basic_cpp_extension_compilation[test_extension-sources0-extra_cflags0-False-True]
FAILED tests/test_torch_utils_cpp_extension_g1.py::test_mixed_cpp_cuda_extension[cuda_extension-sources0-extra_cuda_cflags0-True-True]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_parameter_combinations[param_test-sources0-extra_cflags0-extra_include_paths0-/tmp/test_build-False]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_invalid_source_files[invalid_ext-sources0-True-RuntimeError]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_invalid_source_files[invalid_ext-sources1-True-RuntimeError]
5 failed, 2 warnings in 1.07s

Error: exit 1