=== Run Tests ===
FFFFF                                                                    [100%]
=================================== FAILURES ===================================
_ test_basic_cpp_extension_compilation[test_extension-sources0-extra_cflags0-False-True] _

test_name = 'test_extension', sources = ['test.cpp'], extra_cflags = ['-O2']
verbose = False, is_python_module = True
mock_subprocess = <MagicMock name='run' id='4970912720'>
mock_import_module = <MagicMock name='import_module' id='4970919344'>
mock_tempfile = <MagicMock name='mkdtemp' id='4972290848'>
mock_os_path = <MagicMock name='exists' id='4972282064'>
mock_file_baton = <MagicMock name='FileBaton' id='4971986080'>
mock_os_makedirs = <MagicMock name='makedirs' id='4971982912'>
mock_os_isdir = <MagicMock name='isdir' id='4971789760'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-3/test_basic_cpp_extension_compi0')

    @pytest.mark.parametrize("test_name,sources,extra_cflags,verbose,is_python_module", [
        ("test_extension", ["test.cpp"], ["-O2"], False, True),
    ])
    def test_basic_cpp_extension_compilation(
        test_name, sources, extra_cflags, verbose, is_python_module,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_file_baton, mock_os_makedirs, mock_os_isdir,
        cleanup_temp_dirs, tmp_path
    ):
        """
        测试基本C++扩展编译和加载功能
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # 调用load函数，确保所有必要的mock都到位
        with patch('os.path.exists') as mock_exists:
            mock_exists.return_value = True
    
            # 确保缓存目录存在
            with patch('os.makedirs') as mock_makedirs:
                mock_makedirs.return_value = None
    
                # 确保目录检查通过
                with patch('os.path.isdir') as mock_isdir:
                    mock_isdir.return_value = True
    
                    # 确保FileBaton被正确mock
                    with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                        mock_baton = Mock()
                        mock_baton.try_acquire.return_value = True
                        mock_baton.release.return_value = None
                        mock_baton_class.return_value = mock_baton
    
>                       module = load(
                            name=test_name,
                            sources=source_paths,
                            extra_cflags=extra_cflags,
                            verbose=verbose,
                            is_python_module=is_python_module
                        )

tests/test_torch_utils_cpp_extension_g1.py:177: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x12843ab00>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/test_extension/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
_ test_mixed_cpp_cuda_extension[cuda_extension-sources0-extra_cuda_cflags0-True-True] _

test_name = 'cuda_extension', sources = ['cuda.cpp', 'kernel.cu']
extra_cuda_cflags = ['-O3'], with_cuda = True, verbose = True
mock_subprocess = <MagicMock name='run' id='4971982144'>
mock_import_module = <MagicMock name='import_module' id='4426901216'>
mock_tempfile = <MagicMock name='mkdtemp' id='4974025248'>
mock_os_path = <MagicMock name='exists' id='4974032256'>
mock_cuda_available = <MagicMock name='is_available' id='4974010352'>
mock_file_baton = <MagicMock name='FileBaton' id='4974018368'>
mock_os_makedirs = <MagicMock name='makedirs' id='4973999392'>
mock_os_isdir = <MagicMock name='isdir' id='4973990944'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-3/test_mixed_cpp_cuda_extension_0')

    @pytest.mark.parametrize("test_name,sources,extra_cuda_cflags,with_cuda,verbose", [
        ("cuda_extension", ["cuda.cpp", "kernel.cu"], ["-O3"], True, True),
    ])
    def test_mixed_cpp_cuda_extension(
        test_name, sources, extra_cuda_cflags, with_cuda, verbose,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_cuda_available, mock_file_baton, mock_os_makedirs, mock_os_isdir,
        cleanup_temp_dirs, tmp_path
    ):
        """
        测试混合C++/CUDA扩展编译功能
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            if source_file.endswith('.cu'):
                file_path.write_text(CUDA_CPP_CONTENT)
            else:
                file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # 调用load函数，确保所有必要的mock都到位
        with patch('os.path.exists') as mock_exists:
            mock_exists.return_value = True
    
            # 确保缓存目录存在
            with patch('os.makedirs') as mock_makedirs:
                mock_makedirs.return_value = None
    
                # 确保目录检查通过
                with patch('os.path.isdir') as mock_isdir:
                    mock_isdir.return_value = True
    
                    # 确保FileBaton被正确mock
                    with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                        mock_baton = Mock()
                        mock_baton.try_acquire.return_value = True
                        mock_baton.release.return_value = None
                        mock_baton_class.return_value = mock_baton
    
>                       module = load(
                            name=test_name,
                            sources=source_paths,
                            extra_cuda_cflags=extra_cuda_cflags,
                            with_cuda=with_cuda,
                            verbose=verbose
                        )

tests/test_torch_utils_cpp_extension_g1.py:259: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x12f08dd20>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/cuda_extension/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
----------------------------- Captured stderr call -----------------------------
Using /Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu as PyTorch extensions root...
_ test_parameter_combinations[param_test-sources0-extra_cflags0-extra_include_paths0-/tmp/test_build-False] _

test_name = 'param_test', sources = ['test.cpp']
extra_cflags = ['-Wall', '-Wextra']
extra_include_paths = ['/usr/local/include']
build_directory = '/tmp/test_build', keep_intermediates = False
mock_subprocess = <MagicMock name='run' id='4974013328'>
mock_import_module = <MagicMock name='import_module' id='5084095600'>
mock_tempfile = <MagicMock name='mkdtemp' id='5084098384'>
mock_os_path = <MagicMock name='exists' id='4973390112'>
mock_os_makedirs = <MagicMock name='makedirs' id='4973383392'>
mock_shutil_rmtree = <MagicMock name='rmtree' id='4970954864'>
mock_file_baton = <MagicMock name='FileBaton' id='4970962928'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='4973323712'>
mock_os_isdir = <MagicMock name='isdir' id='4973326304'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-3/test_parameter_combinations_pa0')

    @pytest.mark.parametrize("test_name,sources,extra_cflags,extra_include_paths,build_directory,keep_intermediates", [
        ("param_test", ["test.cpp"], ["-Wall", "-Wextra"], ["/usr/local/include"], "/tmp/test_build", False),
    ])
    def test_parameter_combinations(
        test_name, sources, extra_cflags, extra_include_paths, build_directory, keep_intermediates,
        mock_subprocess, mock_import_module, mock_tempfile, mock_os_path,
        mock_os_makedirs, mock_shutil_rmtree, mock_file_baton, mock_os_makedirs_for_cache,
        mock_os_isdir, cleanup_temp_dirs, tmp_path
    ):
        """
        测试各种参数组合
        """
        # 创建测试源文件
        source_dir = tmp_path / "sources"
        source_dir.mkdir()
    
        for source_file in sources:
            file_path = source_dir / source_file
            file_path.write_text(SIMPLE_CPP_CONTENT)
    
        # 准备源文件路径列表
        source_paths = [str(source_dir / s) for s in sources]
    
        # Mock构建目录创建
        mock_build_dir = "/tmp/mock_build_dir"
    
        # 调用load函数，确保所有必要的mock都到位
        with patch('os.path.exists') as mock_exists:
            mock_exists.return_value = True
    
            with patch('tempfile.mkdtemp') as mock_mkdtemp:
                if build_directory is None:
                    mock_mkdtemp.return_value = mock_build_dir
                else:
                    # 如果指定了构建目录，确保它存在
                    mock_exists.return_value = True
    
                # 确保FileBaton被正确mock，并且目录存在
                with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                    mock_baton = Mock()
                    mock_baton.try_acquire.return_value = True
                    mock_baton.release.return_value = None
                    mock_baton_class.return_value = mock_baton
    
                    # 确保构建目录存在
                    with patch('os.makedirs') as mock_makedirs:
                        mock_makedirs.return_value = None
    
                        # 确保缓存目录存在
                        with patch('os.path.isdir') as mock_isdir:
                            mock_isdir.return_value = True
    
>                           module = load(
                                name=test_name,
                                sources=source_paths,
                                extra_cflags=extra_cflags,
                                extra_include_paths=extra_include_paths,
                                build_directory=build_directory,
                                keep_intermediates=keep_intermediates
                            )

tests/test_torch_utils_cpp_extension_g2.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x1285c5e70>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/tmp/test_build/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
______ test_invalid_source_files[invalid_ext-sources0-True-RuntimeError] _______

test_name = 'invalid_ext', sources = [], expect_error = True
error_type = <class 'RuntimeError'>
mock_subprocess = <MagicMock name='run' id='4973389488'>
mock_tempfile = <MagicMock name='mkdtemp' id='4972117968'>
mock_os_path = <MagicMock name='exists' id='4972310304'>
mock_file_baton = <MagicMock name='FileBaton' id='4972299696'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='4974205760'>
mock_os_isdir = <MagicMock name='isdir' id='4974199184'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-3/test_invalid_source_files_inva0')

    @pytest.mark.parametrize("test_name,sources,expect_error,error_type", [
        ("invalid_ext", [], True, RuntimeError),
        ("invalid_ext", ["nonexistent.cpp"], True, RuntimeError),
    ])
    def test_invalid_source_files(
        test_name, sources, expect_error, error_type,
        mock_subprocess, mock_tempfile, mock_os_path, mock_file_baton,
        mock_os_makedirs_for_cache, mock_os_isdir, cleanup_temp_dirs, tmp_path
    ):
        """
        测试无效源文件的错误处理
        """
        # 准备源文件路径列表
        source_paths = []
        for source_file in sources:
            if source_file:  # 非空字符串
                source_paths.append(str(tmp_path / source_file))
    
        # 根据测试场景设置mock
        with patch('os.path.exists') as mock_exists:
            if not sources or "nonexistent" in str(sources):
                # 文件不存在
                mock_exists.return_value = False
            else:
                mock_exists.return_value = True
    
            if expect_error:
                # 期望抛出异常
                with pytest.raises(error_type) as exc_info:
                    # 确保FileBaton被正确mock，并且缓存目录存在
                    with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                        mock_baton = Mock()
                        mock_baton.try_acquire.return_value = True
                        mock_baton.release.return_value = None
                        mock_baton_class.return_value = mock_baton
    
                        # 确保缓存目录存在
                        with patch('os.makedirs') as mock_makedirs:
                            mock_makedirs.return_value = None
    
                            # 确保目录检查通过
                            with patch('os.path.isdir') as mock_isdir:
                                mock_isdir.return_value = True
    
                                # 对于nonexistent.cpp的情况，需要mock哈希计算
                                if sources and "nonexistent" in str(sources):
                                    with patch('torch.utils._cpp_extension_versioner.hash_source_files') as mock_hash:
                                        mock_hash.return_value = 12345
    
                                        load(
                                            name=test_name,
                                            sources=source_paths if source_paths else []
                                        )
                                else:
                                    # 对于空sources的情况，正常调用
>                                   load(
                                        name=test_name,
                                        sources=source_paths if source_paths else []
                                    )

tests/test_torch_utils_cpp_extension_g2.py:273: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x1287ba080>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/invalid_ext/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
______ test_invalid_source_files[invalid_ext-sources1-True-RuntimeError] _______

test_name = 'invalid_ext', sources = ['nonexistent.cpp'], expect_error = True
error_type = <class 'RuntimeError'>
mock_subprocess = <MagicMock name='run' id='4972344800'>
mock_tempfile = <MagicMock name='mkdtemp' id='4974224016'>
mock_os_path = <MagicMock name='exists' id='4974227376'>
mock_file_baton = <MagicMock name='FileBaton' id='4974278304'>
mock_os_makedirs_for_cache = <MagicMock name='makedirs' id='4974270528'>
mock_os_isdir = <MagicMock name='isdir' id='4974413184'>, cleanup_temp_dirs = []
tmp_path = PosixPath('/private/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/pytest-of-zzf1sh/pytest-3/test_invalid_source_files_inva1')

    @pytest.mark.parametrize("test_name,sources,expect_error,error_type", [
        ("invalid_ext", [], True, RuntimeError),
        ("invalid_ext", ["nonexistent.cpp"], True, RuntimeError),
    ])
    def test_invalid_source_files(
        test_name, sources, expect_error, error_type,
        mock_subprocess, mock_tempfile, mock_os_path, mock_file_baton,
        mock_os_makedirs_for_cache, mock_os_isdir, cleanup_temp_dirs, tmp_path
    ):
        """
        测试无效源文件的错误处理
        """
        # 准备源文件路径列表
        source_paths = []
        for source_file in sources:
            if source_file:  # 非空字符串
                source_paths.append(str(tmp_path / source_file))
    
        # 根据测试场景设置mock
        with patch('os.path.exists') as mock_exists:
            if not sources or "nonexistent" in str(sources):
                # 文件不存在
                mock_exists.return_value = False
            else:
                mock_exists.return_value = True
    
            if expect_error:
                # 期望抛出异常
                with pytest.raises(error_type) as exc_info:
                    # 确保FileBaton被正确mock，并且缓存目录存在
                    with patch('torch.utils.file_baton.FileBaton') as mock_baton_class:
                        mock_baton = Mock()
                        mock_baton.try_acquire.return_value = True
                        mock_baton.release.return_value = None
                        mock_baton_class.return_value = mock_baton
    
                        # 确保缓存目录存在
                        with patch('os.makedirs') as mock_makedirs:
                            mock_makedirs.return_value = None
    
                            # 确保目录检查通过
                            with patch('os.path.isdir') as mock_isdir:
                                mock_isdir.return_value = True
    
                                # 对于nonexistent.cpp的情况，需要mock哈希计算
                                if sources and "nonexistent" in str(sources):
                                    with patch('torch.utils._cpp_extension_versioner.hash_source_files') as mock_hash:
                                        mock_hash.return_value = 12345
    
>                                       load(
                                            name=test_name,
                                            sources=source_paths if source_paths else []
                                        )

tests/test_torch_utils_cpp_extension_g2.py:267: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1284: in load
    return _jit_compile(
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:1485: in _jit_compile
    if baton.try_acquire():
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <torch.utils.file_baton.FileBaton object at 0x1287ba020>

    def try_acquire(self):
        '''
        Tries to atomically create a file under exclusive access.
    
        Returns:
            True if the file could be created, else False.
        '''
        try:
>           self.fd = os.open(self.lock_file_path, os.O_CREAT | os.O_EXCL)
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/zzf1sh/Library/Caches/torch_extensions/py310_cpu/invalid_ext/lock'

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/file_baton.py:29: FileNotFoundError
=============================== warnings summary ===============================
../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:25
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/utils/cpp_extension.py:25: UserWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html. The pkg_resources package is slated for removal as early as 2025-11-30. Refrain from using this package or pin to Setuptools<81.
    from pkg_resources import packaging  # type: ignore[attr-defined]

../../../../../../../../opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/pkg_resources/__init__.py:3146
  /opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/pkg_resources/__init__.py:3146: DeprecationWarning: Deprecated call to `pkg_resources.declare_namespace('google')`.
  Implementing implicit namespace packages (as specified in PEP 420) is preferred to `pkg_resources.declare_namespace`. See https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-namespace-packages
    declare_namespace(pkg)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                         Stmts   Miss Branch BrPart  Cover   Missing
----------------------------------------------------------------------------------------
tests/conftest.py                               61     30      0      0    51%   60, 65, 70-76, 81-86, 91-93, 98-103, 108-110, 115-117
tests/test_torch_utils_cpp_extension_g1.py     140     33     30      2    72%   86-87, 186-209, 268-303, 318
tests/test_torch_utils_cpp_extension_g2.py     167     49     46      6    67%   81-83, 98-99, 150, 180-213, 233->232, 242, 279-321, 334
----------------------------------------------------------------------------------------
TOTAL                                          368    112     76      8    67%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_utils_cpp_extension_g1.py::test_basic_cpp_extension_compilation[test_extension-sources0-extra_cflags0-False-True]
FAILED tests/test_torch_utils_cpp_extension_g1.py::test_mixed_cpp_cuda_extension[cuda_extension-sources0-extra_cuda_cflags0-True-True]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_parameter_combinations[param_test-sources0-extra_cflags0-extra_include_paths0-/tmp/test_build-False]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_invalid_source_files[invalid_ext-sources0-True-RuntimeError]
FAILED tests/test_torch_utils_cpp_extension_g2.py::test_invalid_source_files[invalid_ext-sources1-True-RuntimeError]
5 failed, 2 warnings in 1.00s

Error: exit 1