=== Run Tests ===
......F                                                                  [100%]
=================================== FAILURES ===================================
________________ TestSpecialPooling.test_maxunpool1d_edge_cases ________________

self = <test_torch_nn_modules_pooling_special.TestSpecialPooling object at 0x1233bacb0>
set_random_seed = 42

    def test_maxunpool1d_edge_cases(self, set_random_seed):
        """Test MaxUnpool1d with various edge cases"""
        # Test 1: Single element input
        single_input = torch.tensor([[[5.0]]], dtype=torch.float32)
        single_pool = nn.MaxPool1d(kernel_size=1, stride=1, return_indices=True)
        single_pooled, single_indices = single_pool(single_input)
    
        single_unpool = nn.MaxUnpool1d(kernel_size=1, stride=1)
        single_unpooled = single_unpool(single_pooled, single_indices)
    
        assert torch.allclose(single_unpooled, single_input), \
            f"Single element unpooling failed: got {single_unpooled}, expected {single_input}"
    
        # Test 2: Input with all same values
        same_input = torch.ones((1, 1, 4), dtype=torch.float32) * 3.0
        same_pool = nn.MaxPool1d(kernel_size=2, stride=2, return_indices=True)
        same_pooled, same_indices = same_pool(same_input)
    
        same_unpool = nn.MaxUnpool1d(kernel_size=2, stride=2)
        same_unpooled = same_unpool(same_pooled, same_indices)
    
        # When all values are the same, the first one in each window is chosen
        # Input: [3, 3, 3, 3]
        # MaxPool with kernel=2, stride=2: windows [3,3] and [3,3]
        # Max positions: indices 0 and 2 (first element in each window)
        # Unpooled: [3, 0, 3, 0]
        expected_same = torch.tensor([[[3.0, 0.0, 3.0, 0.0]]], dtype=torch.float32)
    
        assert torch.allclose(same_unpooled, expected_same, rtol=1e-6), \
            f"Same values unpooling failed: got {same_unpooled}, expected {expected_same}"
    
        # Test 3: With output_size parameter different from default
        test_input = torch.tensor([[[1.0, 2.0, 3.0, 4.0, 5.0]]], dtype=torch.float32)
        test_pool = nn.MaxPool1d(kernel_size=2, stride=2, return_indices=True)
        test_pooled, test_indices = test_pool(test_input)
    
        test_unpool = nn.MaxUnpool1d(kernel_size=2, stride=2)
    
        # Test with explicit output_size
        custom_size = (1, 1, 6)  # Larger than default
>       custom_unpooled = test_unpool(test_pooled, test_indices, output_size=custom_size)

tests/test_torch_nn_modules_pooling_special.py:353: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/modules/module.py:1190: in _call_impl
    return forward_call(*input, **kwargs)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/modules/pooling.py:323: in forward
    return F.max_unpool1d(input, indices, self.kernel_size, self.stride,
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/functional.py:943: in max_unpool1d
    output_size = _unpool_output_size(input, kernel_size, _stride, padding, output_size)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[2., 4.]]]), kernel_size = (2,), stride = (2,), padding = (0,)
output_size = (6,)

    def _unpool_output_size(
        input: Tensor, kernel_size: List[int], stride: List[int], padding: List[int], output_size: Optional[List[int]]
    ) -> List[int]:
        input_size = input.size()
        default_size = torch.jit.annotate(List[int], [])
        for d in range(len(kernel_size)):
            default_size.append((input_size[-len(kernel_size) + d] - 1) * stride[d] + kernel_size[d] - 2 * padding[d])
        if output_size is None:
            ret = default_size
        else:
            if len(output_size) == len(kernel_size) + 2:
                output_size = output_size[2:]
            if len(output_size) != len(kernel_size):
                raise ValueError(
                    "output_size should be a sequence containing "
                    "{} or {} elements, but it has a length of '{}'".format(
                        len(kernel_size), len(kernel_size) + 2, len(output_size)
                    )
                )
            for d in range(len(kernel_size)):
                min_size = default_size[d] - stride[d]
                max_size = default_size[d] + stride[d]
                if not (min_size < output_size[d] < max_size):
>                   raise ValueError(
                        'invalid output_size "{}" (dim {} must be between {} and {})'.format(
                            output_size, d, min_size, max_size
                        )
                    )
E                   ValueError: invalid output_size "(6,)" (dim 0 must be between 2 and 6)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/functional.py:905: ValueError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                              Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------------------------
tests/test_torch_nn_modules_pooling_advanced.py      39      0      0      0   100%
tests/test_torch_nn_modules_pooling_basic.py         86      0      4      0   100%
tests/test_torch_nn_modules_pooling_special.py      151     12     16      4    90%   69, 97-101, 110-112, 120-122, 355-359
---------------------------------------------------------------------------------------------
TOTAL                                               276     12     20      4    95%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_nn_modules_pooling_special.py::TestSpecialPooling::test_maxunpool1d_edge_cases
1 failed, 6 passed in 0.71s

Error: exit 1