=== Run Tests ===
F.F...s....                                                              [100%]
=================================== FAILURES ===================================
_ TestTensorStrCore.test_basic_float_tensor_formatting[dtype0-cpu-shape0-arange-4] _

self = <test_torch_tensor_str_core.TestTensorStrCore object at 0x1279726b0>
dtype = torch.float32, device = 'cpu', shape = (2, 3), values = 'arange'
precision = 4

    @pytest.mark.parametrize("dtype,device,shape,values,precision", [
        (torch.float32, 'cpu', (2, 3), 'arange', 4),
    ])
    def test_basic_float_tensor_formatting(self, dtype, device, shape, values, precision):
        """TC-01: Basic float tensor formatting with precision control."""
        # Set print options
        set_printoptions(precision=precision)
    
        # Create tensor based on values specification
        if values == 'arange':
            total_elements = math.prod(shape)
            tensor = torch.arange(total_elements, dtype=dtype, device=device).reshape(shape)
        else:
            raise ValueError(f"Unknown values specification: {values}")
    
        # Get string representation
        tensor_str = str(tensor)
    
        # Weak assertions
        # 1. Output is a string
        assert isinstance(tensor_str, str), "Tensor string representation should be a string"
    
        # 2. Contains shape information - adjust assertion based on actual format
        # Tensor string format is like: tensor([[0., 1., 2.],\n        [3., 4., 5.]])
        # We need to check the structure matches the shape
        lines = tensor_str.strip().split('\n')
    
        # Check that we have the right number of lines for the shape
        # For a 2x3 tensor, we expect at least 3 lines (tensor(...) + 2 data lines)
        expected_min_lines = shape[0] + 1 if shape[0] <= 10 else 3  # +1 for tensor(...) line
>       assert len(lines) >= min(expected_min_lines, 3), \
            f"Output should have at least {min(expected_min_lines, 3)} lines for shape {shape}"
E       AssertionError: Output should have at least 3 lines for shape (2, 3)
E       assert 2 >= 3
E        +  where 2 = len(['tensor([[0., 1., 2.],', '        [3., 4., 5.]])'])
E        +  and   3 = min(3, 3)

tests/test_torch_tensor_str_core.py:70: AssertionError
____ TestTensorStrCore.test_complex_tensor_formatting[dtype0-cpu-shape0-4] _____

self = <test_torch_tensor_str_core.TestTensorStrCore object at 0x127972fe0>
dtype = torch.complex64, device = 'cpu', shape = (2, 2), precision = 4

    @pytest.mark.parametrize("dtype,device,shape,precision", [
        (torch.complex64, 'cpu', (2, 2), 4),
    ])
    def test_complex_tensor_formatting(self, dtype, device, shape, precision):
        """TC-05: Complex tensor formatting with real and imaginary parts."""
        # Set print options
        set_printoptions(precision=precision)
    
        # Create complex tensor
        total_elements = math.prod(shape)
        # Create real and imaginary parts
        real_part = torch.arange(total_elements, dtype=torch.float32, device=device).reshape(shape)
        imag_part = torch.arange(total_elements, total_elements * 2, dtype=torch.float32, device=device).reshape(shape)
        complex_tensor = torch.complex(real_part, imag_part)
    
        # Get string representation
        tensor_str = str(complex_tensor)
    
        # Weak assertions
        # 1. Output is a string
        assert isinstance(tensor_str, str), "Tensor string representation should be a string"
    
        # 2. Contains complex indicator
        # Complex tensors should show complex numbers
        assert "j" in tensor_str or "complex" in tensor_str.lower(), \
            "Complex tensor should contain 'j' or 'complex' indicator"
    
        # 3. Real and imaginary parts separate
        # Complex numbers should show both real and imaginary parts
        # Look for pattern like (real + imag j)
        import re
        complex_pattern = r'\([-+]?\d*\.?\d+\s*[+-]\s*\d*\.?\d+\s*j\)'
        complex_matches = re.findall(complex_pattern, tensor_str)
>       assert len(complex_matches) > 0, "Should show complex numbers with real and imaginary parts"
E       AssertionError: Should show complex numbers with real and imaginary parts
E       assert 0 > 0
E        +  where 0 = len([])

tests/test_torch_tensor_str_core.py:198: AssertionError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                     Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------------
check_format.py                              0      0      0      0   100%
tests/test_torch_tensor_str_core.py         85     25     16      4    63%   53, 76-101, 150->161, 154-158, 202-212, 221
tests/test_torch_tensor_str_options.py      41      4      8      2    88%   87-89, 107
tests/test_torch_tensor_str_special.py      89      2     16      6    92%   57, 78->95, 95->100, 166->178, 170->169, 242
------------------------------------------------------------------------------------
TOTAL                                      215     31     40     12    80%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_tensor_str_core.py::TestTensorStrCore::test_basic_float_tensor_formatting[dtype0-cpu-shape0-arange-4]
FAILED tests/test_torch_tensor_str_core.py::TestTensorStrCore::test_complex_tensor_formatting[dtype0-cpu-shape0-4]
2 failed, 8 passed, 1 skipped in 0.72s

Error: exit 1