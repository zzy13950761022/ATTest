=== Run Tests ===
FF....F...F...                                                           [100%]
=================================== FAILURES ===================================
___________________ test_github_repository_standard_loading ____________________

mock_hubconf_resnet50 = <function mock_hubconf_resnet50.<locals>.create_mock_model at 0x13d7d48b0>
mock_github_download = {'download': <MagicMock name='download_url_to_file' id='5326666672'>, 'git_archive_link': <MagicMock name='_git_archive_link' id='5326655248'>, 'urlparse': <MagicMock name='urlparse' id='5326575488'>}
mock_cache_dir = PosixPath('/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmpy29ohz5h/.cache/torch/hub')
mock_import_module = <MagicMock name='import_module' id='5326629056'>

    def test_github_repository_standard_loading(
        mock_hubconf_resnet50,
        mock_github_download,
        mock_cache_dir,
        mock_import_module
    ):
        """
        Test GitHub repository standard loading (CASE_01).
    
        This test verifies that torch.hub.load can load a model from a GitHub
        repository with standard parameters.
    
        Weak assertions:
        1. returns_object: Function returns a valid object
        2. is_callable: Returned object is callable (has forward method)
        3. has_expected_attributes: Returned object has expected model attributes
        """
        # Setup cache directory structure
        repo_dir = mock_cache_dir / 'pytorch_vision_master'
        repo_dir.mkdir(parents=True, exist_ok=True)
    
        # Create a dummy hubconf.py file in cache
        hubconf_file = repo_dir / 'hubconf.py'
        hubconf_file.write_text('# Mock hubconf.py file')
    
        # Mock the cache reload function to return the repo directory
        with patch('torch.hub._get_cache_or_reload') as mock_cache_reload, \
             patch('torch.hub._check_module_exists') as mock_check_module:
    
            # Mock to return the repo directory path
            mock_cache_reload.return_value = str(repo_dir)
            mock_check_module.return_value = True
    
            # Mock trust warning
            with patch('warnings.warn') as mock_warn:
    
                # Mock the actual import of hubconf.py
                # We need to mock _import_module to return a module with resnet50
                with patch('torch.hub._import_module') as mock_hub_import:
                    # Create a mock module with resnet50 function
                    mock_module = Mock()
                    mock_module.resnet50 = mock_hubconf_resnet50
                    mock_hub_import.return_value = mock_module
    
                    # Call torch.hub.load with standard parameters
                    model = torch.hub.load(
                        repo_or_dir='pytorch/vision',
                        model='resnet50',
                        source='github',
                        trust_repo=None,
                        force_reload=False,
                        verbose=True,
                        skip_validation=False
                    )
    
                    # Weak assertion 1: returns_object
                    assert model is not None, "torch.hub.load should return a model object"
    
                    # Weak assertion 2: is_callable
                    # Check that the model has a forward method (is callable)
                    assert hasattr(model, 'forward'), "Model should have forward method"
                    assert callable(model.forward), "Model.forward should be callable"
    
                    # Weak assertion 2.1: Additional callable check - can call forward
                    test_input = torch.randn(1, 3, 224, 224)
                    output = model.forward(test_input)
                    assert output is not None, "Model.forward should return output"
                    assert isinstance(output, torch.Tensor), "Output should be a torch.Tensor"
    
                    # Weak assertion 3: has_expected_attributes
                    # Check for common model attributes
                    expected_attrs = ['eval', 'train', 'parameters', 'named_parameters',
                                    'state_dict', 'load_state_dict']
                    for attr in expected_attrs:
                        assert hasattr(model, attr), f"Model should have {attr} attribute"
    
                    # Verify mock calls
                    # Check that _import_module was called with correct parameters
                    mock_hub_import.assert_called_once()
                    call_args = mock_hub_import.call_args
    
                    # _import_module should be called with ('hubconf.py', hubconf_path)
                    assert call_args[0][0] == 'hubconf.py', f"Should import module named 'hubconf.py', got {call_args[0][0]}"
                    assert str(call_args[0][1]) == str(hubconf_file), f"Should import from {hubconf_file}, got {call_args[0][1]}"
    
                    # Check that the model factory was called
>                   assert mock_module.resnet50.called, "resnet50 factory should be called"
E                   AttributeError: 'function' object has no attribute 'called'

tests/test_torch_hub_load.py:214: AttributeError
___________________________ test_local_path_loading ____________________________

mock_local_hubconf = <function mock_local_hubconf.<locals>.create_mock_model at 0x13d7b35b0>
temp_dir = PosixPath('/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmpxlzon4e1')
mock_import_module = <MagicMock name='import_module' id='5326578224'>

    def test_local_path_loading(
        mock_local_hubconf,
        temp_dir,
        mock_import_module
    ):
        """
        Test local path loading (CASE_02).
    
        This test verifies that torch.hub.load can load a model from a local
        directory path with a valid hubconf.py file.
    
        Weak assertions:
        1. returns_object: Function returns a valid object
        2. is_callable: Returned object is callable (has forward method)
        3. has_expected_attributes: Returned object has expected model attributes
        """
        # Create a local test directory with hubconf.py
        local_repo_dir = temp_dir / 'test_hub_local'
        local_repo_dir.mkdir(parents=True, exist_ok=True)
    
        # Create hubconf.py file with simple_model entry point
        hubconf_content = '''
    import torch.nn as nn
    
    class SimpleModel(nn.Module):
        def __init__(self):
            super().__init__()
            self.linear = nn.Linear(10, 5)
    
        def forward(self, x):
            return self.linear(x)
    
    def simple_model(*args, **kwargs):
        """Factory function for simple_model."""
        return SimpleModel()
    '''
    
        hubconf_file = local_repo_dir / 'hubconf.py'
        hubconf_file.write_text(hubconf_content)
    
        # Mock trust warning
        with patch('warnings.warn') as mock_warn:
    
            # Mock the actual import of hubconf.py
            # We need to mock _import_module to return a module with simple_model
            with patch('torch.hub._import_module') as mock_hub_import:
                # Create a mock module with simple_model function
                mock_module = Mock()
                mock_module.simple_model = mock_local_hubconf
                mock_hub_import.return_value = mock_module
    
                # Call torch.hub.load with local path
                model = torch.hub.load(
                    repo_or_dir=str(local_repo_dir),
                    model='simple_model',
                    source='local',
                    trust_repo=None,
                    force_reload=False,
                    verbose=True,
                    skip_validation=False
                )
    
                # Weak assertion 1: returns_object
                assert model is not None, "torch.hub.load should return a model object"
    
                # Weak assertion 2: is_callable
                # Check that the model has a forward method (is callable)
                assert hasattr(model, 'forward'), "Model should have forward method"
                assert callable(model.forward), "Model.forward should be callable"
    
                # Weak assertion 2.1: Additional callable check - can call forward
                test_input = torch.randn(1, 10)
                output = model.forward(test_input)
                assert output is not None, "Model.forward should return output"
                assert isinstance(output, torch.Tensor), "Output should be a torch.Tensor"
    
                # Weak assertion 3: has_expected_attributes
                # Check for common model attributes
                expected_attrs = ['eval', 'train']
                for attr in expected_attrs:
                    assert hasattr(model, attr), f"Model should have {attr} attribute"
    
                # Verify the model has the expected class name
                assert model.__class__.__name__ == "SimpleModel", \
                    f"Model should be SimpleModel, got {model.__class__.__name__}"
    
                # Verify mock calls
                # Check that _import_module was called with correct parameters
                mock_hub_import.assert_called_once()
                call_args = mock_hub_import.call_args
    
                # _import_module should be called with ('hubconf.py', hubconf_file_path)
                assert call_args[0][0] == 'hubconf.py', f"Should import module named 'hubconf.py', got {call_args[0][0]}"
                assert str(call_args[0][1]) == str(hubconf_file), f"Should import from {hubconf_file}, got {call_args[0][1]}"
    
                # Check that the model factory was called
>               assert mock_module.simple_model.called, "simple_model factory should be called"
E               AttributeError: 'function' object has no attribute 'called'

tests/test_torch_hub_load.py:334: AttributeError
_____________________________ test_trust_mechanism _____________________________

mock_trust_mechanism = <function mock_trust_mechanism.<locals>.create_mock_model at 0x13d7b3be0>
mock_github_download = {'download': <MagicMock name='download_url_to_file' id='5326606480'>, 'git_archive_link': <MagicMock name='_git_archive_link' id='5326618240'>, 'urlparse': <MagicMock name='urlparse' id='5326608352'>}
mock_cache_dir = PosixPath('/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmpabao68b7/.cache/torch/hub')
mock_import_module = <MagicMock name='import_module' id='5326622480'>
mock_user_input = <MagicMock name='input' id='5326570448'>

    def test_trust_mechanism(
        mock_trust_mechanism,
        mock_github_download,
        mock_cache_dir,
        mock_import_module,
        mock_user_input
    ):
        """
        Test trust mechanism (CASE_03).
    
        This test verifies that torch.hub.load handles trust_repo=True parameter
        correctly, updating the trust list without user prompts.
    
        Weak assertions:
        1. returns_object: Function returns a valid object
        2. trust_list_updated: Trust list is updated after loading
        3. no_user_prompt: No user input is requested when trust_repo=True
        """
        # Setup cache directory structure
        repo_dir = mock_cache_dir / 'test_trust_repo_master'
        repo_dir.mkdir(parents=True, exist_ok=True)
    
        # Create a dummy hubconf.py file in cache
        hubconf_file = repo_dir / 'hubconf.py'
        hubconf_file.write_text('# Mock hubconf.py file for trust testing')
    
        # Mock the trust repo check and addition
        with patch('torch.hub._get_cache_or_reload') as mock_cache_reload, \
             patch('torch.hub._check_module_exists') as mock_check_module:
    
            # Mock cache reload to return the repo directory
            mock_cache_reload.return_value = str(repo_dir)
            mock_check_module.return_value = True
    
            # Mock the trust warning mechanism
            with patch('warnings.warn') as mock_warn:
    
                # Mock the actual import of hubconf.py
                # We need to mock _import_module to return a module with trust_model
                with patch('torch.hub._import_module') as mock_hub_import:
                    # Create a mock module with trust_model function
                    mock_module = Mock()
                    mock_module.trust_model = mock_trust_mechanism
                    mock_hub_import.return_value = mock_module
    
                    # Call torch.hub.load with trust_repo=True
                    model = torch.hub.load(
                        repo_or_dir='test/trust_repo',
                        model='trust_model',
                        source='github',
                        trust_repo=True,  # Explicitly trust the repo
                        force_reload=False,
                        verbose=False,  # Silent mode for trust test
                        skip_validation=False
                    )
    
                    # Weak assertion 1: returns_object
                    assert model is not None, "torch.hub.load should return a model object"
    
                    # Weak assertion 2: trust_list_updated
                    # When trust_repo=True, torch.hub should not show warnings about trust_repo
                    # Check that no warning was issued about trust_repo=None
                    trust_warning_found = False
                    for call_args in mock_warn.call_args_list:
                        if 'trust_repo' in str(call_args) and 'None' in str(call_args):
                            trust_warning_found = True
                            break
                    assert not trust_warning_found, "Should not warn about trust_repo=None when trust_repo=True"
    
                    # Weak assertion 3: no_user_prompt
                    # Verify that input() was NOT called (no user interaction needed)
                    mock_user_input.assert_not_called()
    
                    # Additional weak assertions from common pattern
                    # Check that the model has a forward method (is callable)
                    assert hasattr(model, 'forward'), "Model should have forward method"
                    assert callable(model.forward), "Model.forward should be callable"
    
                    # Test forward call
                    test_input = torch.randn(1, 5)
                    output = model.forward(test_input)
                    assert output is not None, "Model.forward should return output"
                    assert isinstance(output, torch.Tensor), "Output should be a torch.Tensor"
    
                    # Check for common model attributes
                    expected_attrs = ['eval', 'train']
                    for attr in expected_attrs:
                        assert hasattr(model, attr), f"Model should have {attr} attribute"
    
                    # Verify the model has the expected class name
                    assert model.__class__.__name__ == "TrustModel", \
                        f"Model should be TrustModel, got {model.__class__.__name__}"
    
                    # Verify mock calls
                    mock_hub_import.assert_called_once()
                    call_args = mock_hub_import.call_args
    
                    # _import_module should be called with ('hubconf.py', hubconf_path)
                    assert call_args[0][0] == 'hubconf.py', f"Should import module named 'hubconf.py', got {call_args[0][0]}"
                    assert str(call_args[0][1]) == str(hubconf_file), f"Should import from {hubconf_file}, got {call_args[0][1]}"
    
>                   assert mock_module.trust_model.called, "trust_model factory should be called"
E                   AttributeError: 'function' object has no attribute 'called'

tests/test_torch_hub_trust.py:203: AttributeError
________________________ test_invalid_trust_repo_value _________________________

    def test_invalid_trust_repo_value():
        """Test that invalid trust_repo value raises appropriate error."""
        # Mock network requests to avoid actual HTTP calls
        with patch('torch.hub.urlopen') as mock_urlopen, \
             patch('torch.hub._read_url') as mock_read_url:
    
            # Mock successful API response for repo validation
            mock_response = Mock()
            mock_response.read.return_value = b'[{"name": "main"}]'
            mock_response.headers.get_content_charset.return_value = 'utf-8'
            mock_urlopen.return_value.__enter__.return_value = mock_response
    
            # Mock _read_url for API calls
            mock_read_url.return_value = '[{"name": "main"}]'
    
            with pytest.raises((ValueError, TypeError)):
                # trust_repo should be bool, "check", or None
>               torch.hub.load(
                    repo_or_dir='test/repo',
                    model='test_model',
                    source='github',
                    trust_repo='invalid_value'  # Not a valid value
                )

tests/test_torch_hub_trust.py:271: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:539: in load
    repo_or_dir = _get_cache_or_reload(repo_or_dir, force_reload, trust_repo, "load",
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:230: in _get_cache_or_reload
    with zipfile.ZipFile(cached_file) as cached_zipfile:
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/zipfile.py:1288: in __init__
    self._RealGetContents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <zipfile.ZipFile [closed]>

    def _RealGetContents(self):
        """Read in the table of contents for the ZIP file."""
        fp = self.fp
        try:
            endrec = _EndRecData(fp)
        except OSError:
            raise BadZipFile("File is not a zip file")
        if not endrec:
>           raise BadZipFile("File is not a zip file")
E           zipfile.BadZipFile: File is not a zip file

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/zipfile.py:1355: BadZipFile
----------------------------- Captured stderr call -----------------------------
Downloading: "https://github.com/test/repo/zipball/main" to /Users/zzf1sh/.cache/torch/hub/main.zip
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                            Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------
tests/test_torch_hub_load.py      203     48     16      1    74%   115-121, 217-234, 337-349, 365-378, 383-394, 470-471
tests/test_torch_hub_trust.py     148     11     14      2    91%   166-168, 206-217, 350-351
---------------------------------------------------------------------------
TOTAL                             351     59     30      3    81%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_hub_load.py::test_github_repository_standard_loading
FAILED tests/test_torch_hub_load.py::test_local_path_loading - AttributeError...
FAILED tests/test_torch_hub_trust.py::test_trust_mechanism - AttributeError: ...
FAILED tests/test_torch_hub_trust.py::test_invalid_trust_repo_value - zipfile...
4 failed, 10 passed in 0.63s

Error: exit 1