=== Run Tests ===
FF...FF...F...                                                           [100%]
=================================== FAILURES ===================================
___________________ test_github_repository_standard_loading ____________________

mock_hubconf_resnet50 = <function mock_hubconf_resnet50.<locals>.create_mock_model at 0x12e1ec5e0>
mock_github_download = {'download': <MagicMock name='download_url_to_file' id='4367240448'>, 'git_archive_link': <MagicMock name='_git_archive_link' id='5068702192'>, 'urlparse': <MagicMock name='urlparse' id='5068621328'>}
mock_cache_dir = PosixPath('/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmpp9u89ju5/.cache/torch/hub')
mock_import_module = <MagicMock name='import_module' id='5068679312'>

    def test_github_repository_standard_loading(
        mock_hubconf_resnet50,
        mock_github_download,
        mock_cache_dir,
        mock_import_module
    ):
        """
        Test GitHub repository standard loading (CASE_01).
    
        This test verifies that torch.hub.load can load a model from a GitHub
        repository with standard parameters.
    
        Weak assertions:
        1. returns_object: Function returns a valid object
        2. is_callable: Returned object is callable (has forward method)
        3. has_expected_attributes: Returned object has expected model attributes
        """
        # Setup mock import module to return our mock hubconf
        mock_module = Mock()
        mock_module.resnet50 = mock_hubconf_resnet50
        mock_import_module.return_value = mock_module
    
        # Setup cache directory structure
        repo_dir = mock_cache_dir / 'pytorch_vision_master'
        repo_dir.mkdir(parents=True, exist_ok=True)
    
        # Create a dummy hubconf.py file in cache
        hubconf_file = repo_dir / 'hubconf.py'
        hubconf_file.write_text('# Mock hubconf.py file')
    
        # Mock the cache reload function to return the repo directory
        with patch('torch.hub._get_cache_or_reload') as mock_cache_reload, \
             patch('torch.hub._check_module_exists') as mock_check_module:
    
            # Mock to return the repo directory path
            mock_cache_reload.return_value = str(repo_dir)
            mock_check_module.return_value = True
    
            # Mock trust warning
            with patch('warnings.warn') as mock_warn:
    
                # Call torch.hub.load with standard parameters
>               model = torch.hub.load(
                    repo_or_dir='pytorch/vision',
                    model='resnet50',
                    source='github',
                    trust_repo=None,
                    force_reload=False,
                    verbose=True,
                    skip_validation=False
                )

tests/test_torch_hub_load.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:542: in load
    model = _load_local(repo_or_dir, model, *args, **kwargs)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:571: in _load_local
    entry = _load_entry_from_hubconf(hub_module, model)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

m = <module 'hubconf.py' from '/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmpp9u89ju5/.cache/torch/hub/pytorch_vision_master/hubconf.py'>
model = 'resnet50'

    def _load_entry_from_hubconf(m, model):
        if not isinstance(model, str):
            raise ValueError('Invalid input: model should be a string of function name')
    
        # Note that if a missing dependency is imported at top level of hubconf, it will
        # throw before this function. It's a chicken and egg situation where we have to
        # load hubconf to know what're the dependencies, but to import hubconf it requires
        # a missing package. This is fine, Python will throw proper error message for users.
        _check_dependencies(m)
    
        func = _load_attr_from_module(m, model)
    
        if func is None or not callable(func):
>           raise RuntimeError('Cannot find callable {} in hubconf'.format(model))
E           RuntimeError: Cannot find callable resnet50 in hubconf

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:321: RuntimeError
___________________________ test_local_path_loading ____________________________

mock_local_hubconf = <function mock_local_hubconf.<locals>.create_mock_model at 0x12e1b7eb0>
temp_dir = PosixPath('/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmp543lik_6')
mock_import_module = <MagicMock name='import_module' id='5068629008'>

    def test_local_path_loading(
        mock_local_hubconf,
        temp_dir,
        mock_import_module
    ):
        """
        Test local path loading (CASE_02).
    
        This test verifies that torch.hub.load can load a model from a local
        directory path with a valid hubconf.py file.
    
        Weak assertions:
        1. returns_object: Function returns a valid object
        2. is_callable: Returned object is callable (has forward method)
        3. has_expected_attributes: Returned object has expected model attributes
        """
        # Create a local test directory with hubconf.py
        local_repo_dir = temp_dir / 'test_hub_local'
        local_repo_dir.mkdir(parents=True, exist_ok=True)
    
        # Create hubconf.py file with simple_model entry point
        hubconf_content = '''
    import torch.nn as nn
    
    class SimpleModel(nn.Module):
        def __init__(self):
            super().__init__()
            self.linear = nn.Linear(10, 5)
    
        def forward(self, x):
            return self.linear(x)
    
    def simple_model(*args, **kwargs):
        """Factory function for simple_model."""
        return SimpleModel()
    '''
    
        hubconf_file = local_repo_dir / 'hubconf.py'
        hubconf_file.write_text(hubconf_content)
    
        # Setup mock import module to return our mock hubconf
        mock_module = Mock()
        mock_module.simple_model = mock_local_hubconf
    
        # Mock _import_module instead of importlib.import_module
        # because torch.hub uses its own _import_module for local paths
        with patch('torch.hub._import_module') as mock_hub_import:
            mock_hub_import.return_value = mock_module
    
            # Mock trust warning
            with patch('warnings.warn') as mock_warn:
    
                # Call torch.hub.load with local path
                model = torch.hub.load(
                    repo_or_dir=str(local_repo_dir),
                    model='simple_model',
                    source='local',
                    trust_repo=None,
                    force_reload=False,
                    verbose=True,
                    skip_validation=False
                )
    
                # Weak assertion 1: returns_object
                assert model is not None, "torch.hub.load should return a model object"
    
                # Weak assertion 2: is_callable
                # Check that the model has a forward method (is callable)
                assert hasattr(model, 'forward'), "Model should have forward method"
                assert callable(model.forward), "Model.forward should be callable"
    
                # Weak assertion 2.1: Additional callable check - can call forward
                test_input = torch.randn(1, 10)
                output = model.forward(test_input)
                assert output is not None, "Model.forward should return output"
                assert isinstance(output, torch.Tensor), "Output should be a torch.Tensor"
    
                # Weak assertion 3: has_expected_attributes
                # Check for common model attributes
                expected_attrs = ['eval', 'train']
                for attr in expected_attrs:
                    assert hasattr(model, attr), f"Model should have {attr} attribute"
    
                # Verify the model has the expected class name
                assert model.__class__.__name__ == "SimpleModel", \
                    f"Model should be SimpleModel, got {model.__class__.__name__}"
    
                # Verify mock calls
                # Check that _import_module was called with correct path
                mock_hub_import.assert_called_once()
    
                # The module name should be 'hubconf' and path should be the hubconf.py file
                call_args = mock_hub_import.call_args
                # torch.hub._import_module expects module name and file path
                # The actual call is _import_module('hubconf', hubconf_file_path)
>               assert call_args[0][0] == 'hubconf', f"Should import module named 'hubconf', got {call_args[0][0]}"
E               AssertionError: Should import module named 'hubconf', got hubconf.py
E               assert 'hubconf.py' == 'hubconf'
E                 
E                 - hubconf
E                 + hubconf.py
E                 ?        +++

tests/test_torch_hub_load.py:325: AssertionError
______________________ test_nonexistent_model_entrypoint _______________________

    def test_nonexistent_model_entrypoint():
        """Test that non-existent model entry point raises appropriate error."""
        # Mock the entire download and import process to avoid network calls
        with patch('torch.hub._get_cache_or_reload') as mock_cache_reload, \
             patch('torch.hub._check_module_exists') as mock_check_module, \
             patch('torch.hub._import_module') as mock_import_module:
    
            # Setup mocks to simulate successful download but missing model
            mock_cache_reload.return_value = None
            mock_check_module.return_value = True
    
            # Create a mock module without the requested model
            mock_module = Mock()
            # Don't add any model entry points
            mock_import_module.return_value = mock_module
    
            with pytest.raises((AttributeError, RuntimeError)):
>               torch.hub.load(
                    repo_or_dir='test/repo',
                    model='nonexistent_model',
                    source='github'
                )

tests/test_torch_hub_load.py:448: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:542: in load
    model = _load_local(repo_or_dir, model, *args, **kwargs)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:568: in _load_local
    hubconf_path = os.path.join(hubconf_dir, MODULE_HUBCONF)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

a = None, p = ('hubconf.py',)

    def join(a, *p):
        """Join two or more pathname components, inserting '/' as needed.
        If any component is an absolute path, all previous path components
        will be discarded.  An empty last part will result in a path that
        ends with a separator."""
>       a = os.fspath(a)
E       TypeError: expected str, bytes or os.PathLike object, not NoneType

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/posixpath.py:76: TypeError
_____________________________ test_trust_mechanism _____________________________

mock_trust_mechanism = <function mock_trust_mechanism.<locals>.create_mock_model at 0x12e2da710>
mock_github_download = {'download': <MagicMock name='download_url_to_file' id='5069363792'>, 'git_archive_link': <MagicMock name='_git_archive_link' id='5069365760'>, 'urlparse': <MagicMock name='urlparse' id='5069671920'>}
mock_cache_dir = PosixPath('/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmpdloq2xo4/.cache/torch/hub')
mock_import_module = <MagicMock name='import_module' id='5069251600'>
mock_user_input = <MagicMock name='input' id='5069250976'>

    def test_trust_mechanism(
        mock_trust_mechanism,
        mock_github_download,
        mock_cache_dir,
        mock_import_module,
        mock_user_input
    ):
        """
        Test trust mechanism (CASE_03).
    
        This test verifies that torch.hub.load handles trust_repo=True parameter
        correctly, updating the trust list without user prompts.
    
        Weak assertions:
        1. returns_object: Function returns a valid object
        2. trust_list_updated: Trust list is updated after loading
        3. no_user_prompt: No user input is requested when trust_repo=True
        """
        # Setup mock import module to return our mock hubconf
        mock_module = Mock()
        mock_module.trust_model = mock_trust_mechanism
        mock_import_module.return_value = mock_module
    
        # Setup cache directory structure
        repo_dir = mock_cache_dir / 'test_trust_repo_master'
        repo_dir.mkdir(parents=True, exist_ok=True)
    
        # Create a dummy hubconf.py file in cache
        hubconf_file = repo_dir / 'hubconf.py'
        hubconf_file.write_text('# Mock hubconf.py file for trust testing')
    
        # Mock the trust repo check and addition
        # Note: torch.hub doesn't have _is_trusted_repo or _add_trusted_repo functions
        # Instead, we need to mock the internal trust mechanism
        with patch('torch.hub._get_cache_or_reload') as mock_cache_reload, \
             patch('torch.hub._check_module_exists') as mock_check_module:
    
            # Mock cache reload to return the repo directory
            mock_cache_reload.return_value = str(repo_dir)
            mock_check_module.return_value = True
    
            # Mock the trust warning mechanism
            with patch('warnings.warn') as mock_warn:
    
                # Call torch.hub.load with trust_repo=True
>               model = torch.hub.load(
                    repo_or_dir='test/trust_repo',
                    model='trust_model',
                    source='github',
                    trust_repo=True,  # Explicitly trust the repo
                    force_reload=False,
                    verbose=False,  # Silent mode for trust test
                    skip_validation=False
                )

tests/test_torch_hub_trust.py:147: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:542: in load
    model = _load_local(repo_or_dir, model, *args, **kwargs)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:571: in _load_local
    entry = _load_entry_from_hubconf(hub_module, model)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

m = <module 'hubconf.py' from '/var/folders/fc/ny_p_wjs10xfzq7xns_lfdc40000gn/T/tmpdloq2xo4/.cache/torch/hub/test_trust_repo_master/hubconf.py'>
model = 'trust_model'

    def _load_entry_from_hubconf(m, model):
        if not isinstance(model, str):
            raise ValueError('Invalid input: model should be a string of function name')
    
        # Note that if a missing dependency is imported at top level of hubconf, it will
        # throw before this function. It's a chicken and egg situation where we have to
        # load hubconf to know what're the dependencies, but to import hubconf it requires
        # a missing package. This is fine, Python will throw proper error message for users.
        _check_dependencies(m)
    
        func = _load_attr_from_module(m, model)
    
        if func is None or not callable(func):
>           raise RuntimeError('Cannot find callable {} in hubconf'.format(model))
E           RuntimeError: Cannot find callable trust_model in hubconf

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:321: RuntimeError
________________________ test_invalid_trust_repo_value _________________________

    def test_invalid_trust_repo_value():
        """Test that invalid trust_repo value raises appropriate error."""
        # Mock network requests to avoid actual HTTP calls
        with patch('torch.hub.urlopen') as mock_urlopen, \
             patch('torch.hub._read_url') as mock_read_url:
    
            # Mock successful API response for repo validation
            mock_response = Mock()
            mock_response.read.return_value = b'[{"name": "main"}]'
            mock_response.headers.get_content_charset.return_value = 'utf-8'
            mock_urlopen.return_value.__enter__.return_value = mock_response
    
            # Mock _read_url for API calls
            mock_read_url.return_value = '[{"name": "main"}]'
    
            with pytest.raises((ValueError, TypeError)):
                # trust_repo should be bool, "check", or None
>               torch.hub.load(
                    repo_or_dir='test/repo',
                    model='test_model',
                    source='github',
                    trust_repo='invalid_value'  # Not a valid value
                )

tests/test_torch_hub_trust.py:263: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:539: in load
    repo_or_dir = _get_cache_or_reload(repo_or_dir, force_reload, trust_repo, "load",
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/hub.py:230: in _get_cache_or_reload
    with zipfile.ZipFile(cached_file) as cached_zipfile:
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/zipfile.py:1288: in __init__
    self._RealGetContents()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = <zipfile.ZipFile [closed]>

    def _RealGetContents(self):
        """Read in the table of contents for the ZIP file."""
        fp = self.fp
        try:
            endrec = _EndRecData(fp)
        except OSError:
            raise BadZipFile("File is not a zip file")
        if not endrec:
>           raise BadZipFile("File is not a zip file")
E           zipfile.BadZipFile: File is not a zip file

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/zipfile.py:1355: BadZipFile
----------------------------- Captured stderr call -----------------------------
Downloading: "https://github.com/test/repo/zipball/main" to /Users/zzf1sh/.cache/torch/hub/main.zip
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                            Stmts   Miss Branch BrPart  Cover   Missing
---------------------------------------------------------------------------
tests/test_torch_hub_load.py      195     72     14      1    60%   43-52, 115-121, 181-226, 326-344, 360-373, 378-389, 457-458
tests/test_torch_hub_trust.py     141     31     12      1    75%   43-48, 158-209, 342-343
---------------------------------------------------------------------------
TOTAL                             336    103     26      2    67%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_hub_load.py::test_github_repository_standard_loading
FAILED tests/test_torch_hub_load.py::test_local_path_loading - AssertionError...
FAILED tests/test_torch_hub_load.py::test_nonexistent_model_entrypoint - Type...
FAILED tests/test_torch_hub_trust.py::test_trust_mechanism - RuntimeError: Ca...
FAILED tests/test_torch_hub_trust.py::test_invalid_trust_repo_value - zipfile...
5 failed, 9 passed in 0.65s

Error: exit 1