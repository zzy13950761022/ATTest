=== Run Tests ===
F..                                                                      [100%]
=================================== FAILURES ===================================
____________ test_pack_padded_sequence_basic[True-False-cpu-dtype0] ____________

dtype = torch.float32, device = 'cpu', batch_first = False
enforce_sorted = True

    @pytest.mark.parametrize("dtype", [torch.float32])
    @pytest.mark.parametrize("device", ["cpu"])
    @pytest.mark.parametrize("batch_first", [False])
    @pytest.mark.parametrize("enforce_sorted", [True])
    def test_pack_padded_sequence_basic(
        dtype: torch.dtype,
        device: str,
        batch_first: bool,
        enforce_sorted: bool
    ):
        """TC-01: pack_padded_sequence基本功能"""
        # Test parameters from param_matrix
        batch_size = 3
        max_len = 5
        padding_value = 0.0
        feature_dim = 3
    
        # Generate test data
        padded, lengths = generate_padded_sequence(
            batch_size=batch_size,
            max_len=max_len,
            feature_dim=feature_dim,
            dtype=dtype,
            device=device,
            batch_first=batch_first
        )
    
        # Call the function
        packed = rnn_utils.pack_padded_sequence(
            padded,
            lengths,
            batch_first=batch_first,
            enforce_sorted=enforce_sorted
        )
    
        # Weak assertions (epoch 1)
        # 1. output_type: Should return PackedSequence
        assert isinstance(packed, rnn_utils.PackedSequence), \
            f"Expected PackedSequence, got {type(packed)}"
    
        # 2. shape_consistency: data shape should be consistent
        total_elements = lengths.sum().item()
        expected_data_shape = (total_elements, feature_dim)
        assert packed.data.shape == expected_data_shape, \
            f"Expected data shape {expected_data_shape}, got {packed.data.shape}"
    
        # 3. device_match: data device should match input
        assert packed.data.device.type == device, \
            f"Expected device {device}, got {packed.data.device.type}"
    
        # 4. dtype_match: data dtype should match input
        assert packed.data.dtype == dtype, \
            f"Expected dtype {dtype}, got {packed.data.dtype}"
    
        # 5. lengths_preserved: batch_sizes should sum to total length
        assert packed.batch_sizes.sum().item() == total_elements, \
            f"batch_sizes sum {packed.batch_sizes.sum().item()} != total elements {total_elements}"
    
        # Additional weak assertions from requirements
        # sorted_indices should be present
        assert hasattr(packed, 'sorted_indices'), "PackedSequence should have sorted_indices"
        assert hasattr(packed, 'unsorted_indices'), "PackedSequence should have unsorted_indices"
    
        # sorted_indices/unsorted_indices should be torch.int64
>       assert packed.sorted_indices.dtype == torch.int64, \
            f"sorted_indices should be int64, got {packed.sorted_indices.dtype}"
E       AttributeError: 'NoneType' object has no attribute 'dtype'

tests/test_torch_nn_utils_rnn_pack_unpack.py:133: AttributeError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                           Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------------------
tests/test_torch_nn_utils_rnn_pack_unpack.py     120     25     24      5    75%   31-33, 49-54, 60, 65, 135-153, 203, 215-216, 234-235, 322-323
------------------------------------------------------------------------------------------
TOTAL                                            120     25     24      5    75%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_nn_utils_rnn_pack_unpack.py::test_pack_padded_sequence_basic[True-False-cpu-dtype0]
1 failed, 2 passed in 0.56s

Error: exit 1