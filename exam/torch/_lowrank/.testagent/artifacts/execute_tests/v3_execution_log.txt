=== Run Tests ===
FFF..FFF.....F....F                                                      [100%]
=================================== FAILURES ===================================
__________ test_svd_lowrank_basic[dtype0-cpu-shape0-2-2-None-flags0] ___________

dtype = torch.float32, device = 'cpu', shape = (5, 3), q = 2, niter = 2
M = None, flags = ['normal']

    @pytest.mark.parametrize("dtype,device,shape,q,niter,M,flags", [
        (torch.float32, 'cpu', (5, 3), 2, 2, None, ['normal']),
        # 参数扩展：更大形状测试
        (torch.float64, 'cpu', (8, 5), 3, 2, None, ['larger_shape']),
        # 参数扩展：高矩阵测试
        (torch.float32, 'cpu', (3, 7), 2, 2, None, ['tall_matrix']),
    ])
    def test_svd_lowrank_basic(dtype, device, shape, q, niter, M, flags):
        """测试 svd_lowrank 基本功能"""
        # 设置随机种子
        set_random_seed()
    
        # 创建测试矩阵
        A = create_test_matrix(shape, dtype=dtype, device=device, flags=flags)
    
        # 调用目标函数
        U, S, V = svd_lowrank(A, q=q, niter=niter, M=M)
    
        # weak 断言：基本属性
        m, n = shape
        assert_tensor_properties(U, expected_shape=(m, q), expected_dtype=dtype, name="U")
        assert_tensor_properties(S, expected_shape=(q,), expected_dtype=dtype, name="S")
        assert_tensor_properties(V, expected_shape=(n, q), expected_dtype=dtype, name="V")
    
        # weak 断言：基本属性检查
        # 1. 奇异值应为非负
        assert (S >= 0).all(), "奇异值应非负"
    
        # 2. 奇异值应为降序排列（近似）
        if q > 1:
            # 检查是否大致降序（允许小的数值误差）
            diff = S[:-1] - S[1:]
            assert (diff >= -1e-6).all(), "奇异值应大致降序排列"
    
        # 3. 重构误差检查（弱断言版本）
        # 计算低秩近似
        A_approx = U @ torch.diag(S) @ V.T
    
        # 检查重构矩阵形状
        assert A_approx.shape == A.shape, f"重构矩阵形状错误: 期望 {A.shape}, 实际 {A_approx.shape}"
    
        # 检查重构误差数量级（弱断言，只检查不是特别大）
        error = torch.norm(A - A_approx)
        norm_A = torch.norm(A)
        if norm_A > 0:
            rel_error = error / norm_A
            # 弱断言：相对误差应小于 0.1（宽松条件）
>           assert rel_error < 0.1, f"重构相对误差过大: {rel_error.item()}"
E           AssertionError: 重构相对误差过大: 0.1372620314359665
E           assert tensor(0.1373) < 0.1

tests/test_torch_lowrank_g1.py:97: AssertionError
__________ test_svd_lowrank_basic[dtype1-cpu-shape1-3-2-None-flags1] ___________

dtype = torch.float64, device = 'cpu', shape = (8, 5), q = 3, niter = 2
M = None, flags = ['larger_shape']

    @pytest.mark.parametrize("dtype,device,shape,q,niter,M,flags", [
        (torch.float32, 'cpu', (5, 3), 2, 2, None, ['normal']),
        # 参数扩展：更大形状测试
        (torch.float64, 'cpu', (8, 5), 3, 2, None, ['larger_shape']),
        # 参数扩展：高矩阵测试
        (torch.float32, 'cpu', (3, 7), 2, 2, None, ['tall_matrix']),
    ])
    def test_svd_lowrank_basic(dtype, device, shape, q, niter, M, flags):
        """测试 svd_lowrank 基本功能"""
        # 设置随机种子
        set_random_seed()
    
        # 创建测试矩阵
        A = create_test_matrix(shape, dtype=dtype, device=device, flags=flags)
    
        # 调用目标函数
        U, S, V = svd_lowrank(A, q=q, niter=niter, M=M)
    
        # weak 断言：基本属性
        m, n = shape
        assert_tensor_properties(U, expected_shape=(m, q), expected_dtype=dtype, name="U")
        assert_tensor_properties(S, expected_shape=(q,), expected_dtype=dtype, name="S")
        assert_tensor_properties(V, expected_shape=(n, q), expected_dtype=dtype, name="V")
    
        # weak 断言：基本属性检查
        # 1. 奇异值应为非负
        assert (S >= 0).all(), "奇异值应非负"
    
        # 2. 奇异值应为降序排列（近似）
        if q > 1:
            # 检查是否大致降序（允许小的数值误差）
            diff = S[:-1] - S[1:]
            assert (diff >= -1e-6).all(), "奇异值应大致降序排列"
    
        # 3. 重构误差检查（弱断言版本）
        # 计算低秩近似
        A_approx = U @ torch.diag(S) @ V.T
    
        # 检查重构矩阵形状
        assert A_approx.shape == A.shape, f"重构矩阵形状错误: 期望 {A.shape}, 实际 {A_approx.shape}"
    
        # 检查重构误差数量级（弱断言，只检查不是特别大）
        error = torch.norm(A - A_approx)
        norm_A = torch.norm(A)
        if norm_A > 0:
            rel_error = error / norm_A
            # 弱断言：相对误差应小于 0.1（宽松条件）
>           assert rel_error < 0.1, f"重构相对误差过大: {rel_error.item()}"
E           AssertionError: 重构相对误差过大: 0.4155800182541249
E           assert tensor(0.4156, dtype=torch.float64) < 0.1

tests/test_torch_lowrank_g1.py:97: AssertionError
__________ test_svd_lowrank_basic[dtype2-cpu-shape2-2-2-None-flags2] ___________

dtype = torch.float32, device = 'cpu', shape = (3, 7), q = 2, niter = 2
M = None, flags = ['tall_matrix']

    @pytest.mark.parametrize("dtype,device,shape,q,niter,M,flags", [
        (torch.float32, 'cpu', (5, 3), 2, 2, None, ['normal']),
        # 参数扩展：更大形状测试
        (torch.float64, 'cpu', (8, 5), 3, 2, None, ['larger_shape']),
        # 参数扩展：高矩阵测试
        (torch.float32, 'cpu', (3, 7), 2, 2, None, ['tall_matrix']),
    ])
    def test_svd_lowrank_basic(dtype, device, shape, q, niter, M, flags):
        """测试 svd_lowrank 基本功能"""
        # 设置随机种子
        set_random_seed()
    
        # 创建测试矩阵
        A = create_test_matrix(shape, dtype=dtype, device=device, flags=flags)
    
        # 调用目标函数
        U, S, V = svd_lowrank(A, q=q, niter=niter, M=M)
    
        # weak 断言：基本属性
        m, n = shape
        assert_tensor_properties(U, expected_shape=(m, q), expected_dtype=dtype, name="U")
        assert_tensor_properties(S, expected_shape=(q,), expected_dtype=dtype, name="S")
        assert_tensor_properties(V, expected_shape=(n, q), expected_dtype=dtype, name="V")
    
        # weak 断言：基本属性检查
        # 1. 奇异值应为非负
        assert (S >= 0).all(), "奇异值应非负"
    
        # 2. 奇异值应为降序排列（近似）
        if q > 1:
            # 检查是否大致降序（允许小的数值误差）
            diff = S[:-1] - S[1:]
            assert (diff >= -1e-6).all(), "奇异值应大致降序排列"
    
        # 3. 重构误差检查（弱断言版本）
        # 计算低秩近似
        A_approx = U @ torch.diag(S) @ V.T
    
        # 检查重构矩阵形状
        assert A_approx.shape == A.shape, f"重构矩阵形状错误: 期望 {A.shape}, 实际 {A_approx.shape}"
    
        # 检查重构误差数量级（弱断言，只检查不是特别大）
        error = torch.norm(A - A_approx)
        norm_A = torch.norm(A)
        if norm_A > 0:
            rel_error = error / norm_A
            # 弱断言：相对误差应小于 0.1（宽松条件）
>           assert rel_error < 0.1, f"重构相对误差过大: {rel_error.item()}"
E           AssertionError: 重构相对误差过大: 0.31134098768234253
E           assert tensor(0.3113) < 0.1

tests/test_torch_lowrank_g1.py:97: AssertionError
____ test_svd_lowrank_randomness_control[dtype0-cpu-shape0-2-2-None-flags0] ____

dtype = torch.float32, device = 'cpu', shape = (5, 3), q = 2, niter = 2
M = None, flags = ['random_seed']

    @pytest.mark.parametrize("dtype,device,shape,q,niter,M,flags", [
        (torch.float32, 'cpu', (5, 3), 2, 2, None, ['random_seed']),
    ])
    def test_svd_lowrank_randomness_control(dtype, device, shape, q, niter, M, flags):
        """测试 svd_lowrank 随机性控制"""
        m, n = shape
    
        # 测试1：相同种子应产生相同结果
        torch.manual_seed(123)
        A1 = torch.randn(m, n, dtype=dtype, device=device)
        U1, S1, V1 = svd_lowrank(A1, q=q, niter=niter, M=M)
    
        torch.manual_seed(123)  # 重置种子
        A2 = torch.randn(m, n, dtype=dtype, device=device)
        U2, S2, V2 = svd_lowrank(A2, q=q, niter=niter, M=M)
    
        # weak 断言：可重复性
        # 检查输入矩阵是否相同（由于相同种子）
        assert torch.allclose(A1, A2, rtol=1e-6), "相同种子应产生相同输入矩阵"
    
        # 检查输出是否相同（弱断言：相对误差小于 1e-5）
        assert torch.allclose(U1, U2, rtol=1e-5), "相同种子应产生相同的 U"
        assert torch.allclose(S1, S2, rtol=1e-5), "相同种子应产生相同的 S"
        assert torch.allclose(V1, V2, rtol=1e-5), "相同种子应产生相同的 V"
    
        # 测试2：不同种子应产生不同结果（统计上）
        torch.manual_seed(456)
        A3 = torch.randn(m, n, dtype=dtype, device=device)
        U3, S3, V3 = svd_lowrank(A3, q=q, niter=niter, M=M)
    
        # 检查不同种子产生的输入是否不同
        assert not torch.allclose(A1, A3, rtol=1e-6), "不同种子应产生不同输入矩阵"
    
        # 检查输出是否不同（弱断言：至少有一个显著不同）
        # 计算差异
        U_diff = torch.norm(U1 - U3)
        S_diff = torch.norm(S1 - S3)
        V_diff = torch.norm(V1 - V3)
    
        # 弱断言：至少有一个差异大于阈值
        threshold = 1e-3
        assert (U_diff > threshold or S_diff > threshold or V_diff > threshold), \
            "不同种子应产生统计上不同的结果"
    
        # weak 断言：基本属性检查（对两组结果都检查）
        for U, S, V in [(U1, S1, V1), (U3, S3, V3)]:
            assert_tensor_properties(U, expected_shape=(m, q), expected_dtype=dtype, name="U")
            assert_tensor_properties(S, expected_shape=(q,), expected_dtype=dtype, name="S")
            assert_tensor_properties(V, expected_shape=(n, q), expected_dtype=dtype, name="V")
    
            # 奇异值应为非负
            assert (S >= 0).all(), "奇异值应非负"
    
            # 重构误差检查（弱断言）
            A_approx = U @ torch.diag(S) @ V.T
            error = torch.norm(A1 - A_approx) if U is U1 else torch.norm(A3 - A_approx)
            norm_A = torch.norm(A1) if U is U1 else torch.norm(A3)
            if norm_A > 0:
                rel_error = error / norm_A
                # 弱断言：相对误差应小于 0.1
>               assert rel_error < 0.1, f"重构相对误差过大: {rel_error.item()}"
E               AssertionError: 重构相对误差过大: 0.32828664779663086
E               assert tensor(0.3283) < 0.1

tests/test_torch_lowrank_g1.py:247: AssertionError
__________________________ test_svd_lowrank_invalid_q __________________________

    def test_svd_lowrank_invalid_q():
        """测试无效 q 参数"""
        set_random_seed()
        A = torch.randn(5, 3, dtype=torch.float32)
    
        # q > min(m,n) 应引发 ValueError
        with pytest.raises(ValueError, match="q must be satisfying"):
>           svd_lowrank(A, q=10)  # q=10 > min(5,3)=3

tests/test_torch_lowrank_g1.py:286: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lowrank.py:137: in svd_lowrank
    return _svd_lowrank(A, q=q, niter=niter, M=M)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

A = tensor([[ 0.3367,  0.1288,  0.2345],
        [ 0.2303, -1.1229, -0.1863],
        [ 2.2082, -0.6380,  0.4617],
        [ 0.2674,  0.5349,  0.8094],
        [ 1.1103, -1.6898, -0.9890]])
q = 10, niter = 2, M = None

    def _svd_lowrank(
        A: Tensor,
        q: Optional[int] = 6,
        niter: Optional[int] = 2,
        M: Optional[Tensor] = None,
    ) -> Tuple[Tensor, Tensor, Tensor]:
        q = 6 if q is None else q
        m, n = A.shape[-2:]
        matmul = _utils.matmul
        if M is None:
            M_t = None
        else:
            M_t = _utils.transpose(M)
        A_t = _utils.transpose(A)
    
        # Algorithm 5.1 in Halko et al 2009, slightly modified to reduce
        # the number conjugate and transpose operations
        if m < n or n > q:
            # computing the SVD approximation of a transpose in
            # order to keep B shape minimal (the m < n case) or the V
            # shape small (the n > q case)
            Q = get_approximate_basis(A_t, q, niter=niter, M=M_t)
            Q_c = _utils.conjugate(Q)
            if M is None:
                B_t = matmul(A, Q_c)
            else:
                B_t = matmul(A, Q_c) - matmul(M, Q_c)
            assert B_t.shape[-2] == m, (B_t.shape, m)
            assert B_t.shape[-1] == q, (B_t.shape, q)
            assert B_t.shape[-1] <= B_t.shape[-2], B_t.shape
            U, S, Vh = torch.linalg.svd(B_t, full_matrices=False)
            V = Vh.mH
            V = Q.matmul(V)
        else:
            Q = get_approximate_basis(A, q, niter=niter, M=M)
            Q_c = _utils.conjugate(Q)
            if M is None:
                B = matmul(A_t, Q_c)
            else:
                B = matmul(A_t, Q_c) - matmul(M_t, Q_c)
            B_t = _utils.transpose(B)
>           assert B_t.shape[-2] == q, (B_t.shape, q)
E           AssertionError: (torch.Size([3, 3]), 10)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lowrank.py:181: AssertionError
________________________ test_svd_lowrank_invalid_niter ________________________

    def test_svd_lowrank_invalid_niter():
        """测试无效 niter 参数"""
        set_random_seed()
        A = torch.randn(5, 3, dtype=torch.float32)
    
        # niter < 0 应引发 ValueError
        with pytest.raises(ValueError, match="niter must be non-negative"):
>           svd_lowrank(A, niter=-1)

tests/test_torch_lowrank_g1.py:299: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lowrank.py:137: in svd_lowrank
    return _svd_lowrank(A, q=q, niter=niter, M=M)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

A = tensor([[ 0.3367,  0.1288,  0.2345],
        [ 0.2303, -1.1229, -0.1863],
        [ 2.2082, -0.6380,  0.4617],
        [ 0.2674,  0.5349,  0.8094],
        [ 1.1103, -1.6898, -0.9890]])
q = 6, niter = -1, M = None

    def _svd_lowrank(
        A: Tensor,
        q: Optional[int] = 6,
        niter: Optional[int] = 2,
        M: Optional[Tensor] = None,
    ) -> Tuple[Tensor, Tensor, Tensor]:
        q = 6 if q is None else q
        m, n = A.shape[-2:]
        matmul = _utils.matmul
        if M is None:
            M_t = None
        else:
            M_t = _utils.transpose(M)
        A_t = _utils.transpose(A)
    
        # Algorithm 5.1 in Halko et al 2009, slightly modified to reduce
        # the number conjugate and transpose operations
        if m < n or n > q:
            # computing the SVD approximation of a transpose in
            # order to keep B shape minimal (the m < n case) or the V
            # shape small (the n > q case)
            Q = get_approximate_basis(A_t, q, niter=niter, M=M_t)
            Q_c = _utils.conjugate(Q)
            if M is None:
                B_t = matmul(A, Q_c)
            else:
                B_t = matmul(A, Q_c) - matmul(M, Q_c)
            assert B_t.shape[-2] == m, (B_t.shape, m)
            assert B_t.shape[-1] == q, (B_t.shape, q)
            assert B_t.shape[-1] <= B_t.shape[-2], B_t.shape
            U, S, Vh = torch.linalg.svd(B_t, full_matrices=False)
            V = Vh.mH
            V = Q.matmul(V)
        else:
            Q = get_approximate_basis(A, q, niter=niter, M=M)
            Q_c = _utils.conjugate(Q)
            if M is None:
                B = matmul(A_t, Q_c)
            else:
                B = matmul(A_t, Q_c) - matmul(M_t, Q_c)
            B_t = _utils.transpose(B)
>           assert B_t.shape[-2] == q, (B_t.shape, q)
E           AssertionError: (torch.Size([5, 3]), 6)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lowrank.py:181: AssertionError
_____________________ test_get_approximate_basis_invalid_q _____________________

    def test_get_approximate_basis_invalid_q():
        """测试 get_approximate_basis 无效 q 参数"""
        set_random_seed()
        A = torch.randn(6, 4, dtype=torch.float32)
    
        # 测试 q > min(m,n) 的情况
        # 注意：根据实际实现，get_approximate_basis 可能不会验证 q 参数
        # 但 torch.randn 会接受 q > n，然后 QR 分解会失败或产生奇怪结果
        # 我们测试函数是否能够处理这种情况而不崩溃
        try:
            # q=10 > min(6,4)=4
            Q = get_approximate_basis(A, q=10, niter=2)
            # 如果函数没有验证 q，它会继续执行
            # 检查返回的张量形状
>           assert Q.shape == (6, 10), f"当 q=10 时，期望形状 (6, 10)，实际得到 {Q.shape}"
E           AssertionError: 当 q=10 时，期望形状 (6, 10)，实际得到 torch.Size([6, 4])
E           assert torch.Size([6, 4]) == (6, 10)
E             
E             At index 1 diff: 4 != 10
E             Use -v to get more diff

tests/test_torch_lowrank_g2.py:293: AssertionError
_______________________ test_svd_lowrank_invalid_params ________________________

    def test_svd_lowrank_invalid_params():
        """测试 svd_lowrank 无效参数"""
        set_random_seed()
        A = torch.randn(5, 3, dtype=torch.float32)
    
        # 测试 q 参数边界
        # svd_lowrank 有默认 q=6，但我们的矩阵只有 min(5,3)=3
        # 函数应该能够处理 q > min(m,n) 的情况
        try:
>           U, S, V = svd_lowrank(A, q=10)  # q=10 > min(5,3)=3

tests/test_torch_lowrank_g2.py:422: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lowrank.py:137: in svd_lowrank
    return _svd_lowrank(A, q=q, niter=niter, M=M)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

A = tensor([[ 0.3367,  0.1288,  0.2345],
        [ 0.2303, -1.1229, -0.1863],
        [ 2.2082, -0.6380,  0.4617],
        [ 0.2674,  0.5349,  0.8094],
        [ 1.1103, -1.6898, -0.9890]])
q = 10, niter = 2, M = None

    def _svd_lowrank(
        A: Tensor,
        q: Optional[int] = 6,
        niter: Optional[int] = 2,
        M: Optional[Tensor] = None,
    ) -> Tuple[Tensor, Tensor, Tensor]:
        q = 6 if q is None else q
        m, n = A.shape[-2:]
        matmul = _utils.matmul
        if M is None:
            M_t = None
        else:
            M_t = _utils.transpose(M)
        A_t = _utils.transpose(A)
    
        # Algorithm 5.1 in Halko et al 2009, slightly modified to reduce
        # the number conjugate and transpose operations
        if m < n or n > q:
            # computing the SVD approximation of a transpose in
            # order to keep B shape minimal (the m < n case) or the V
            # shape small (the n > q case)
            Q = get_approximate_basis(A_t, q, niter=niter, M=M_t)
            Q_c = _utils.conjugate(Q)
            if M is None:
                B_t = matmul(A, Q_c)
            else:
                B_t = matmul(A, Q_c) - matmul(M, Q_c)
            assert B_t.shape[-2] == m, (B_t.shape, m)
            assert B_t.shape[-1] == q, (B_t.shape, q)
            assert B_t.shape[-1] <= B_t.shape[-2], B_t.shape
            U, S, Vh = torch.linalg.svd(B_t, full_matrices=False)
            V = Vh.mH
            V = Q.matmul(V)
        else:
            Q = get_approximate_basis(A, q, niter=niter, M=M)
            Q_c = _utils.conjugate(Q)
            if M is None:
                B = matmul(A_t, Q_c)
            else:
                B = matmul(A_t, Q_c) - matmul(M_t, Q_c)
            B_t = _utils.transpose(B)
>           assert B_t.shape[-2] == q, (B_t.shape, q)
E           AssertionError: (torch.Size([3, 3]), 10)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lowrank.py:181: AssertionError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                             Stmts   Miss Branch BrPart  Cover   Missing
----------------------------------------------------------------------------
tests/test_torch_lowrank_g1.py     152     26     28     10    80%   15, 27, 33-35, 42->44, 44->exit, 79->86, 101-112, 156->163, 244->232, 251-274, 289-290
tests/test_torch_lowrank_g2.py     214     38     36     10    77%   15, 34, 41->43, 43->exit, 94->100, 135->142, 154->161, 239->246, 259-269, 295-297, 302, 309-324, 339-346, 424-427, 432, 437-450
----------------------------------------------------------------------------
TOTAL                              366     64     64     20    78%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_lowrank_g1.py::test_svd_lowrank_basic[dtype0-cpu-shape0-2-2-None-flags0]
FAILED tests/test_torch_lowrank_g1.py::test_svd_lowrank_basic[dtype1-cpu-shape1-3-2-None-flags1]
FAILED tests/test_torch_lowrank_g1.py::test_svd_lowrank_basic[dtype2-cpu-shape2-2-2-None-flags2]
FAILED tests/test_torch_lowrank_g1.py::test_svd_lowrank_randomness_control[dtype0-cpu-shape0-2-2-None-flags0]
FAILED tests/test_torch_lowrank_g1.py::test_svd_lowrank_invalid_q - Assertion...
FAILED tests/test_torch_lowrank_g1.py::test_svd_lowrank_invalid_niter - Asser...
FAILED tests/test_torch_lowrank_g2.py::test_get_approximate_basis_invalid_q
FAILED tests/test_torch_lowrank_g2.py::test_svd_lowrank_invalid_params - Asse...
8 failed, 11 passed in 0.90s

Error: exit 1