=== Run Tests ===
....ssssss.sss..............s...............xFF.x.........               [100%]
=================================== FAILURES ===================================
__________________________ test_parameter_exclusivity __________________________

    def test_parameter_exclusivity():
        """
        Test that size and scale_factor parameters are mutually exclusive.
    
        Verifies that:
        1. ValueError is raised when both size and scale_factor are specified
        2. Error message contains appropriate information
    
        Note: PyTorch's F.interpolate allows both size and scale_factor to be specified,
        but it uses size if both are provided. The error checking happens in F.interpolate.
        """
        # Create input tensor
        input_shape = (1, 3, 4, 4)
        x = create_test_tensor(input_shape, dtype=torch.float32, device='cpu')
    
        # Test with Upsample class - PyTorch allows both to be specified
        # but uses size if both are provided
        upsample = nn.Upsample(
            size=[8, 8],
            scale_factor=2.0,
            mode='nearest'
        )
    
        # Forward pass should work - PyTorch uses size when both are specified
>       output = upsample(x)

tests/test_torch_nn_modules_upsampling_g3.py:79: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/modules/module.py:1190: in _call_impl
    return forward_call(*input, **kwargs)
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/modules/upsampling.py:156: in forward
    return F.interpolate(input, self.size, self.scale_factor, self.mode, self.align_corners,
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

input = tensor([[[[0.0000, 0.0208, 0.0417, 0.0625],
          [0.0833, 0.1042, 0.1250, 0.1458],
          [0.1667, 0.1875, 0.2...00, 0.7708, 0.7917, 0.8125],
          [0.8333, 0.8542, 0.8750, 0.8958],
          [0.9167, 0.9375, 0.9583, 0.9792]]]])
size = [8, 8], scale_factor = 2.0, mode = 'nearest', align_corners = None
recompute_scale_factor = None, antialias = False

    def interpolate(input: Tensor, size: Optional[int] = None, scale_factor: Optional[List[float]] = None, mode: str = 'nearest', align_corners: Optional[bool] = None, recompute_scale_factor: Optional[bool] = None, antialias: bool = False) -> Tensor:  # noqa: F811
        r"""Down/up samples the input to either the given :attr:`size` or the given
        :attr:`scale_factor`
    
        The algorithm used for interpolation is determined by :attr:`mode`.
    
        Currently temporal, spatial and volumetric sampling are supported, i.e.
        expected inputs are 3-D, 4-D or 5-D in shape.
    
        The input dimensions are interpreted in the form:
        `mini-batch x channels x [optional depth] x [optional height] x width`.
    
        The modes available for resizing are: `nearest`, `linear` (3D-only),
        `bilinear`, `bicubic` (4D-only), `trilinear` (5D-only), `area`, `nearest-exact`
    
        Args:
            input (Tensor): the input tensor
            size (int or Tuple[int] or Tuple[int, int] or Tuple[int, int, int]):
                output spatial size.
            scale_factor (float or Tuple[float]): multiplier for spatial size. If `scale_factor` is a tuple,
                its length has to match the number of spatial dimensions; `input.dim() - 2`.
            mode (str): algorithm used for upsampling:
                ``'nearest'`` | ``'linear'`` | ``'bilinear'`` | ``'bicubic'`` |
                ``'trilinear'`` | ``'area'`` | ``'nearest-exact'``. Default: ``'nearest'``
            align_corners (bool, optional): Geometrically, we consider the pixels of the
                input and output as squares rather than points.
                If set to ``True``, the input and output tensors are aligned by the
                center points of their corner pixels, preserving the values at the corner pixels.
                If set to ``False``, the input and output tensors are aligned by the corner
                points of their corner pixels, and the interpolation uses edge value padding
                for out-of-boundary values, making this operation *independent* of input size
                when :attr:`scale_factor` is kept the same. This only has an effect when :attr:`mode`
                is ``'linear'``, ``'bilinear'``, ``'bicubic'`` or ``'trilinear'``.
                Default: ``False``
            recompute_scale_factor (bool, optional): recompute the scale_factor for use in the
                interpolation calculation. If `recompute_scale_factor` is ``True``, then
                `scale_factor` must be passed in and `scale_factor` is used to compute the
                output `size`. The computed output `size` will be used to infer new scales for
                the interpolation. Note that when `scale_factor` is floating-point, it may differ
                from the recomputed `scale_factor` due to rounding and precision issues.
                If `recompute_scale_factor` is ``False``, then `size` or `scale_factor` will
                be used directly for interpolation. Default: ``None``.
            antialias (bool, optional): flag to apply anti-aliasing. Default: ``False``. Using anti-alias
                option together with ``align_corners=False``, interpolation result would match Pillow
                result for downsampling operation. Supported modes: ``'bilinear'``, ``'bicubic'``.
    
        .. note::
            With ``mode='bicubic'``, it's possible to cause overshoot, in other words it can produce
            negative values or values greater than 255 for images.
            Explicitly call ``result.clamp(min=0, max=255)`` if you want to reduce the overshoot
            when displaying the image.
    
        .. note::
            Mode ``mode='nearest-exact'`` matches Scikit-Image and PIL nearest neighbours interpolation
            algorithms and fixes known issues with ``mode='nearest'``. This mode is introduced to keep
            backward compatibility.
            Mode ``mode='nearest'`` matches buggy OpenCV's ``INTER_NEAREST`` interpolation algorithm.
    
        Note:
            {backward_reproducibility_note}
        """
        if has_torch_function_unary(input):
            return handle_torch_function(
                interpolate,
                (input,),
                input,
                size=size,
                scale_factor=scale_factor,
                mode=mode,
                align_corners=align_corners,
                recompute_scale_factor=recompute_scale_factor,
                antialias=antialias
            )
    
        if mode in ("nearest", "area", "nearest-exact"):
            if align_corners is not None:
                raise ValueError(
                    "align_corners option can only be set with the "
                    "interpolating modes: linear | bilinear | bicubic | trilinear"
                )
        else:
            if align_corners is None:
                align_corners = False
    
        dim = input.dim() - 2  # Number of spatial dimensions.
    
        # Process size and scale_factor.  Validate that exactly one is set.
        # Validate its length if it is a list, or expand it if it is a scalar.
        # After this block, exactly one of output_size and scale_factors will
        # be non-None, and it will be a list (or tuple).
        if size is not None and scale_factor is not None:
>           raise ValueError("only one of size or scale_factor should be defined")
E           ValueError: only one of size or scale_factor should be defined

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/nn/functional.py:3860: ValueError
_________________________ test_invalid_mode_parameter __________________________

    def test_invalid_mode_parameter():
        """
        Test that invalid mode parameter raises appropriate error.
    
        Verifies that:
        1. Error is raised when invalid mode is specified
        2. Error message contains appropriate information
    
        Note: PyTorch raises NotImplementedError for invalid mode.
        The error message format is: "input error: only 3d, 4d and 5d input tensors supported (got Xd) for the modes: ... (got invalid_mode)"
        """
        # Create input tensor
        input_shape = (1, 3, 4, 4)
        x = create_test_tensor(input_shape, dtype=torch.float32, device='cpu')
    
        # Test with invalid mode - PyTorch raises NotImplementedError
        with pytest.raises(NotImplementedError) as exc_info:
            upsample = nn.Upsample(
                scale_factor=2.0,
                mode='invalid_mode'  # Invalid mode
            )
            # Try to use it - error occurs during forward pass
            upsample(x)
    
        # Check error message - PyTorch's actual error message format
        error_msg = str(exc_info.value).lower()
    
        # The error message should contain information about supported modes
        assert "mode" in error_msg or "invalid_mode" in error_msg or "got invalid_mode" in error_msg, (
            f"Error message should mention mode or invalid_mode: {error_msg}"
        )
    
        # Check for the actual PyTorch error message pattern
        # The message contains list of supported modes
        supported_modes = ['nearest', 'linear', 'bilinear', 'bicubic', 'trilinear', 'area', 'nearest-exact']
        mode_found = any(mode in error_msg for mode in supported_modes)
        assert mode_found, (
            f"Error message should list supported modes: {error_msg}"
        )
    
        # Check that the invalid mode is mentioned in the error
        assert "invalid_mode" in error_msg, (
            f"Error message should mention the invalid mode: {error_msg}"
        )
    
        # Test with empty string mode
        with pytest.raises(NotImplementedError) as exc_info2:
            upsample_empty = nn.Upsample(scale_factor=2.0, mode='')
            upsample_empty(x)
    
        error_msg2 = str(exc_info2.value).lower()
        assert "got " in error_msg2, f"Error message for empty mode: {error_msg2}"
    
        # Test with None mode - this should raise TypeError during initialization
>       with pytest.raises(TypeError) as exc_info3:
E       Failed: DID NOT RAISE <class 'TypeError'>

tests/test_torch_nn_modules_upsampling_g3.py:203: Failed
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                                           Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------------------
cleanup.py                                         7      7      4      0     0%   1-15
cleanup_final.py                                   6      6      4      0     0%   1-6
cleanup_test.py                                    3      3      0      0     0%   1-3
run_test.py                                       12     12      4      0     0%   1-24
test_behavior.py                                  48     48      0      0     0%   1-57
test_repr.py                                       9      9      0      0     0%   1-16
test_scale_factor_behavior.py                     32     32      0      0     0%   1-40
tests/test_torch_nn_modules_upsampling_g1.py     162     23     12      3    82%   158->161, 196, 204, 212, 220, 228, 236, 295-298, 306, 314, 322, 359-368, 372-373
tests/test_torch_nn_modules_upsampling_g2.py     226     28     34      5    83%   44-58, 226-234, 435->441, 454-457, 462-470, 608-609, 612
tests/test_torch_nn_modules_upsampling_g3.py     241     99     22      1    56%   22, 32-46, 80-144, 207-261, 383-424, 449, 460, 481, 585
------------------------------------------------------------------------------------------
TOTAL                                            746    267     80      9    61%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_nn_modules_upsampling_g3.py::test_parameter_exclusivity
FAILED tests/test_torch_nn_modules_upsampling_g3.py::test_invalid_mode_parameter
2 failed, 44 passed, 10 skipped, 2 xfailed in 0.99s

Error: exit 1