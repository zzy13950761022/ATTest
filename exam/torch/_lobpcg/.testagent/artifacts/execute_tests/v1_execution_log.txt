=== Run Tests ===
FF...                                                                    [100%]
=================================== FAILURES ===================================
_____ test_dense_basic_eigenvalue_solution[dtype0-cpu-shape0-2-True-ortho] _____

dtype = torch.float32, device = 'cpu', shape = (4, 4), k = 2, largest = True
method = 'ortho'

    @pytest.mark.parametrize("dtype,device,shape,k,largest,method", [
        (torch.float32, 'cpu', (4, 4), 2, True, 'ortho'),
    ])
    def test_dense_basic_eigenvalue_solution(dtype, device, shape, k, largest, method):
        """CASE_01: 密集矩阵基本特征值求解"""
        # Create symmetric positive definite matrix
        A = make_symmetric_positive_definite(shape, dtype=dtype, device=device)
    
        # Compute eigenvalues using lobpcg
>       E_lobpcg, X_lobpcg = lobpcg_module.lobpcg(
            A=A,
            k=k,
            largest=largest,
            method=method
        )

tests/test_torch_lobpcg_basic.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lobpcg.py:567: in lobpcg
    return _lobpcg(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

A = tensor([[15.1695,  2.8110,  3.6046, -4.5324],
        [ 2.8110,  8.5612, -0.2765, -0.9935],
        [ 3.6046, -0.2765,  9.4081, -1.1433],
        [-4.5324, -0.9935, -1.1433,  6.0152]])
k = 2, B = None, X = None, n = 2, iK = None, niter = None
tol = 0.00034641016151377546, largest = True, method = 'ortho', tracker = None
ortho_iparams = None, ortho_fparams = None, ortho_bparams = None

    def _lobpcg(
        A: Tensor,
        k: Optional[int] = None,
        B: Optional[Tensor] = None,
        X: Optional[Tensor] = None,
        n: Optional[int] = None,
        iK: Optional[Tensor] = None,
        niter: Optional[int] = None,
        tol: Optional[float] = None,
        largest: Optional[bool] = None,
        method: Optional[str] = None,
        tracker: None = None,
        ortho_iparams: Optional[Dict[str, int]] = None,
        ortho_fparams: Optional[Dict[str, float]] = None,
        ortho_bparams: Optional[Dict[str, bool]] = None,
    ) -> Tuple[Tensor, Tensor]:
    
        # A must be square:
        assert A.shape[-2] == A.shape[-1], A.shape
        if B is not None:
            # A and B must have the same shapes:
            assert A.shape == B.shape, (A.shape, B.shape)
    
        dtype = _utils.get_floating_dtype(A)
        device = A.device
        if tol is None:
            feps = {torch.float32: 1.2e-07, torch.float64: 2.23e-16}[dtype]
            tol = feps**0.5
    
        m = A.shape[-1]
        k = (1 if X is None else X.shape[-1]) if k is None else k
        n = (k if n is None else n) if X is None else X.shape[-1]
    
        if m < 3 * n:
>           raise ValueError(
                "LPBPCG algorithm is not applicable when the number of A rows (={})"
                " is smaller than 3 x the number of requested eigenpairs (={})".format(m, n)
            )
E           ValueError: LPBPCG algorithm is not applicable when the number of A rows (=4) is smaller than 3 x the number of requested eigenpairs (=2)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lobpcg.py:619: ValueError
______ test_smallest_eigenvalue_solution[dtype0-cpu-shape0-3-False-ortho] ______

dtype = torch.float64, device = 'cpu', shape = (5, 5), k = 3, largest = False
method = 'ortho'

    @pytest.mark.parametrize("dtype,device,shape,k,largest,method", [
        (torch.float64, 'cpu', (5, 5), 3, False, 'ortho'),
    ])
    def test_smallest_eigenvalue_solution(dtype, device, shape, k, largest, method):
        """CASE_02: 最小特征值求解验证"""
        # Create symmetric positive definite matrix
        A = make_symmetric_positive_definite(shape, dtype=dtype, device=device)
    
        # Compute eigenvalues using lobpcg (smallest eigenvalues)
>       E_lobpcg, X_lobpcg = lobpcg_module.lobpcg(
            A=A,
            k=k,
            largest=largest,  # False for smallest eigenvalues
            method=method
        )

tests/test_torch_lobpcg_basic.py:162: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lobpcg.py:567: in lobpcg
    return _lobpcg(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

A = tensor([[ 9.0688,  0.8573, -2.4274,  1.9544, -4.2555],
        [ 0.8573,  6.5047, -0.1984,  0.3962, -1.1352],
        ...9544,  0.3962, -0.2619,  9.6827, -1.8234],
        [-4.2555, -1.1352,  2.8232, -1.8234,  9.7730]], dtype=torch.float64)
k = 3, B = None, X = None, n = 3, iK = None, niter = None
tol = 1.493318452306808e-08, largest = False, method = 'ortho', tracker = None
ortho_iparams = None, ortho_fparams = None, ortho_bparams = None

    def _lobpcg(
        A: Tensor,
        k: Optional[int] = None,
        B: Optional[Tensor] = None,
        X: Optional[Tensor] = None,
        n: Optional[int] = None,
        iK: Optional[Tensor] = None,
        niter: Optional[int] = None,
        tol: Optional[float] = None,
        largest: Optional[bool] = None,
        method: Optional[str] = None,
        tracker: None = None,
        ortho_iparams: Optional[Dict[str, int]] = None,
        ortho_fparams: Optional[Dict[str, float]] = None,
        ortho_bparams: Optional[Dict[str, bool]] = None,
    ) -> Tuple[Tensor, Tensor]:
    
        # A must be square:
        assert A.shape[-2] == A.shape[-1], A.shape
        if B is not None:
            # A and B must have the same shapes:
            assert A.shape == B.shape, (A.shape, B.shape)
    
        dtype = _utils.get_floating_dtype(A)
        device = A.device
        if tol is None:
            feps = {torch.float32: 1.2e-07, torch.float64: 2.23e-16}[dtype]
            tol = feps**0.5
    
        m = A.shape[-1]
        k = (1 if X is None else X.shape[-1]) if k is None else k
        n = (k if n is None else n) if X is None else X.shape[-1]
    
        if m < 3 * n:
>           raise ValueError(
                "LPBPCG algorithm is not applicable when the number of A rows (={})"
                " is smaller than 3 x the number of requested eigenpairs (={})".format(m, n)
            )
E           ValueError: LPBPCG algorithm is not applicable when the number of A rows (=5) is smaller than 3 x the number of requested eigenpairs (=3)

/opt/anaconda3/envs/testagent-experiment/lib/python3.10/site-packages/torch/_lobpcg.py:619: ValueError
================================ tests coverage ================================
______________ coverage: platform darwin, python 3.10.19-final-0 _______________

Name                               Stmts   Miss Branch BrPart  Cover   Missing
------------------------------------------------------------------------------
tests/test_torch_lobpcg_basic.py     142     65     32      7    48%   34-45, 49->55, 52, 59, 66-67, 71-86, 92-95, 117-149, 171-198, 311-316, 320, 325
------------------------------------------------------------------------------
TOTAL                                142     65     32      7    48%
Coverage XML written to file coverage.xml
=========================== short test summary info ============================
FAILED tests/test_torch_lobpcg_basic.py::test_dense_basic_eigenvalue_solution[dtype0-cpu-shape0-2-True-ortho]
FAILED tests/test_torch_lobpcg_basic.py::test_smallest_eigenvalue_solution[dtype0-cpu-shape0-3-False-ortho]
2 failed, 3 passed in 0.76s

Error: exit 1